/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype

/**
 * @namespace
 */
var cc = cc = cc || {};

(function () {
    var initializing = false, fnTest = /\b_super\b/;

    /**
     * The base Class implementation (does nothing)
     * @class
     */
    cc.Class = function () {
    };

    /**
     * Create a new Class that inherits from this Class
     * @param {Array} prop
     * @return {function}
     */
    cc.Class.extend = function (prop) {
        var _super = this.prototype;

        // Instantiate a base Class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function (name, fn) {
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-Class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy Class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.ctor)
                this.ctor.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this Class extendable
        Class.extend = arguments.callee;

        //add implementation method
        Class.implement = function (prop) {
            for (var name in prop) {
                prototype[name] = prop[name];
            }
        };
        return Class;
    };
})();


/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * copy an new object
 * @function
 * @param {object|Array} obj source object
 * @return {Array|object}
 */
cc.clone = function (obj) {
    var newObj = (obj instanceof Array) ? [] : {};
    for (var key in obj) {
        var copy = obj[key];
        if (copy instanceof Array) {
            newObj[key] = cc.clone(copy);
        } else if (((typeof copy) == "object") && !(copy instanceof cc.Node)
            && !(copy instanceof HTMLElement)) {
            newObj[key] = cc.clone(copy);
        } else {
            newObj[key] = copy;
        }
    }
    return newObj;
};

/**
 * Output Debug message.
 * @function
 * @param {String} message
 */
cc.Log = function (message) {
    console.log(message);
};

/**
 * Pop out a message box
 * @param {String} message
 * @function
 */
cc.MessageBox = function (message) {
    console.log(message);
};

// cocos2d debug
if (cc.COCOS2D_DEBUG == 0) {
    cc.Log = function () {
    };
    cc.LogINFO = function () {
    };
    cc.LogERROR = function () {
    };
}
else if (cc.COCOS2D_DEBUG == 1) {
    cc.LogINFO = cc.Log;
    cc.LogERROR = function () {
    };
}
else if (cc.COCOS2D_DEBUG > 1) {
    cc.LogINFO = cc.Log;
    cc.LogERROR = cc.Log;
}// COCOS2D_DEBUG

if (cc._DEBUG) {
    cc.Assert = function (cond, message) {
        if ((typeof console.assert) == "function") {
            console.assert(cond, message);
        } else {
            if (!cond) {
                if (message) {
                    alert(message);
                }
            }
        }
    }
} else {
    cc.Assert = function () {
    };
}

// Enum the language type supportted now
/**
 * English language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_ENGLISH = 0;

/**
 * Chinese language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_CHINESE = 1;

/**
 * French language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_FRENCH = 2;

/**
 * Italian language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_ITALIAN = 3;

/**
 * German language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_GERMAN = 4;

/**
 * Spanish language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_SPANISH = 5;

/**
 * Russian language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_RUSSIAN = 6;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * time value
 * @Class
 * @extends cc.Class
 */
cc.timeval = cc.Class.extend(/** @lends cc.timeval# */{
    /**
     * seconds
     * @type Number
     */
    tv_sec:0,
    /**
     * microseconds
     * @type Number
     */
    tv_usec:0//
});

/**
 * @namespace
 */
cc.Time = {};

/**
 * get time of day
 * @return {cc.timeval}
 */
cc.Time.gettimeofdayCocos2d = function () {
    var timeval = new cc.timeval();
    var tmp = Date.now();
    timeval.tv_usec = (tmp % 1000) * 1000;
    timeval.tv_sec = Math.floor(tmp / 1000);
    return timeval;
};

/**
 * get system date (alias to Date.now())
 * @return {Date}
 */
cc.Time.now = function (){
    return Date.now();
};

/**
 * timer sub
 * @param {cc.timeval | Number} start start value
 * @param {cc.timeval | Number} end end value
 * @return {cc.timeval | Number}
 */
cc.Time.timersubCocos2d = function (start, end) {
    if (!out || !start || !end) {
        return -1;
    }
    if (start instanceof cc.timeval && end instanceof cc.timeval) {
        var out = new cc.timeval();
        out.tv_sec = end.tv_sec - start.tv_sec;
        out.tv_usec = end.tv_usec - start.tv_usec;
        if (end.tv_usec < start.tv_usec) {
            out.tv_usec += 1000000;
            out.tv_sec--;
        }
        return out;
    }
    else if (!isNaN(start) && !isNaN(end)) {
        return end - start;
    }
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * mixin cc.Codec
 */
cc.Codec = {name:'Jacob__Codec'};

/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @returns {String} Unpacked byte string
 */
cc.unzip = function () {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @returns {String} Unpacked byte string
 */
cc.unzipBase64 = function () {
    var tmpInput = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return   cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [tmpInput]);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
cc.unzipBase64AsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzipBase64(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};

/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
cc.unzipAsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzip(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * mixin cc.Codec.Base64
 */
cc.Codec.Base64 = {name:'Jacob__Codec__Base64'};

cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * <p>
 *    cc.Codec.Base64.decode(input[, unicode=false]) -> String (http://en.wikipedia.org/wiki/Base64).
 * </p>
 * @function
 * @param {String} input The base64 encoded string to decode
 * @return {String} Decodes a base64 encoded String
 * @example
 * //decode string
 * cc.Codec.Base64.decode("U29tZSBTdHJpbmc="); // => "Some String"
 */
cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
    var output = [],
        chr1, chr2, chr3,
        enc1, enc2, enc3, enc4,
        i = 0;

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    while (i < input.length) {
        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output.push(String.fromCharCode(chr1));

        if (enc3 != 64) {
            output.push(String.fromCharCode(chr2));
        }
        if (enc4 != 64) {
            output.push(String.fromCharCode(chr3));
        }
    }

    output = output.join('');

    return output;
};

/**
 * <p>
 *    Converts an input string encoded in base64 to an array of integers whose<br/>
 *    values represent the decoded string's characters' bytes.
 * </p>
 * @function
 * @param {String} input The String to convert to an array of Integers
 * @param {Number} bytes
 * @return {Array}
 * @example
 * //decode string to array
 * var decodeArr = cc.Codec.Base64.decodeAsArray("U29tZSBTdHJpbmc=");
 */
cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
    var dec = this.decode(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }

    return ar;
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * See cc.Codec.GZip.gunzip.
 * @param {Array | String} data The bytestream to decompress
 * Constructor
 */
cc.Codec.GZip = function Jacob__GZip(data) {
    this.data = data;

    this.debug = false;
    this.gpflags = undefined;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = new Array(32768);
    this.bIdx = 0;
    this.modeZIP = false;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = undefined;
    this.literalTree = new Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = new Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = new Array(17);
    this.fpos[0] = 0;
    this.flens = undefined;
    this.fmax = undefined;
};

/**
 * Unzips the gzipped data of the 'data' argument.
 * @param string  The bytestream to decompress. Either an array of Integers between 0 and 255, or a String.
 * @return {String}
 */
cc.Codec.GZip.gunzip = function (string) {
    if (string.constructor === Array) {
    } else if (string.constructor === String) {
    }
    var gzip = new cc.Codec.GZip(string);
    return gzip.gunzip()[0][0];
};

cc.Codec.GZip.HufNode = function () {
    this.b0 = 0;
    this.b1 = 0;
    this.jump = null;
    this.jumppos = -1;
};

/**
 * @constant
 * @type Number
 */
cc.Codec.GZip.LITERALS = 288;
/**
 * @constant
 * @type Number
 */
cc.Codec.GZip.NAMEMAX = 256;

cc.Codec.GZip.bitReverse = [
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
];
cc.Codec.GZip.cplens = [
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];
cc.Codec.GZip.cplext = [
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
];
/* 99==invalid */
cc.Codec.GZip.cpdist = [
    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
    0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
    0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
    0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
];
cc.Codec.GZip.cpdext = [
    0, 0, 0, 0, 1, 1, 2, 2,
    3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13
];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


/**
 * gunzip
 * @return {Array}
 */
cc.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];

    //convertToByteArray(input);
    //if (this.debug) alert(this.data);

    this.nextFile();
    return this.unzipped;
};

cc.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    if (this.bytepos < this.data.length) {
        //return this.data[this.bytepos++]; // Array
        return this.data.charCodeAt(this.bytepos++);
    } else {
        return -1;
    }
};

cc.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1;
};

cc.Codec.GZip.prototype.readBit = function () {
    var carry;
    this.bits++;
    carry = (this.bb & 1);
    this.bb >>= 1;
    if (this.bb == 0) {
        this.bb = this.readByte();
        carry = (this.bb & 1);
        this.bb = (this.bb >> 1) | 0x80;
    }
    return carry;
};

cc.Codec.GZip.prototype.readBits = function (a) {
    var res = 0,
        i = a;

    while (i--) res = (res << 1) | this.readBit();
    if (a) res = cc.Codec.GZip.bitReverse[res] >> (8 - a);

    return res;
};

cc.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0;
};

cc.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    if (this.bIdx == 0x8000) this.bIdx = 0;
};

cc.Codec.GZip.prototype.IsPat = function () {
    while (1) {
        if (this.fpos[this.len] >= this.fmax)       return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
    }
};

cc.Codec.GZip.prototype.Rec = function () {
    var curplace = this.Places[this.treepos];
    var tmp;
    //if (this.debug) document.write("<br>len:"+this.len+" treepos:"+this.treepos);
    if (this.len == 17) { //war 17
        return -1;
    }
    this.treepos++;
    this.len++;

    tmp = this.IsPat();
    //if (this.debug) document.write("<br>IsPat "+tmp);
    if (tmp >= 0) {
        curplace.b0 = tmp;
        /* leaf cell for 0-bit */
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
    } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
        if (this.Rec()) return -1;
    }
    tmp = this.IsPat();
    if (tmp >= 0) {
        curplace.b1 = tmp;
        /* leaf cell for 1-bit */
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = null;
        /* Just for the display routine */
    } else {
        /* Not a Leaf cell */
        curplace.b1 = 0x8000;
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
    }
    this.len--;
    return 0;
};

cc.Codec.GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
    var i;
    /* Create the Huffman decode tree/table */
    //if (this.debug) document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
    this.Places = currentTree;
    this.treepos = 0;
    this.flens = lengths;
    this.fmax = numval;
    for (i = 0; i < 17; i++) this.fpos[i] = 0;
    this.len = 0;
    if (this.Rec()) {
        //if (this.debug) alert("invalid huffman tree\n");
        return -1;
    }
    // if (this.debug) {
    //   document.write('<br>Tree: '+this.Places.length);
    //   for (var a=0;a<32;a++){
    //     document.write("Places["+a+"].b0="+this.Places[a].b0+"<br>");
    //     document.write("Places["+a+"].b1="+this.Places[a].b1+"<br>");
    //   }
    // }

    return 0;
};

cc.Codec.GZip.prototype.DecodeValue = function (currentTree) {
    var len, i,
        xtreepos = 0,
        X = currentTree[xtreepos],
        b;

    /* decode one symbol of the data */
    while (1) {
        b = this.readBit();
        // if (this.debug) document.write("b="+b);
        if (b) {
            if (!(X.b1 & 0x8000)) {
                // if (this.debug) document.write("ret1");
                return X.b1;
                /* If leaf node, return data */
            }
            X = X.jump;
            len = currentTree.length;
            for (i = 0; i < len; i++) {
                if (currentTree[i] === X) {
                    xtreepos = i;
                    break;
                }
            }
        } else {
            if (!(X.b0 & 0x8000)) {
                // if (this.debug) document.write("ret2");
                return X.b0;
                /* If leaf node, return data */
            }
            xtreepos++;
            X = currentTree[xtreepos];
        }
    }
    // if (this.debug) document.write("ret3");

    return -1;
};

cc.Codec.GZip.prototype.DeflateLoop = function () {
    var last, c, type, i, len;

    do {
        last = this.readBit();
        type = this.readBits(2);

        if (type == 0) {
            var blockLen, cSum;

            // Stored
            this.byteAlign();
            blockLen = this.readByte();
            blockLen |= (this.readByte() << 8);

            cSum = this.readByte();
            cSum |= (this.readByte() << 8);

            if (((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n"); // FIXME: use throw
            }
            while (blockLen--) {
                c = this.readByte();
                this.addBuffer(c);
            }
        } else if (type == 1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while (1) {
                /*
                 256    0000000        0
                 :   :     :
                 279    0010111        23
                 0   00110000    48
                 :    :      :
                 143    10111111    191
                 280 11000000    192
                 :    :      :
                 287 11000111    199
                 144    110010000    400
                 :    :       :
                 255    111111111    511

                 Note the bit order!
                 */
                j = (cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1);
                if (j > 23) {
                    j = (j << 1) | this.readBit();
                    /* 48..255 */

                    if (j > 199) {              /* 200..255 */
                        j -= 128;
                        /*  72..127 */
                        j = (j << 1) | this.readBit();
                        /* 144..255 << */
                    } else {                    /*  48..199 */
                        j -= 48;
                        /*   0..151 */
                        if (j > 143) {
                            j = j + 136;
                            /* 280..287 << */
                            /*   0..143 << */
                        }
                    }
                } else {                      /*   0..23 */
                    j += 256;
                    /* 256..279 << */
                }
                if (j < 256) {
                    this.addBuffer(j);
                } else if (j == 256) {
                    /* EOF */
                    break; // FIXME: make this the loop-condition
                } else {
                    var len, dist;

                    j -= 256 + 1;
                    /* bytes + EOF */
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];

                    j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    }
                    dist += cc.Codec.GZip.cpdist[j];

                    for (j = 0; j < len; j++) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                }
            } // while

        } else if (type == 2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288 + 32);    // "static" just to preserve stack

            // Dynamic Huffman tables

            literalCodes = 257 + this.readBits(5);
            distCodes = 1 + this.readBits(5);
            lenCodes = 4 + this.readBits(4);
            for (j = 0; j < 19; j++) {
                ll[j] = 0;
            }

            // Get the decode tree code lengths

            for (j = 0; j < lenCodes; j++) {
                ll[cc.Codec.GZip.border[j]] = this.readBits(3);
            }
            len = this.distanceTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new cc.Codec.GZip.HufNode();
            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) {
            //   document.write("<br>distanceTree");
            //   for(var a=0;a<this.distanceTree.length;a++){
            //     document.write("<br>"+this.distanceTree[a].b0+" "+this.distanceTree[a].b1+" "+this.distanceTree[a].jump+" "+this.distanceTree[a].jumppos);
            //   }
            // }

            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z = -1;
            // if (this.debug) document.write("<br>n="+n+" bits: "+this.bits+"<br>");
            while (i < n) {
                z++;
                j = this.DecodeValue(this.distanceTree);
                // if (this.debug) document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+this.bits+"<br>");
                if (j < 16) {    // length of code in bits (0..15)
                    ll[i++] = j;
                } else if (j == 16) {    // repeat last length 3 to 6 times
                    var l;
                    j = 3 + this.readBits(2);
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i - 1] : 0;
                    while (j--) {
                        ll[i++] = l;
                    }
                } else {
                    if (j == 17) {        // 3 to 10 zero length codes
                        j = 3 + this.readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes
                        j = 11 + this.readBits(7);
                    }
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    while (j--) {
                        ll[i++] = 0;
                    }
                }
            } // while

            // Can overwrite tree decode tree as it is not used anymore
            len = this.literalTree.length;
            for (i = 0; i < len; i++)
                this.literalTree[i] = new cc.Codec.GZip.HufNode();
            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new cc.Codec.GZip.HufNode();
            var ll2 = new Array();
            for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) document.write("<br>literalTree");
            while (1) {
                j = this.DecodeValue(this.literalTree);
                if (j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if (j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];

                    j = this.DecodeValue(this.distanceTree);
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    }
                    dist += cc.Codec.GZip.cpdist[j];
                    while (len--) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                } else {
                    this.addBuffer(j);
                }
            } // while
        }
    } while (!last);
    this.flushBuffer();

    this.byteAlign();
    return 0;
};

cc.Codec.GZip.prototype.unzipFile = function (name) {
    var i;
    this.gunzip();
    for (i = 0; i < this.unzipped.length; i++) {
        if (this.unzipped[i][1] == name) {
            return this.unzipped[i][0];
        }
    }
};

cc.Codec.GZip.prototype.nextFile = function () {
    // if (this.debug) alert("NEXTFILE");

    this.outputArr = [];
    this.modeZIP = false;

    var tmp = [];
    tmp[0] = this.readByte();
    tmp[1] = this.readByte();
    // if (this.debug) alert("type: "+tmp[0]+" "+tmp[1]);

    if (tmp[0] == 0x78 && tmp[1] == 0xda) { //GZIP
        // if (this.debug) alert("GEONExT-GZIP");
        this.DeflateLoop();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
        this.files++;
    }
    if (tmp[0] == 0x1f && tmp[1] == 0x8b) { //GZIP
        // if (this.debug) alert("GZIP");
        this.skipdir();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "file"];
        this.files++;
    }
    if (tmp[0] == 0x50 && tmp[1] == 0x4b) { //ZIP
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (tmp[2] == 0x03 && tmp[3] == 0x04) {
            //MODE_ZIP
            tmp[0] = this.readByte();
            tmp[1] = this.readByte();
            // if (this.debug) alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);

            this.gpflags = this.readByte();
            this.gpflags |= (this.readByte() << 8);
            // if (this.debug) alert("gpflags: "+this.gpflags);

            var method = this.readByte();
            method |= (this.readByte() << 8);
            // if (this.debug) alert("method: "+method);

            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();

//       var crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);

            var compSize = this.readByte();
            compSize |= (this.readByte() << 8);
            compSize |= (this.readByte() << 16);
            compSize |= (this.readByte() << 24);

            var size = this.readByte();
            size |= (this.readByte() << 8);
            size |= (this.readByte() << 16);
            size |= (this.readByte() << 24);

            // if (this.debug) alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);

            var filelen = this.readByte();
            filelen |= (this.readByte() << 8);

            var extralen = this.readByte();
            extralen |= (this.readByte() << 8);

            // if (this.debug) alert("filelen "+filelen);
            i = 0;
            this.nameBuf = [];
            while (filelen--) {
                var c = this.readByte();
                if (c == "/" | c == ":") {
                    i = 0;
                } else if (i < cc.Codec.GZip.NAMEMAX - 1) {
                    this.nameBuf[i++] = String.fromCharCode(c);
                }
            }
            // if (this.debug) alert("nameBuf: "+this.nameBuf);

            if (!this.fileout) this.fileout = this.nameBuf;

            var i = 0;
            while (i < extralen) {
                c = this.readByte();
                i++;
            }

            // if (size = 0 && this.fileOut.charAt(this.fileout.length-1)=="/"){
            //   //skipdir
            //   // if (this.debug) alert("skipdir");
            // }
            if (method == 8) {
                this.DeflateLoop();
                // if (this.debug) alert(this.outputArr.join(''));
                this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
                this.files++;
            }
            this.skipdir();
        }
    }
};

cc.Codec.GZip.prototype.skipdir = function () {
    var tmp = [];
    var compSize, size, os, i, c;

    if ((this.gpflags & 8)) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();

//     if (tmp[0] == 0x50 && tmp[1] == 0x4b && tmp[2] == 0x07 && tmp[3] == 0x08) {
//       crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);
//     } else {
//       crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
//     }

        compSize = this.readByte();
        compSize |= (this.readByte() << 8);
        compSize |= (this.readByte() << 16);
        compSize |= (this.readByte() << 24);

        size = this.readByte();
        size |= (this.readByte() << 8);
        size |= (this.readByte() << 16);
        size |= (this.readByte() << 24);
    }

    if (this.modeZIP) this.nextFile();

    tmp[0] = this.readByte();
    if (tmp[0] != 8) {
        // if (this.debug) alert("Unknown compression method!");
        return 0;
    }

    this.gpflags = this.readByte();
    // if (this.debug && (this.gpflags & ~(0x1f))) alert("Unknown flags set!");

    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();

    this.readByte();
    os = this.readByte();

    if ((this.gpflags & 4)) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        // if (this.debug) alert("Extra field size: "+this.len);
        for (i = 0; i < this.len; i++)
            this.readByte();
    }

    if ((this.gpflags & 8)) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
            if (c == "7" || c == ":")
                i = 0;
            if (i < cc.Codec.GZip.NAMEMAX - 1)
                this.nameBuf[i++] = c;
        }
        //this.nameBuf[i] = "\0";
        // if (this.debug) alert("original file name: "+this.nameBuf);
    }

    if ((this.gpflags & 16)) {
        while (c = this.readByte()) { // FIXME: looks like they read to the end of the stream, should be doable more efficiently
            //FILE COMMENT
        }
    }

    if ((this.gpflags & 2)) {
        this.readByte();
        this.readByte();
    }

    this.DeflateLoop();

//   crc = this.readByte();
//   crc |= (this.readByte()<<8);
//   crc |= (this.readByte()<<16);
//   crc |= (this.readByte()<<24);

    size = this.readByte();
    size |= (this.readByte() << 8);
    size |= (this.readByte() << 16);
    size |= (this.readByte() << 24);

    if (this.modeZIP) this.nextFile();
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * PI is the ratio of a circle's circumference to its diameter.
 * @constant
 * @type Number
 */
cc.PI = Math.PI;

/**
 * @constant
 * @type Number
 */
cc.RAD = cc.PI / 180;

/**
 * @constant
 * @type Number
 */
cc.DEG = 180 / cc.PI;

/**
 * <p>
 * simple macro that swaps 2 variables<br/>
 *  modified from c++ macro, you need to pass in the x and y variables names in string, <br/>
 *  and then a reference to the whole object as third variable
 * </p>
 * @param x
 * @param y
 * @param ref
 * @function
 * @deprecated
 */
cc.SWAP = function (x, y, ref) {
    if ((typeof ref) == 'object' && (typeof ref.x) != 'undefined' && (typeof ref.y) != 'undefined') {
        var tmp = ref[x];
        ref[x] = ref[y];
        ref[y] = tmp;
    } else {
        cc.Assert(false, "CC_SWAP is being modified from original macro, please check usage");
    }
};

/**
 * returns a random float between -1 and 1
 * @return {Number}
 * @function
 */
cc.RANDOM_MINUS1_1 = function () {
    return (Math.random() - 0.5) * 2;
};

/**
 * returns a random float between 0 and 1
 * @return {Number}
 * @function
 */
cc.RANDOM_0_1 = function () {
    return Math.random();
};

/**
 * converts degrees to radians
 * @param {Number} angle
 * @return {Number}
 * @function
 */
cc.DEGREES_TO_RADIANS = function (angle) {
    return angle * cc.RAD;
};

/**
 * converts radians to degrees
 * @param {Number} angle
 * @return {Number}
 * @function
 */
cc.RADIANS_TO_DEGREES = function (angle) {
    return angle * cc.DEG;
};

/**
 * default gl blend src function. Compatible with premultiplied alpha images.
 * @constant
 * @type Number
 */
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 0x0302;

/**
 * default gl blend dst function. Compatible with premultiplied alpha images.
 * @constant
 * @type Number
 */
cc.BLEND_DST = 0x0303;

/**
 * <p>
 *     GL states that are enabled:<br/>
 *       - GL_TEXTURE_2D<br/>
 *       - GL_VERTEX_ARRAY<br/>
 *       - GL_TEXTURE_COORD_ARRAY<br/>
 *       - GL_COLOR_ARRAY<br/>
 * </p>
 * @function
 */
cc.ENABLE_DEFAULT_GL_STATES = function () {
    //TODO OPENGL STUFF
    /*
     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_COLOR_ARRAY);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
     glEnable(GL_TEXTURE_2D);*/
};

/**
 * <p>
 *   Disable default GL states:<br/>
 *     - GL_TEXTURE_2D<br/>
 *     - GL_TEXTURE_COORD_ARRAY<br/>
 *     - GL_COLOR_ARRAY<br/>
 * </p>
 * @function
 */
cc.DISABLE_DEFAULT_GL_STATES = function () {
    //TODO OPENGL
    /*
     glDisable(GL_TEXTURE_2D);
     glDisableClientState(GL_COLOR_ARRAY);
     glDisableClientState(GL_TEXTURE_COORD_ARRAY);
     glDisableClientState(GL_VERTEX_ARRAY);
     */
};

/**
 * @constant
 * @type Number
 */
cc.FLT_EPSILON = 0.0000001192092896;

/**
 * <p>
 *     On Mac it returns 1;<br/>
 *     On iPhone it returns 2 if RetinaDisplay is On. Otherwise it returns 1
 * </p>
 * @function
 */
cc.CONTENT_SCALE_FACTOR = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.Director.sharedDirector().getContentScaleFactor();
} : function () {
    return 1;
};

/**
 * Converts a rect in pixels to points
 * @param {cc.Rect} pixel
 * @function
 */
cc.RECT_PIXELS_TO_POINTS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (pixel) {
    return cc.RectMake(pixel.origin.x / cc.CONTENT_SCALE_FACTOR(), pixel.origin.y / cc.CONTENT_SCALE_FACTOR(),
        pixel.size.width / cc.CONTENT_SCALE_FACTOR(), pixel.size.height / cc.CONTENT_SCALE_FACTOR());
} : function (p) {
    return p;
};

/**
 * Converts a rect in points to pixels
 * @param {cc.Rect} point
 * @function
 */
cc.RECT_POINTS_TO_PIXELS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (point) {
    return cc.RectMake(point.origin.x * cc.CONTENT_SCALE_FACTOR(), point.origin.y * cc.CONTENT_SCALE_FACTOR(),
        point.size.width * cc.CONTENT_SCALE_FACTOR(), point.size.height * cc.CONTENT_SCALE_FACTOR());
} : function (p) {
    return p;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 * The current version of Cocos2d-html5 being used.<br/>
 * Please DO NOT remove this String, it is an important flag for bug tracking.<br/>
 * If you post a bug to forum, please attach this flag.
 * </p>
 * @constant
 * @type String
 */
cc.ENGINE_VERSION = "Cocos2d-html5-v0.5.0-alpha2";


/**
 * <p>
 *   If enabled, the texture coordinates will be calculated by using this formula: <br/>
 *      - texCoord.left = (rect.origin.x*2+1) / (texture.wide*2);                  <br/>
 *      - texCoord.right = texCoord.left + (rect.size.width*2-2)/(texture.wide*2); <br/>
 *                                                                                 <br/>
 *  The same for bottom and top.                                                   <br/>
 *                                                                                 <br/>
 *  This formula prevents artifacts by using 99% of the texture.                   <br/>
 *  The "correct" way to prevent artifacts is by using the spritesheet-artifact-fixer.py or a similar tool.<br/>
 *                                                                                  <br/>
 *  Affected nodes:                                                                 <br/>
 *      - cc.Sprite / cc.SpriteBatchNode and subclasses: cc.LabelBMFont, cc.TMXTiledMap <br/>
 *      - cc.LabelAtlas                                                              <br/>
 *      - cc.QuadParticleSystem                                                      <br/>
 *      - cc.TileMap                                                                 <br/>
 *                                                                                  <br/>
 *  To enabled set it to 1. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;

/**
 * <p>
 *    If enabled, FontLabel will be used to render .ttf files.<br/>
 *    If the .ttf file is not found, then it will use the standard UIFont class<br/>
 *    If disabled, the standard UIFont class will be used.<br/>
 *    <br/>
 *    To disable set it to 0. Enabled by default.<br/>
 *    Only valid for cocos2d-ios. Not supported on cocos2d-mac<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.FONT_LABEL_SUPPORT = 1;

/**
 * <p>
 *     If enabled, then the FPS will be drawn using cc.LabelAtlas (fast rendering).<br/>
 *     You will need to add the fps_images.png to your project.<br/>
 *     If disabled, the FPS will be rendered using cc.Label (slow rendering)<br/>
 *     <br/>
 *     To enable set it to a value different than 0. Enabled by default.<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.DIRECTOR_FAST_FPS = 1;

/**
 * <p>
 *   Senconds between FPS updates.<br/>
 *   0.5 seconds, means that the FPS number will be updated every 0.5 seconds.<br/>
 *   Having a bigger number means a more reliable FPS<br/>
 *   <br/>
 *   Default value: 0.1f<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.DIRECTOR_FPS_INTERVAL = 0.5;

/**
 * <p>
 *    If enabled, and only when it is used with cc.FastDirector, the main loop will wait 0.04 seconds to<br/>
 *    dispatch all the events, even if there are not events to dispatch.<br/>
 *    If your game uses lot's of events (eg: touches) it might be a good idea to enable this feature.<br/>
 *    Otherwise, it is safe to leave it disabled.<br/>
 *    <br/>
 *    To enable set it to 1. Disabled by default.<br/>
 * </p>
 * @warning This feature is experimental
 * @constant
 * @type Number
 */
cc.DIRECTOR_DISPATCH_FAST_EVENTS = 0;

/**
 * <p>
 *    If enabled, cocos2d-mac will run on the Display Link thread. If disabled cocos2d-mac will run in its own thread.<br/>
 *    <br/>
 *    If enabled, the images will be drawn at the "correct" time, but the events might not be very responsive.<br/>
 *    If disabled, some frames might be skipped, but the events will be dispatched as they arrived.<br/>
 *    To enable set it to a 1, to disable it set to 0. Enabled by default.<br/>
 *    <br/>
 *    Only valid for cocos2d-mac. Not supported on cocos2d-ios.
 * </p>
 * @constant
 * @type Number
 */
cc.DIRECTOR_MAC_USE_DISPLAY_LINK_THREAD = 1;

/**
 * <p>
 *    If enabled, the cc.Node objects (cc.Sprite, cc.Label,etc) will be able to render in subpixels.<br/>
 *    If disabled, integer pixels will be used.<br/>
 *    <br/>
 *    To enable set it to 1. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.COCOSNODE_RENDER_SUBPIXEL = 1;

/**
 * <p>
 *   If enabled, the cc.Sprite objects rendered with cc.SpriteBatchNode will be able to render in subpixels.<br/>
 *   If disabled, integer pixels will be used.<br/>
 *   <br/>
 *   To enable set it to 1. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;

/**
 * <p>
 *    If enabled, batch nodes (texture atlas and particle system) will use VBO instead of vertex list (VBO is recommended by Apple)<br/>
 *    <br/>
 *    To enable set it to 1.<br/>
 *    Enabled by default on iPhone with ARMv7 processors, iPhone Simulator and Mac<br/>
 *    Disabled by default on iPhone with ARMv6 processors.
 * </p>
 * @constant
 * @type Number
 */
cc.USES_VBO = 1;

/**
 * <p>
 *   If enabled, cc.Node will transform the nodes using a cached Affine matrix.<br/>
 *   If disabled, the node will be transformed using glTranslate,glRotate,glScale.<br/>
 *   Using the affine matrix only requires 2 GL calls.<br/>
 *   Using the translate/rotate/scale requires 5 GL calls.<br/>
 *   But computing the Affine matrix is relative expensive.<br/>
 *   But according to performance tests, Affine matrix performs better.<br/>
 *   This parameter doesn't affect cc.SpriteBatchNode nodes.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.NODE_TRANSFORM_USING_AFFINE_MATRIX = 1;

/**
 * <p>
 *     If most of your imamges have pre-multiplied alpha, set it to 1 (if you are going to use .PNG/.JPG file images).<br/>
 *     Only set to 0 if ALL your images by-pass Apple UIImage loading system (eg: if you use libpng or PVR images)<br/>
 *     <br/>
 *     To enable set it to a value different than 0. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;

/**
 * <p>
 *   Use GL_TRIANGLE_STRIP instead of GL_TRIANGLES when rendering the texture atlas.<br/>
 *   It seems it is the recommend way, but it is much slower, so, enable it at your own risk<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;

/**
 * <p>
 *  If enabled, NPOT textures will be used where available. Only 3rd gen (and newer) devices support NPOT textures.<br/>
 *  NPOT textures have the following limitations:<br/>
 *     - They can't have mipmaps<br/>
 *     - They only accept GL_CLAMP_TO_EDGE in GL_TEXTURE_WRAP_{S,T}<br/>
 *  <br/>
 *  To enable set it to a value different than 0. Disabled by default. <br/>
 *  <br/>
 *  This value governs only the PNG, GIF, BMP, images.<br/>
 *  This value DOES NOT govern the PVR (PVR.GZ, PVR.CCZ) files. If NPOT PVR is loaded, then it will create an NPOT texture ignoring this value.
 * </p>
 * @constant
 * @type Number
 * @deprecated This value will be removed in 1.1 and NPOT textures will be loaded by default if the device supports it.
 */
cc.TEXTURE_NPOT_SUPPORT = 0;

/**
 * <p>
 *    If enabled, cocos2d supports retina display.<br/>
 *    For performance reasons, it's recommended disable it in games without retina display support, like iPad only games.<br/>
 *    <br/>
 *    To enable set it to 1. Use 0 to disable it. Enabled by default.<br/>
 *    <br/>
 *    This value governs only the PNG, GIF, BMP, images.<br/>
 *    This value DOES NOT govern the PVR (PVR.GZ, PVR.CCZ) files. If NPOT PVR is loaded, then it will create an NPOT texture ignoring this value.
 * </p>
 * @constant
 * @type Number
 * @deprecated This value will be removed in 1.1 and NPOT textures will be loaded by default if the device supports it.
 */
cc.RETINA_DISPLAY_SUPPORT = 1;

/**
 * <p>
 *    It's the suffix that will be appended to the files in order to load "retina display" images.<br/>
 *    <br/>
 *    On an iPhone4 with Retina Display support enabled, the file @"sprite-hd.png" will be loaded instead of @"sprite.png".<br/>
 *    If the file doesn't exist it will use the non-retina display image.<br/>
 *    <br/>
 *    Platforms: Only used on Retina Display devices like iPhone 4.
 * </p>
 * @constant
 * @type String
 */
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";

/**
 * <p>
 *   If enabled, it will use LA88 (16-bit textures) on Neon devices for cc.LabelTTF objects.<br/>
 *   If it is disabled, or if it is used on another architecture it will use A8 (8-bit textures).<br/>
 *   On Neon devices, LA88 textures are 6% faster than A8 textures, but then will consume 2x memory.<br/>
 *   <br/>
 *   This feature is disabled by default.<br/>
 *   <br/>
 *   Platforms: Only used on ARM Neon architectures like iPhone 3GS or newer and iPad.
 * </p>
 * @constant
 * @type Number
 */
cc.USE_LA88_LABELS_ON_NEON_ARCH = 0;

/**
 * <p>
 *   If enabled, all subclasses of cc.Sprite will draw a bounding box<br/>
 *   Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default:<br/>
 *      0 -- disabled<br/>
 *      1 -- draw bounding box<br/>
 *      2 -- draw texture box
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITE_DEBUG_DRAW = 0;

/**
 * <p>
 *    If enabled, all subclasses of cc.Sprite that are rendered using an cc.SpriteBatchNode draw a bounding box.<br/>
 *    Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *    <br/>
 *    To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;

/**
 * <p>
 *   If enabled, all subclasses of cc.LabelBMFont will draw a bounding box <br/>
 *   Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default.<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.LABELBMFONT_DEBUG_DRAW = 0;

/**
 * <p>
 *    If enabled, all subclasses of cc.LabeltAtlas will draw a bounding box<br/>
 *    Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *    <br/>
 *    To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.LABELATLAS_DEBUG_DRAW = 0;

/**
 * <p>
 *     If enabled, will activate various profilers withing cocos2d. This statistical data will be output to the console<br/>
 *     once per second showing average time (in milliseconds) required to execute the specific routine(s).<br/>
 *     Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *     <br/>
 *     To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.ENABLE_PROFILERS = 0;

/**
 * whether or not support retina display
 * @constant
 * @type Number
 */
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;

/**
 * default engine
 * @constant
 * @type String
 */
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.SAX_NONE = 0;

/**
 * @constant
 * @type Number
 */
cc.SAX_KEY = 1;

/**
 * @constant
 * @type Number
 */
cc.SAX_DICT = 2;

/**
 * @constant
 * @type Number
 */
cc.SAX_INT = 3;

/**
 * @constant
 * @type Number
 */
cc.SAX_REAL = 4;

/**
 * @constant
 * @type Number
 */
cc.SAX_STRING = 5;

/**
 * @constant
 * @type Number
 */
cc.SAX_ARRAY = 6;

/**
 * @namespace
 */
cc.FileUtils = {};

/**
 * Get resource file data
 * @function
 * @param {String} fileName The resource file name which contain the path
 * @param {Number} mode mode The read mode of the file
 * @param {Number} size If get the file data succeed the it will be the data size,or it will be 0
 * @warning If you get the file data succeed,you must delete it after used.
 * @deprecated
 */
cc.FileUtils.getFileData = function (fileName, mode, size) {
};

/**
 * Get resource file data from zip file
 * @function
 * @param {String} pszZipFilePath
 * @param {String} fileName fileName The resource file name which contain the relative path of zip file
 * @param {Number} size size If get the file data succeed the it will be the data size,or it will be 0
 * @warning If you get the file data succeed,you must delete it after used.
 * @deprecated
 */
cc.FileUtils.getFileDataFromZip = function (pszZipFilePath, fileName, size) {
};

/**
 * removes the HD suffix from a path
 * @function
 * @param {String} path
 * @deprecated
 */
cc.FileUtils.ccRemoveHDSuffixFromFile = function (path) {
};

//////////////////////////////////////////////////////////////////////////
// Notification support when getFileData from invalid file path.
//////////////////////////////////////////////////////////////////////////
/**
 * Notification support when getFileData from invalid file path.
 * @function
 * @type {Boolean}
 */
cc.popupNotify = true;

/**
 * Generate the absolute path of the file.
 * @function
 * @param {String} pszRelativePath
 * @return {String} The absolute path of the file.
 * @warning We only add the ResourcePath before the relative path of the file. <br/>
 * If you have not set the ResourcePath,the function add "/NEWPLUS/TDA_DATA/UserData/" as default.<br/>
 * You can set ResourcePath by function void setResourcePath(const char *resourcePath);
 */
cc.FileUtils.fullPathFromRelativePath = function (pszRelativePath) {
    return pszRelativePath;
};

/**
 * Generate the relative path of the file.
 * @function
 * @param {String} filename
 * @param {String} relativeFile
 * @return {String}
 */
cc.FileUtils.fullPathFromRelativeFile = function (filename, relativeFile) {
    var tmpPath;
    if (filename) {
        tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("/") + 1);
        return tmpPath + filename;
    }
    else{
        tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("."));
        tmpPath = tmpPath + ".png";
        return tmpPath;
    }
};

/**
 * Set the ResourcePath,we will find resource in this path
 * @function
 * @param {String} resourcePath The absolute resource path
 * @warning Don't call this function in android and iOS, it has not effect.<br/>
 * In android, if you want to read file other than apk, you shoud use invoke getFileData(), and pass the<br/>
 * absolute path.
 * @deprecated
 */
cc.FileUtils.setResourcePath = function (resourcePath) {
};

/**
 * Generate an Dictionary of object by file
 * @function
 * @param fileName The file name of *.plist file
 * @return {object} The Dictionary of object generated from the file
 */
cc.FileUtils.dictionaryWithContentsOfFile = function (fileName) {
    var parser = cc.SAXParser.shareParser();
    this.rootDict = parser.parse(fileName);
    return this.rootDict;
};

/**
 * The same meaning as dictionaryWithContentsOfFile(), but it doesn't call autorelease, so the invoker should call release().
 * @function
 * @param {String} fileName
 * @return {object} The Dictionary of object generated from the file
 */
cc.FileUtils.dictionaryWithContentsOfFileThreadSafe = function (fileName) {
    var tMaker = new cc.DictMaker();
    return tMaker.dictionaryWithContentsOfFile(fileName);
};

/**
 * Get the writeable path
 * @function
 * @return  The path that can write/read file
 * @deprecated
 */
cc.FileUtils.getWriteablePath = function () {
};

/**
 * Set whether pop-up a message box when the image load failed
 * @function
 * @param {Boolean} notify
 */
cc.FileUtils.setIsPopupNotify = function (notify) {
    cc.popupNotify = notify;
};

/**
 * Get whether pop-up a message box when the image load failed
 * @function
 * @return {Boolean}
 */
cc.FileUtils.getIsPopupNotify = function () {
    return cc.popupNotify;
};

/**
 * plist Dictionary Maker
 * @class
 * @extends cc.Class
 * @example
 * //create a DictMaker
 * var tMaker = new cc.DictMaker();
 * tMaker.dictionaryWithContentsOfFile(fileName);
 */
cc.DictMaker = cc.Class.extend(/** @lends cc.DictMaker# */{
    rootDict:[],
    /**
     * Generate dictionary with contents of file
     * @param {String} fileName
     * @return {Array}
     */
    dictionaryWithContentsOfFile:function (fileName) {
        var parser = cc.SAXParser.shareParser();
        this.rootDict = parser.parse(fileName);
        return this.rootDict;
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * RGB color composed of bytes 3 bytes
 * @Class
 * @Construct
 * @param {Number | cc.Color3B} r1 red value (0 to 255) or destination color of new color
 * @param {Number} g1 green value (0 to 255)
 * @param {Number} b1 blue value (0 to 255)
 * @example
 * //create an empty color
 * var color1 = new cc.Color3B();
 *
 * //create a red color
 * var redColor = new cc.Color3B(255,0,0);
 *
 * //create a new color with color
 * var newColor = new cc.Color3B(redColor);
 */
cc.Color3B = function (r1, g1, b1) {
    switch (arguments.length) {
        case 0:
            this.r = 0;
            this.g = 0;
            this.b = 0;
        case 1:
            if (r1 && r1 instanceof cc.Color3B) {
                this.r = r1.r || 0;
                this.g = r1.g || 0;
                this.b = r1.b || 0;
            } else {
                this.r = 0;
                this.g = 0;
                this.b = 0;
            }
            break;
        case 3:
            this.r = r1 || 0;
            this.g = g1 || 0;
            this.b = b1 || 0;
            break;
        default:
            throw "unknown argument type";
            break;
    }
};

/**
 * helper macro that creates an ccColor3B type
 * @function
 * @param {Number} r red value (0 to 255)
 * @param {Number} g green value (0 to 255)
 * @param {Number} b blue value (0 to 255)
 * @return {cc.Color3B}
 */
cc.ccc3 = function (r, g, b) {
    return new cc.Color3B(r, g, b);
};


//ccColor3B predefined colors
/**
 *  White color (255,255,255)
 * @function
 * @return {cc.Color3B}
 */
cc.WHITE = function () {
    return new cc.Color3B(255, 255, 255);
};

/**
 *  Yellow color (255,255,0)
 * @function
 * @return {cc.Color3B}
 */
cc.YELLOW = function () {
    return new cc.Color3B(255, 255, 0);
};

/**
 *  Blue color (0,0,255)
 * @function
 * @return {cc.Color3B}
 */
cc.BLUE = function () {
    return new cc.Color3B(0, 0, 255);
};

/**
 *  Green Color (0,255,0)
 * @function
 * @return {cc.Color3B}
 */
cc.GREEN = function () {
    return new cc.Color3B(0, 255, 0);
};

/**
 *  Red Color (255,0,0,)
 * @function
 * @return {cc.Color3B}
 */
cc.RED = function () {
    return new cc.Color3B(255, 0, 0);
};

/**
 *  Magenta Color (255,0,255)
 * @function
 * @return {cc.Color3B}
 */
cc.MAGENTA = function () {
    return new cc.Color3B(255, 0, 255);
};

/**
 *  Black Color (0,0,0)
 * @function
 * @return {cc.Color3B}
 */
cc.BLACK = function () {
    return new cc.Color3B(0, 0, 0);
};

/**
 *  Orange Color (255,127,0)
 * @function
 * @return {cc.Color3B}
 */
cc.ORANGE = function () {
    return new cc.Color3B(255, 127, 0);
};

/**
 *  Gray Color (166,166,166)
 * @function
 * @return {cc.Color3B}
 */
cc.GRAY = function () {
    return new cc.Color3B(166, 166, 166);
};

/**
 * RGBA color composed of 4 bytes
 * @Class
 * @Construct
 * @param {Number} r1 red value (0 to 255)
 * @param {Number} g1 green value (0 to 255)
 * @param {Number} b1 blue value (0 to 255)
 * @param {Number} a1 Alpha value (0 to 255)
 * @example
 * //create a red color
 * var redColor = new cc.Color4B(255,0,0,255);
 */
cc.Color4B = function (r1, g1, b1, a1) {
    this.r = r1;
    this.g = g1;
    this.b = b1;
    this.a = a1;
};

/**
 * helper macro that creates an ccColor4B type
 * @function
 * @param {Number} r red value (0 to 255)
 * @param {Number} g green value (0 to 255)
 * @param {Number} b blue value (0 to 255)
 * @param {Number} o Alpha value (0 to 255)
 * @return {cc.Color4B}
 */
cc.ccc4 = function (r, g, b, o) {
    return new cc.Color4B(r, g, b, o);
};

/**
 * RGBA color composed of 4 floats
 * @Class
 * @Construct
 * @param {Number} r1 red value (0 to 1)
 * @param {Number} g1 green value (0 to 1)
 * @param {Number} b1 blue value (0 to 1)
 * @param {Number} a1 Alpha value (0 to 1)
 * @example
 * //create a red color
 * var redColor = new cc.Color4F(1,0,0,1);
 */
cc.Color4F = function (r1, g1, b1, a1) {
    this.r = r1;
    this.g = g1;
    this.b = b1;
    this.a = a1;
};

/**
 * Returns a cc.Color4F from a cc.Color3B. Alpha will be 1.
 * @function
 * @param {cc.Color3B} c color
 * @return {cc.Color4F}
 */
cc.c4FFromccc3B = function (c) {
    return new cc.Color4F(c.r / 255.0, c.g / 255.0, c.b / 255.0, 1.0);
};

/**
 * Returns a cc.Color4F from a cc.Color4B.
 * @function
 * @param {cc.Color4B} c Color
 * @return {cc.Color4F}
 */
cc.c4FFromccc4B = function (c) {
    return new cc.Color4F(c.r / 255.0, c.g / 255.0, c.b / 255.0, c.a / 255.0);
};

/**
 * returns YES if both cc.Color4F are equal. Otherwise it returns NO.
 * @param {cc.Color4F} a color1
 * @param {cc.Color4F} b color2
 * @return {Boolean}
 */
cc.c4FEqual = function (a, b) {
    return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
};

/**
 * A vertex composed of 2 floats: x, y
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 */
cc.Vertex2F = function (x1, y1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
};

/**
 * helper macro that creates an Vertex2F type
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.Vertex2F}
 */
cc.Vertex2 = function (x, y) {
    return new cc.Vertex2F(x, y);
};

/**
 * A vertex composed of 3 floats: x, y, z
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} z1
 */
cc.Vertex3F = function (x1, y1, z1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
    this.Z = z1 || 0;
};

/**
 * helper macro that creates an Vertex3F type
 * @function
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return {cc.Vertex3F}
 */
cc.vertex3 = function (x, y, z) {
    return new cc.Vertex3F(x, y, z);
};

/**
 * A texcoord composed of 2 floats: u, y
 * @Class
 * @Construct
 * @param {Number} u1
 * @param {Number} v1
 */
cc.Tex2F = function (u1, v1) {
    this.u = u1 || 0;
    this.v = v1 || 0;
};

/**
 * helper macro that creates an Tex2F type
 * @function
 * @param {Number} u
 * @param {Number} v
 * @return {cc.Tex2F}
 */
cc.tex2 = function (u, v) {
    return new cc.Tex2F(u, v);
};

/**
 * Point Sprite component
 * @Class
 * @Construct
 * @param {cc.Vertex2F} pos1
 * @param {cc.Color4B} color1
 * @param {Number} size1
 */
cc.PointSprite = function (pos1, color1, size1) {
    this.pos = pos1 || new cc.Vertex2F(0, 0);
    this.color = color1 || new cc.Color4B(0, 0, 0, 0);
    this.size = size1 || 0;
};

/**
 * A 2D Quad. 4 * 2 floats
 * @Class
 * @Construct
 * @param {cc.Vertex2F} tl1
 * @param {cc.Vertex2F} tr1
 * @param {cc.Vertex2F} bl1
 * @param {cc.Vertex2F} br1
 */
cc.Quad2 = function (tl1, tr1, bl1, br1) {
    this.tl = tl1 || new cc.Vertex2F(0, 0);
    this.tr = tr1 || new cc.Vertex2F(0, 0);
    this.bl = bl1 || new cc.Vertex2F(0, 0);
    this.br = br1 || new cc.Vertex2F(0, 0);
};

/**
 * A 3D Quad. 4 * 3 floats
 * @Class
 * @Construct
 * @param {cc.Vertex3F} bl1
 * @param {cc.Vertex3F} br1
 * @param {cc.Vertex3F} tl1
 * @param {cc.Vertex3F} tr1
 */
cc.Quad3 = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.Vertex3F(0, 0, 0);
    this.br = br1 || new cc.Vertex3F(0, 0, 0);
    this.tl = tl1 || new cc.Vertex3F(0, 0, 0);
    this.tr = tr1 || new cc.Vertex3F(0, 0, 0);
};

/**
 * A 2D grid size
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 */
cc.GridSize = function (x1, y1) {
    this.x = x1;
    this.y = y1;
};

/**
 * helper function to create a cc.GridSize
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.GridSize}
 */
cc.ccg = function (x, y) {
    return new cc.GridSize(x, y);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4B
 * @Class
 * @Construct
 * @param {cc.Vertex2F} vertices1
 * @param {cc.Color4B} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V2F_C4B_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex2F(0, 0);
    this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4F
 * @Class
 * @Construct
 * @param {cc.Vertex2F} vertices1
 * @param {cc.Color4F} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V2F_C4F_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex2F(0, 0);
    this.colors = colors1 || new cc.Color4F(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4B
 * @Class
 * @Construct
 * @param {cc.Vertex3F} vertices1
 * @param {cc.Color4B} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V3F_C4B_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex3F(0, 0, 0);
    this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * 4 ccVertex2FTex2FColor4B Quad
 * @Class
 * @Construct
 * @param {cc.V2F_C4B_T2F} bl1 bottom left
 * @param {cc.V2F_C4B_T2F} br1 bottom right
 * @param {cc.V2F_C4B_T2F} tl1 top left
 * @param {cc.V2F_C4B_T2F} tr1 top right
 */
cc.V2F_C4B_T2F_Quad = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.V2F_C4B_T2F();
    this.br = br1 || new cc.V2F_C4B_T2F();
    this.tl = tl1 || new cc.V2F_C4B_T2F();
    this.tr = tr1 || new cc.V2F_C4B_T2F();
};

/**
 * helper function to create a cc.V2F_C4B_T2F_Quad
 * @function
 * @return {cc.V2F_C4B_T2F_Quad}
 */
cc.V2F_C4B_T2F_QuadZero = function () {
    return new cc.V2F_C4B_T2F_Quad(
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0))
    );
};

/**
 * 4 ccVertex3FTex2FColor4B
 * @Class
 * @Construct
 * @param {cc.V3F_C4B_T2F} tl1 top left
 * @param {cc.V3F_C4B_T2F} bl1 bottom left
 * @param {cc.V3F_C4B_T2F} tr1 top right
 * @param {cc.V3F_C4B_T2F} br1 bottom right
 */
cc.V3F_C4B_T2F_Quad = function (tl1, bl1, tr1, br1) {
    this.tl = tl1 || new cc.V3F_C4B_T2F();
    this.bl = bl1 || new cc.V3F_C4B_T2F();
    this.tr = tr1 || new cc.V3F_C4B_T2F();
    this.br = br1 || new cc.V3F_C4B_T2F();
};

/**
 * helper function to create a cc.V3F_C4B_T2F_Quad
 * @function
 * @return {cc.V3F_C4B_T2F_Quad}
 */
cc.V3F_C4B_T2F_QuadZero = function () {
    return new cc.V3F_C4B_T2F_Quad(
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)));
};

/**
 * 4 ccVertex2FTex2FColor4F Quad
 * @Class
 * @Construct
 * @param {cc.V2F_C4F_T2F} bl1 bottom left
 * @param {cc.V2F_C4F_T2F} br1 bottom right
 * @param {cc.V2F_C4F_T2F} tl1 top left
 * @param {cc.V2F_C4F_T2F} tr1 top right
 * Constructor
 */
cc.V2F_C4F_T2F_Quad = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.V2F_C4F_T2F();
    this.br = br1 || new cc.V2F_C4F_T2F();
    this.tl = tl1 || new cc.V2F_C4F_T2F();
    this.tr = tr1 || new cc.V2F_C4F_T2F();
};

/**
 * Blend Function used for textures
 * @Class
 * @Construct
 * @param {Number} src1 source blend function
 * @param {Number} dst1 destination blend function
 */
cc.BlendFunc = function (src1, dst1) {
    this.src = src1;
    this.dst = dst1;
};

/**
 * text alignment : left
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_LEFT = 0;

/**
 * text alignment : center
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_CENTER = 1;

/**
 * text alignment : right
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_RIGHT = 2;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @param {Number} _x
 * @param {Number} _y
 * Constructor
 */
cc.Point = function (_x, _y) {
    this.x = _x || 0;
    this.y = _y || 0;
};

/**
 * @function
 * @param {cc.Point} point1
 * @param {cc.Point} point2
 * @return {Boolean}
 * Constructor
 */
cc.Point.CCPointEqualToPoint = function (point1, point2) {
    return ((point1.x == point2.x) && (point1.y == point2.y));
};

/**
 * @class
 * @param {Number} _width
 * @param {Number} _height
 * Constructor
 */
cc.Size = function (_width, _height) {
    this.width = _width || 0;
    this.height = _height || 0;
};

/**
 * @function
 * @param {cc.Size} size1
 * @param {cc.Size} size2
 * @return {Boolean}
 * Constructor
 */
cc.Size.CCSizeEqualToSize = function (size1, size2) {
    return ((size1.width == size2.width) && (size1.height == size2.height));

};

/**
 * @class
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} width1
 * @param {Number} height1
 * Constructor
 */
cc.Rect = function (x1, y1, width1, height1) {
    switch (arguments.length) {
        case 0:
            this.origin = new cc.Point(0, 0);
            this.size = new cc.Size(0, 0);
            break;
        case 1:
            var oldRect = x1;
            if (!oldRect) {
                this.origin = new cc.Point(0, 0);
                this.size = new cc.Size(0, 0);
            } else {
                if (oldRect instanceof cc.Rect) {
                    this.origin = new cc.Point(oldRect.origin.x, oldRect.origin.y);
                    this.size = new cc.Size(oldRect.size.width, oldRect.size.height);
                } else {
                    throw "unknown argument type";
                }
            }
            break;
        case 2:
            this.origin = x1 ? new cc.Point(x1.x, x1.y) : new cc.Point(0, 0);
            this.size = y1 ? new cc.Size(y1.width, y1.height) : new cc.Size(0, 0);
            break;
        case 4:
            this.origin = new cc.Point(x1 || 0, y1 || 0);
            this.size = new cc.Size(width1 || 0, height1 || 0);
            break;
        default:
            throw "unknown argument type";
            break;
    }
};

/**
 * @function
 * @param {cc.Rect} rect1
 * @param {cc.Rect} rect2
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectEqualToRect = function (rect1, rect2) {
    return ((cc.Point.CCPointEqualToPoint(rect1.origin, rect2.origin)) &&
        (cc.Size.CCSizeEqualToSize(rect1.size, rect2.size)));
};

/**
 * return the rightmost x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMaxX = function (rect) {
    return (rect.origin.x + rect.size.width);
};

/**
 * return the midpoint x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMidX = function (rect) {
    return ((rect.origin.x + rect.size.width) / 2.0);
};
/**
 * return the leftmost x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMinX = function (rect) {
    return rect.origin.x;
};

/**
 * Return the topmost y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMaxY = function (rect) {
    return(rect.origin.y + rect.size.height);
};

/**
 * Return the midpoint y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMidY = function (rect) {
    return rect.origin.y + rect.size.height / 2.0;
};

/**
 * Return the bottommost y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMinY = function (rect) {
    return rect.origin.y;
};

/**
 * @function
 * @param {cc.Rect} rect
 * @param {cc.Point} point
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectContainsPoint = function (rect, point) {
    var ret = false;
    if (point.x >= cc.Rect.CCRectGetMinX(rect) && point.x <= cc.Rect.CCRectGetMaxX(rect)
        && point.y >= cc.Rect.CCRectGetMinY(rect) && point.y <= cc.Rect.CCRectGetMaxY(rect)) {
        ret = true;
    }
    return ret;
};

/**
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectIntersectsRect = function (rectA, rectB) {
    return !(cc.Rect.CCRectGetMaxX(rectA) < cc.Rect.CCRectGetMinX(rectB) ||
        cc.Rect.CCRectGetMaxX(rectB) < cc.Rect.CCRectGetMinX(rectA) ||
        cc.Rect.CCRectGetMaxY(rectA) < cc.Rect.CCRectGetMinY(rectB) ||
        cc.Rect.CCRectGetMaxY(rectB) < cc.Rect.CCRectGetMinY(rectA));
};

/**
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectOverlapsRect = function (rectA, rectB) {
    if (rectA.origin.x + rectA.size.width < rectB.origin.x) {
        return false;
    }
    if (rectB.origin.x + rectB.size.width < rectA.origin.x) {
        return false;
    }
    if (rectA.origin.y + rectA.size.height < rectB.origin.y) {
        return false;
    }
    if (rectB.origin.y + rectB.size.height < rectA.origin.y) {
        return false;
    }
    return true;
};

/**
 * Returns the smallest rectangle that contains the two source rectangles.
 * @function
 * @param {cc.Rect}　rectA
 * @param {cc.Rect}　rectB
 * @return {cc.Rect}
 * Constructor
 */
cc.Rect.CCRectUnion = function (rectA, rectB) {
    var rect = new cc.Rect(0, 0, 0, 0);
    rect.origin.x = Math.min(rectA.origin.x, rectB.origin.x);
    rect.origin.y = Math.min(rectA.origin.y, rectB.origin.y);
    rect.size.width = Math.max(rectA.origin.x + rectA.size.width, rectB.origin.x + rectB.size.width) - rect.origin.x;
    rect.size.height = Math.max(rectA.origin.y + rectA.size.height, rectB.origin.y + rectB.size.height) - rect.origin.y;
    return rect
};

/**
 * Returns the overlapping portion of 2 rectangles
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {cc.Rect}
 * Constructor
 */
cc.Rect.CCRectIntersection = function (rectA, rectB) {
    var intersection = new cc.Rect(
        Math.max(cc.Rect.CCRectGetMinX(rectA), cc.Rect.CCRectGetMinX(rectB)),
        Math.max(cc.Rect.CCRectGetMinY(rectA), cc.Rect.CCRectGetMinY(rectB)),
        0, 0);

    intersection.size.width = Math.min(cc.Rect.CCRectGetMaxX(rectA), cc.Rect.CCRectGetMaxX(rectB)) - cc.Rect.CCRectGetMinX(intersection);
    intersection.size.height = Math.min(cc.Rect.CCRectGetMaxY(rectA), cc.Rect.CCRectGetMaxY(rectB)) - cc.Rect.CCRectGetMinY(intersection);
    return intersection
};

/**
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.Point}
 * Constructor
 */
cc.PointMake = function (x, y) {
    return new cc.Point(x, y);
};

/**
 * @function
 * @param {Number} width
 * @param {Number} height
 * @return {cc.Size}
 * Constructor
 */
cc.SizeMake = function (width, height) {
    return new cc.Size(width, height);
};

/**
 * @function
 * @param {Number} x
 * @param {Number} y
 * @param {Number} width
 * @param {Number} height
 * @return {cc.Rect}
 * Constructor
 */
cc.RectMake = function (x, y, width, height) {
    return new cc.Rect(x, y, width, height);
};

/**
 * The "left bottom" point -- equivalent to cc.PointMake(0, 0).
 * @function
 * @return {cc.Point}
 * Constructor
 */
cc.PointZero = function () {
    return new cc.Point(0, 0)
};

/**
 * The "zero" size -- equivalent to cc.SizeMake(0, 0).
 * @function
 * @return {cc.Size}
 * Constructor
 */
cc.SizeZero = function () {
    return new cc.Size(0, 0)
};

/**
 * The "zero" rectangle -- equivalent to cc.RectMake(0, 0, 0, 0).
 * @function
 * @return {cc.Rect}
 * Constructor
 */
cc.RectZero = function () {
    return new cc.Rect(0, 0, 0, 0)
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */

cc.Set = cc.Class.extend(/** @lends cc.Set# */{
    /**
     * Constructor
     * @param {cc.Set} setObject
     */
    ctor:function (setObject) {
        if (setObject) {
            this._set = Object.create(setObject._set);
        }
        else {
            this._set = new Array();
        }

    },

    /**
     * Return a copy of the cc.Set, it will copy all the elelments.
     * @return {cc.Set}
     */
    copy:function () {
        return new this.Set(this);
    },

    /**
     * It is the same as copy().
     * @return {cc.Set}
     */
    mutableCopy:function () {
        return this.copy();

    },

    /**
     * Return the number of elements the cc.Set contains.
     * @return {Number}
     */
    count:function () {
        return this._set.length;

    },

    /**
     * Add a element into cc.Set, it will retain the element.
     * @param {object} obj
     */
    addObject:function (obj) {
        this._set.push(obj);

    },

    /**
     * Remove the given element, nothing todo if no element equals obj.
     * @param {object} obj
     */
    removeObject:function (obj) {
        /* if(obj in this._set)
         {
         delete this._set[obj]
         } */
        var k = 0;
        for (var i = 0, n = 0; i < this._set.length; i++) {
            if (this._set[i] != obj) {
                this._set[n++] = this._set[i];
                k++;
            }
        }
        array.length = k;

    },

    /**
     * Check if cc.Set contains a element equals obj.
     * @param {object} obj
     * @return {Boolean}
     */
    containsObject:function (obj) {

        if ((obj in this._set) == true) {
            return true;
        }
        else {
            return false;
        }


    },


    /**
     * Return the first element if it contains elements, or null if it doesn't contain any element.
     * @return {object|Null}
     */
    anyObject:function () {
        if (this._set.length > 0) {
            return this._set[0];
        }
        else {
            return null;
        }

    },

    _set:null

});

/**
 * cc.NSMutableSet is the same as cc.Set
 * @class
 * @extends cc.Set
 */
cc.NSMutableSet = cc.Set;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * first, judge whether the form of the string like this: {x,y}  <br/>
 * if the form is right,the string will be splited into the parameter strs;<br/>
 * or the parameter strs will be empty. <br/>
 * if the form is right return true,else return false.<br/>
 * @function
 * @param {String} str
 * @param {String} strs
 * @return {String}
 */
cc.splitWithForm = function (str, strs) {
    var ret = false;
    do
    {
        if (!str) break;

        // string is empty
        var content = str;
        if (content.length == 0) break;

        var posLeft = content.indexOf('{');
        var posRight = content.indexOf('}');

        // don't have '{' and '}'
        if (posLeft == -1 || posRight == -1) break;
        // '}' is before '{'
        if (posLeft > posRight) break;

        var pointStr = content.substr(posLeft + 1, posRight - posLeft - 1);
        // nothing between '{' and '}'
        if (pointStr.length == 0) break;

        var nPos1 = pointStr.indexOf('{');
        var nPos2 = pointStr.indexOf('}');
        // contain '{' or '}'
        if (nPos1 != -1 || nPos2 != -1) break;
        strs = pointStr.split(",");
        if (strs.length != 2 || strs[0] != null || strs[1] != null) {
            break;
        }
    } while (0);

    return strs;
};

/**
 * Returns a Core Graphics rectangle structure corresponding to the data in a given string. <br/>
 * The string is not localized, so items are always separated with a comma. <br/>
 * If the string is not well-formed, the function returns cc.RectZero.
 * @function
 * @param {String} content content A string object whose contents are of the form "{{x,y},{w, h}}",<br/>
 * where x is the x coordinate, y is the y coordinate, w is the width, and h is the height. <br/>
 * These components can represent integer or float values.
 * @return {cc.Rect} A Core Graphics structure that represents a rectangle.
 * Constructor
 * @example
 * // example
 * var rect = cc.RectFromString("{{3,2},{4,5}}");
 */
cc.RectFromString = function (content) {
    var result = cc.RectZero();

    do {
        if (!content) break;
        var content = content;

        // find the first '{' and the third '}'
        var posLeft = content.indexOf('{') + 1;
        var posRight = content.lastIndexOf('}', content.length);
        if (posLeft == -1 || posRight == -1) break;

        content = content.substring(posLeft, posRight);
        var nPointEnd = content.indexOf('}');
        if (nPointEnd == -1) break;
        nPointEnd = content.indexOf(',', nPointEnd);
        if (nPointEnd == -1) break;
        // get the point string and size string
        var pointStr = content.substr(0, nPointEnd);
        var sizeStr = content.substr(nPointEnd + 1, content.length - nPointEnd);

        // split the string with ','
        var pointInfo = cc.splitWithForm(pointStr.toString());
        var sizeInfo = cc.splitWithForm(sizeStr.toString());

        var x = parseFloat(pointInfo[0]);
        var y = parseFloat(pointInfo[1]);
        var width = parseFloat(sizeInfo[0]);
        var height = parseFloat(sizeInfo[1]);

        result = cc.RectMake(x, y, width, height);
    } while (0);
    return result;
}
/**
 * Returns a Core Graphics point structure corresponding to the data in a given string.
 * @function
 * @param {String} content   A string object whose contents are of the form "{x,y}",
 * where x is the x coordinate and y is the y coordinate.<br/>
 * The x and y values can represent integer or float values. <br/>
 * The string is not localized, so items are always separated with a comma.<br/>
 * @return {cc.Point} A Core Graphics structure that represents a point.<br/>
 * If the string is not well-formed, the function returns cc.PointZero.
 * Constructor
 * @example
 * //example
 * var point = cc.PointFromString("{3.0,2.5}");
 */
cc.PointFromString = function (content) {
    var ret = cc.PointZero();

    try {
        if (content == "")
            return ret;

        var strs = cc.splitWithForm(content);
        var x = parseFloat(strs[0]);
        var y = parseFloat(strs[1]);
        ret = cc.PointMake(x, y);
    } catch (e) {
    }
    return ret;
}
/**
 * Returns a Core Graphics size structure corresponding to the data in a given string.
 * @function
 * @param {String} content   A string object whose contents are of the form "{w, h}",<br/>
 * where w is the width and h is the height.<br/>
 * The w and h values can be integer or float values. <br/>
 * The string is not localized, so items are always separated with a comma.<br/>
 * @return {cc.Size} A Core Graphics structure that represents a size.<br/>
 * If the string is not well-formed, the function returns cc.SizeZero.
 * @example
 * // example
 * var size = cc.SizeFromString("{3.0,2.5}");
 */
cc.SizeFromString = function (content) {
    var ret = cc.SizeZero();
    try {
        if (content == "")
            return ret;

        var strs = cc.splitWithForm(content);
        var width = parseFloat(strs[0]);
        var height = parseFloat(strs[1]);
        ret = cc.SizeMake(width, height);
    } catch (e) {
    }
    return ret;
}
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} tx
 * @param {Number} ty
 */
cc.AffineTransform = function (a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
};

cc.__AffineTransformMake = function (a, b, c, d, tx, ty) {
    return new cc.AffineTransform(a, b, c, d, tx, ty);
};

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} tx
 * @param {Number} ty
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformMake = function (a, b, c, d, tx, ty) {
    return new cc.AffineTransform(a, b, c, d, tx, ty);
};

cc.__PointApplyAffineTransform = function (point, t) {
    var p = new cc.Point();
    p.x = t.a * point.x + t.c * point.y + t.tx;
    p.y = t.b * point.x + t.d * point.y + t.ty;
    return p;
};

/**
 * @function
 * @param {cc.Point} point
 * @param {cc.AffineTransform} t
 * @return {cc.Point}
 * Constructor
 */
cc.PointApplyAffineTransform = function (point, t) {
    return cc.__PointApplyAffineTransform(point, t);
};

cc.__SizeApplyAffineTransform = function (size, t) {
    var s = new cc.Size();
    s.width = t.a * size.width + t.c * size.height;
    s.height = t.b * size.width + t.d * size.height;
    return s;
};

/**
 * @function
 * @param {cc.Size} size
 * @param {cc.AffineTransform} t
 * @return {cc.Size}
 * Constructor
 */
cc.SizeApplyAffineTransform = function (size, t) {
    return cc.__SizeApplyAffineTransform(size, t);
};

/**
 * @function
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformMakeIdentity = function () {
    return cc.__AffineTransformMake(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
};

/**
 * @function
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformIdentity = function () {
    return cc.AffineTransformMakeIdentity();
};

/**
 * @function
 * @param {cc.Rect} rect
 * @param {cc.AffineTransform} anAffineTransform
 * @return {cc.Rect}
 * Constructor
 */
cc.RectApplyAffineTransform = function (rect, anAffineTransform) {
    var top = cc.Rect.CCRectGetMinY(rect);
    var left = cc.Rect.CCRectGetMinX(rect);
    var right = cc.Rect.CCRectGetMaxX(rect);
    var bottom = cc.Rect.CCRectGetMaxY(rect);

    var topLeft = cc.PointApplyAffineTransform(cc.PointMake(left, top), anAffineTransform);
    var topRight = cc.PointApplyAffineTransform(cc.PointMake(right, top), anAffineTransform);
    var bottomLeft = cc.PointApplyAffineTransform(cc.PointMake(left, bottom), anAffineTransform);
    var bottomRight = cc.PointApplyAffineTransform(cc.PointMake(right, bottom), anAffineTransform);

    var minX = Math.min(Math.min(topLeft.x, topRight.x), Math.min(bottomLeft.x, bottomRight.x));
    var maxX = Math.max(Math.max(topLeft.x, topRight.x), Math.max(bottomLeft.x, bottomRight.x));
    var minY = Math.min(Math.min(topLeft.y, topRight.y), Math.min(bottomLeft.y, bottomRight.y));
    var maxY = Math.max(Math.max(topLeft.y, topRight.y), Math.max(bottomLeft.y, bottomRight.y));

    return cc.RectMake(minX, minY, (maxX - minX), (maxY - minY));
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @param {Number} tx
 * @param {Number}ty
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformTranslate = function (t, tx, ty) {
    return cc.__AffineTransformMake(t.a, t.b, t.c, t.d, t.tx + t.a * tx + t.c * ty, t.ty + t.b * tx + t.d * ty);
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @param {Number} sx
 * @param {Number} sy
 * @return {{cc.AffineTransform}}
 * Constructor
 */
cc.AffineTransformScale = function (t, sx, sy) {
    return cc.__AffineTransformMake(t.a * sx, t.b * sx, t.c * sy, t.d * sy, t.tx, t.ty);
};

/**
 * @function
 * @param {cc.AffineTransform} aTransform
 * @param {Number} anAngle
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformRotate = function (aTransform, anAngle) {
    var fSin = Math.sin(anAngle);
    var fCos = Math.cos(anAngle);

    return cc.__AffineTransformMake(aTransform.a * fCos + aTransform.c * fSin,
        aTransform.b * fCos + aTransform.d * fSin,
        aTransform.c * fCos - aTransform.a * fSin,
        aTransform.d * fCos - aTransform.b * fSin,
        aTransform.tx,
        aTransform.ty);
};

/* Concatenate `t2' to `t1' and return the result:<br/>
 * t' = t1 * t2
 * @param {cc.AffineTransform} t1
 * @param {cc.AffineTransform} t2
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformConcat = function (t1, t2) {
    return cc.__AffineTransformMake(t1.a * t2.a + t1.b * t2.c, t1.a * t2.b + t1.b * t2.d, //a,b
        t1.c * t2.a + t1.d * t2.c, t1.c * t2.b + t1.d * t2.d, //c,d
        t1.tx * t2.a + t1.ty * t2.c + t2.tx, //tx
        t1.tx * t2.b + t1.ty * t2.d + t2.ty);				  //ty
};

/**
 * Return true if `t1' and `t2' are equal, false otherwise.
 * @function
 * @param {cc.AffineTransform} t1
 * @param {cc.AffineTransform} t2
 * @return {Boolean}
 * Constructor
 */
cc.AffineTransformEqualToTransform = function (t1, t2) {
    return (t1.a == t2.a && t1.b == t2.b && t1.c == t2.c && t1.d == t2.d && t1.tx == t2.tx && t1.ty == t2.ty);
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformInvert = function (t) {
    var determinant = 1 / (t.a * t.d - t.b * t.c);

    return cc.__AffineTransformMake(determinant * t.d, -determinant * t.b, -determinant * t.c, determinant * t.a,
        determinant * (t.c * t.ty - t.d * t.tx), determinant * (t.b * t.tx - t.a * t.ty));
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>cc.Point extensions based on Chipmunk's cpVect file.<br />
 * These extensions work both with cc.Point</p>
 *
 * <p>The "ccp" prefix means: "CoCos2d Point"</p>
 *
 * <p> //Examples:<br />
 * - cc.ccpAdd( cc.ccp(1,1), cc.ccp(2,2) ); // preferred cocos2d way<br />
 * - cc.ccpAdd( cc.PointMake(1,1), cc.PointMake(2,2) ); // also ok but more verbose<br />
 * - cc.ccpAdd( cc.cpv(1,1), cc.cpv(2,2) ); // mixing chipmunk and cocos2d (avoid)</p>
 */

/**
 * smallest such that 1.0+FLT_EPSILON != 1.0
 * @constant
 * @type Number
 */
cc.CCPOINT_EPSILON = parseFloat('1.192092896e-07F');

/**
 * Helper macro that creates a cc.Point.
 * @param {Number} x
 * @param {Number} y
 * @return {cc.Point}
 */
cc.ccp = function (x, y) {
    return new cc.Point(x, y);
};

/**
 * Returns opposite of point.
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.ccpNeg = function (point) {
    return new cc.Point(-point.x, -point.y);
};

/**
 * Calculates sum of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.Point}
 */
cc.ccpAdd = function (v1, v2) {
    return new cc.Point(v1.x + v2.x, v1.y + v2.y);
};

/**
 * Calculates difference of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.Point}
 */
cc.ccpSub = function (v1, v2) {
    return new cc.Point(v1.x - v2.x, v1.y - v2.y);
};

/**
 * Returns point multiplied by given factor.
 * @param {cc.Point} point
 * @param {Number} floatVar
 * @return {cc.Point}
 */
cc.ccpMult = function (point, floatVar) {
    return new cc.Point(point.x * floatVar, point.y * floatVar);
};

/**
 * Calculates midpoint between two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.ccpMult}
 */
cc.ccpMidpoint = function (v1, v2) {
    return cc.ccpMult(cc.ccpAdd(v1, v2), 0.5);
};

/**
 * Calculates dot product of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {Number}
 */
cc.ccpDot = function (v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};

/**
 * Calculates cross product of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {Number}
 */
cc.ccpCross = function (v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
};

/**
 * Calculates perpendicular of v, rotated 90 degrees counter-clockwise -- cross(v, perp(v)) >= 0
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.ccpPerp = function (point) {
    return new cc.Point(-point.y, point.x);
};

/**
 * Calculates perpendicular of v, rotated 90 degrees clockwise -- cross(v, rperp(v)) <= 0
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.ccpRPerp = function (point) {
    return new cc.Point(point.y, -point.x);
};

/**
 * Calculates the projection of v1 over v2.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.ccpMult}
 */
cc.ccpProject = function (v1, v2) {
    return cc.ccpMult(v2, cc.ccpDot(v1, v2) / cc.ccpDot(v2, v2));
};

/**
 * Rotates two points.
 * @param  {cc.Point} v1
 * @param  {cc.Point} v2
 * @return {cc.Point}
 */
cc.ccpRotate = function (v1, v2) {
    return new cc.Point(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
};

/**
 * Unrotates two points.
 * @param  {cc.Point} v1
 * @param  {cc.Point} v2
 * @return {cc.Point}
 */
cc.ccpUnrotate = function (v1, v2) {
    return new cc.Point(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
};

/**
 * Calculates the square length of a cc.Point (not calling sqrt() )
 * @param  {cc.Point} v
 *@return {cc.ccpDot}
 */
cc.ccpLengthSQ = function (v) {
    return cc.ccpDot(v, v);
};

/**
 * Calculates distance between point an origin
 * @param  {cc.Point} v
 * @return {Number}
 */
cc.ccpLength = function (v) {
    return Math.sqrt(cc.ccpLengthSQ(v));
};

/**
 * Calculates the distance between two points
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.ccpLength}
 */
cc.ccpDistance = function (v1, v2) {
    return cc.ccpLength(cc.ccpSub(v1, v2));
};

/**
 * Returns point multiplied to a length of 1.
 * @param {cc.Point} v
 * @return {cc.ccpMult}
 */
cc.ccpNormalize = function (v) {
    return cc.ccpMult(v, 1.0 / cc.ccpLength(v));
};

/**
 * Converts radians to a normalized vector.
 * @param {Number} a
 * @return {cc.Point}
 */
cc.ccpForAngle = function (a) {
    return new cc.Point(Math.cos(a), Math.sin(a));
};

/**
 * Converts a vector to radians.
 * @param {cc.Point} v
 * @return {Number}
 */
cc.ccpToAngle = function (v) {
    return Math.atan2(v.y, v.x);
};

/**
 * Clamp a value between from and to.
 * @param {Number} value
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {Number}
 */
cc.clampf = function (value, min_inclusive, max_inclusive) {
    if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
    }
    return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};

/**
 * Clamp a point between from and to.
 * @param {Number} p
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {cc.Point}
 */
cc.ccpClamp = function (p, min_inclusive, max_inclusive) {
    return new cc.Point(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
};

/**
 * Quickly convert cc.Size to a cc.Point
 * @param {cc.Size} s
 * @return {cc.Point}
 */
cc.ccpFromSize = function (s) {
    return new cc.Point(s.width, s.height);
};

/**
 * Run a math operation function on each point component <br />
 * Math.abs, Math.fllor, Math.ceil, Math.round.
 * @param {cc.Point} p
 * @param {Function} opFunc
 * @return {cc.Point}
 * @example
 * //For example: let's try to take the floor of x,y
 * var p = cc.ccpCompOp(new cc.Point(10,10),Math.abs);
 */
cc.ccpCompOp = function (p, opFunc) {
    return new cc.Point(opFunc(p.x), opFunc(p.y));
};

/**
 * Linear Interpolation between two points a and b
 * alpha == 0 ? a
 * alpha == 1 ? b
 * otherwise a value between a..b
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @param {Number} alpha
 * @return {cc.ccpAdd}
 */
cc.ccpLerp = function (a, b, alpha) {
    return cc.ccpAdd(cc.ccpMult(a, 1 - alpha), cc.ccpMult(b, alpha));
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @param {Number} variance
 * @return {Boolean} if points have fuzzy equality which means equal with some degree of variance.
 */
cc.ccpFuzzyEqual = function (a, b, variance) {
    if (a.x - variance <= b.x && b.x <= a.x + variance) {
        if (a.y - variance <= b.y && b.y <= a.y + variance) {
            return true;
        }
    }
    return false;
};

/**
 * Multiplies a nd b components, a.x*b.x, a.y*b.y
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {cc.Point}
 */
cc.ccpCompMult = function (a, b) {
    return new cc.Point(a.x * b.x, a.y * b.y);
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {Number} the signed angle in radians between two vector directions
 */
cc.ccpAngleSigned = function (a, b) {
    var a2 = cc.ccpNormalize(a);
    var b2 = cc.ccpNormalize(b);
    var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.ccpDot(a2, b2));
    if (Math.abs(angle) < cc.CCPOINT_EPSILON) {
        return 0.0;
    }
    return angle;
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {Number} the angle in radians between two vector directions
 */
cc.ccpAngle = function (a, b) {
    var angle = Math.acos(cc.ccpDot(cc.ccpNormalize(a), cc.ccpNormalize(b)));
    if (Math.abs(angle) < cc.CCPOINT_EPSILON) return 0.0;
    return angle;
};

/**
 * Rotates a point counter clockwise by the angle around a pivot
 * @param {cc.Point} v v is the point to rotate
 * @param {cc.Point} pivot pivot is the pivot, naturally
 * @param {Number} angle angle is the angle of rotation cw in radians
 * @return {cc.Point} the rotated point
 */
cc.ccpRotateByAngle = function (v, pivot, angle) {
    var r = cc.ccpSub(v, pivot);
    var cosa = Math.cos(angle), sina = Math.sin(angle);
    var t = r.x;
    r.x = t * cosa - r.y * sina + pivot.x;
    r.y = t * sina + r.y * cosa + pivot.y;
    return r;
};

/**
 * A general line-line intersection test
 * @param {cc.Point} A A is the startpoint for the first line P1 = (p1 - p2).
 * @param {cc.Point} B B is the endpoint for the first line P1 = (p1 - p2).
 * @param {cc.Point} C C is the startpoint for the second line P2 = (p3 - p4).
 * @param {cc.Point} D D is the endpoint for the second line P2 = (p3 - p4).
 * @param {cc.Point} retP retP.x is the range for a hitpoint in P1 (pa = p1 + s*(p2 - p1)), <br />
 * retP.y is the range for a hitpoint in P3 (pa = p2 + t*(p4 - p3)).
 * @return {Boolean}
 * indicating successful intersection of a line<br />
 * note that to truly test intersection for segments we have to make<br />
 * sure that s & t lie within [0..1] and for rays, make sure s & t > 0<br />
 * the hit point is        p3 + t * (p4 - p3);<br />
 * the hit point also is    p1 + s * (p2 - p1);
 */
cc.ccpLineIntersect = function (A, B, C, D, retP) {
    if ((A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)) {
        return false;
    }
    var BAx = B.x - A.x;
    var BAy = B.y - A.y;
    var DCx = D.x - C.x;
    var DCy = D.y - C.y;
    var ACx = A.x - C.x;
    var ACy = A.y - C.y;

    var denom = DCy * BAx - DCx * BAy;

    retP.x = DCx * ACy - DCy * ACx;
    retP.y = BAx * ACy - BAy * ACx;

    if (denom == 0) {
        if (retP.x == 0 || retP.y == 0) {
            // Lines incident
            return true;
        }
        // Lines parallel and not incident
        return false;
    }

    retP.x = retP.x / denom;
    retP.y = retP.y / denom;

    return true;
};

/**
 * ccpSegmentIntersect return YES if Segment A-B intersects with segment C-D.
 * @param {cc.Point} A
 * @param {cc.Point} B
 * @param {cc.Point} C
 * @param {cc.Point} D
 * @return {Boolean}
 */
cc.ccpSegmentIntersect = function (A, B, C, D) {
    var retP = new cc.Point();
    if (cc.ccpLineIntersect(A, B, C, D, retP))
        if (retP.x >= 0.0 && retP.x <= 1.0 && retP.y >= 0.0 && retP.y <= 1.0)
            return true;
    return false;
};

/**
 * ccpIntersectPoint return the intersection point of line A-B, C-D
 * @param {cc.Point} A
 * @param {cc.Point} B
 * @param {cc.Point} C
 * @param {cc.Point} D
 * @return {cc.Point}
 */
cc.ccpIntersectPoint = function (A, B, C, D) {
    var retP = new cc.Point();

    if (cc.ccpLineIntersect(A, B, C, D, retP)) {
        // Point of intersection
        var P = new cc.Point();
        P.x = A.x + retP.x * (B.x - A.x);
        P.y = A.y + retP.x * (B.y - A.y);
        return P;
    }

    return cc.PointZero();
};

/**
 * check to see if both points are equal
 * @param {cc.Point} A A ccp a
 * @param {cc.Point} B B ccp b to be compared
 * @return {Boolean} the true if both ccp are same
 */
cc.ccpSameAs = function (A, B) {
    if (A.x && B.x) {
        return (A.x == B.x && A.y == B.y);
    }
    return false;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Default Node tag
 * @constant
 * @type Number
 */
cc.CCNODE_TAG_INVALID = -1;
/**
 * Node on enter
 * @constant
 */
cc.CCNODE_ON_ENTER = null;
/**
 * Node on exit
 * @constant
 */
cc.CCNODE_ON_EXIT = null;

/**
 * save the context
 * @function
 */
cc.saveContext = function () {
    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.save();
    } else {
        //glPushMatrix();
    }
};

/**
 * restore the context
 * @function
 */
cc.restoreContext = function () {
    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.restore();
    } else {
        //glPopMatrix();
    }
};

/** <p>cc.Node is the main element. Anything thats gets drawn or contains things that get drawn is a cc.Node.<br/>
 The most popular cc.Nodes are: cc.Scene, cc.Layer, cc.Sprite, cc.Menu.<br/></p>

 <p>The main features of a cc.Node are: <br/>
 - They can contain other cc.Node nodes (addChild, getChildByTag, removeChild, etc) <br/>
 - They can schedule periodic callback (schedule, unschedule, etc) <br/>
 - They can execute actions (runAction, stopAction, etc) <br/></p>

 <p>Some cc.Node nodes provide extra functionality for them or their children.</p>

 <p>Subclassing a cc.Node usually means (one/all) of: <br/>
 - overriding init to initialize resources and schedule callbacks  <br/>
 - create callbacks to handle the advancement of time <br/>
 - overriding draw to render the node   <br/></p>

 <p>Features of cc.Node: <br/>
 - position  <br/>
 - scale (x, y) <br/>
 - rotation (in degrees, clockwise) <br/>
 - cc.Camera (an interface to gluLookAt ) <br/>
 - cc.GridBase (to do mesh transformations)  <br/>
 - anchor point<br/>
 - size <br/>
 - visible<br/>
 - z-order <br/>
 - openGL z position <br/></P>

 <p> Default values: <br/>
 - rotation: 0 <br/>
 - position: (x=0,y=0) <br/>
 - scale: (x=1,y=1) <br/>
 - contentSize: (x=0,y=0)<br/>
 - anchorPoint: (x=0,y=0)<br/></p>

 <p> Limitations:<br/>
 - A cc.Node is a "void" object. It doesn't have a texture <br/></P>

 <p>Order in transformations with grid disabled <br/>
 -# The node will be translated (position)  <br/>
 -# The node will be rotated (rotation)<br/>
 -# The node will be scaled (scale)  <br/>
 -# The node will be moved according to the camera values (camera) <br/></p>

 <p>Order in transformations with grid enabled<br/>
 -# The node will be translated (position)<br/>
 -# The node will be rotated (rotation) <br/>
 -# The node will be scaled (scale) <br/>
 -# The grid will capture the screen <br/>
 -# The node will be moved according to the camera values (camera) <br/>
 -# The grid will render the captured screen <br/></P>

 <p>Camera:  <br/>
 - Each node has a camera. By default it points to the center of the cc.Node.</P>
 * @class
 * @extends cc.Class
 * @example
 * // example
 * cc.Sprite = cc.Node.extend({});
 * cc.Sprite.initWithImage = function(){
 * };
 */
cc.Node = cc.Class.extend(/** @lends cc.Node# */{
    _zOrder:0,
    _vertexZ:0.0,
    _rotation:0.0,
    _scaleX:1.0,
    _scaleY:1.0,
    _position:cc.PointZero(),
    _positionInPixels:cc.PointZero(),
    _skewX:0.0,
    _skewY:0.0,
    // children (lazy allocs),
    _children:null,
    // lazy alloc,
    _camera:null,
    _grid:null,
    _isVisible:true,
    _anchorPoint:new cc.Point(0, 0),
    _anchorPointInPixels:new cc.Point(0, 0),
    _contentSize:cc.SizeZero(),
    _contentSizeInPixels:cc.SizeZero(),
    _isRunning:false,
    _parent:null,
    // "whole screen" objects. like Scenes and Layers, should set isRelativeAnchorPoint to false
    _isRelativeAnchorPoint:true,
    _tag:cc.CCNODE_TAG_INVALID,
    // userData is always inited as nil
    _userData:null,
    _isTransformDirty:true,
    _isInverseDirty:true,
    _isCacheDirty:true,
    _isTransformGLDirty:null,
    _transform:null,
    _inverse:null,
    _transformGL:null,

    /**
     * Constructor
     */
    ctor:function () {
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
            this._transformGL = 0.0;
        }
        this._anchorPoint = new cc.Point(0, 0);
        this._anchorPointInPixels = new cc.Point(0, 0);
        this._contentSize = new cc.Size(0, 0);
        this._contentSizeInPixels = new cc.Size(0, 0);
    },

    /**
     * @param {Array} array
     * @param {function} func
     * @private
     */
    _arrayMakeObjectsPerformSelector:function (array, callbackType) {
        if (!array || array.length == 0)
            return;

        var i;
        switch (callbackType) {
            case cc.Node.StateCallbackType.onEnter:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onEnter();
                }
                break;
            case cc.Node.StateCallbackType.onExit:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onExit();
                }
                break;
            case cc.Node.StateCallbackType.onEnterTransitionDidFinish:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onEnterTransitionDidFinish();
                }
                break;
            case cc.Node.StateCallbackType.cleanup:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].cleanup();
                }
                break;
            default :
                throw "Unknown callback function";
                break;
        }
    },

    /**
     * @param {cc.Rect} rect
     * @private
     */
    _addDirtyRegionToDirector:function (rect) {
        //if (!cc.firstRun) {
        //cc.Director.sharedDirector().addRegionToDirtyRegion(rect);
        //}
    },

    _isInDirtyRegion:function () {
        //if (!cc.firstRun) {
        //    return cc.Director.sharedDirector().rectIsInDirtyRegion(this.boundingBoxToWorld());
        //}
    },

    /**
     * set the dirty node
     */
    setNodeDirty:function () {
        this._setNodeDirtyForCache();
        this._isTransformDirty = this._isInverseDirty = true;
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
        }
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
        if (this._parent) {
            this._parent._setNodeDirtyForCache();
        }
    },

    /**
     *  get the skew degrees in X
     * @return {Number}
     */
    getSkewX:function () {
        return this._skewX;
    },

    /**
     * set the skew degrees in X
     * @param {Number} newSkewX
     */
    setSkewX:function (newSkewX) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._skewX = newSkewX;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /** get the skew degrees in Y
     * @return {Number}
     */
    getSkewY:function () {
        return this._skewY;
    },

    /**
     * set the skew degrees in Y
     * @param {Number} newSkewY
     */
    setSkewY:function (newSkewY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._skewY = newSkewY;
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * zOrder getter
     * @return {Number}
     */
    getZOrder:function () {
        return this._zOrder;
    },

    /** zOrder setter : private method
     * used internally to alter the zOrder variable. DON'T call this method manually
     * @param {Number} z
     * @private
     */
    _setZOrder:function (z) {
        this._zOrder = z
    },

    /**
     * ertexZ getter
     * @return {Number}
     */
    getVertexZ:function () {
        return this._vertexZ / cc.CONTENT_SCALE_FACTOR();
    },

    /**
     * vertexZ setter
     * @param {Number} Var
     */
    setVertexZ:function (Var) {
        this._vertexZ = Var * cc.CONTENT_SCALE_FACTOR();
    },

    /**
     * rotation getter
     * @return {Number}
     */
    getRotation:function () {
        return this._rotation;
    },

    /**
     * rotation setter
     * @param {Number} newRotation
     */
    setRotation:function (newRotation) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._rotation = newRotation;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /** Get the scale factor of the node.
     * @warning: Assert when _scaleX != _scaleY.
     * @return {Number}
     */
    getScale:function () {
        cc.Assert(this._scaleX == this._scaleY, "cc.Node#scale. ScaleX != ScaleY. Don't know which one to return");
        return this._scaleX;
    },

    /**
     * The scale factor of the node. 1.0 is the default scale factor. It modifies the X and Y scale at the same time.
     * @param {Number} scale
     */
    setScale:function (scale) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._scaleX = scale;
        this._scaleY = scale;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * scaleX getter
     * @return {Number}
     */
    getScaleX:function () {
        return this._scaleX;
    },

    /**
     * scaleX setter
     * @param {Number} newScaleX
     */
    setScaleX:function (newScaleX) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._scaleX = newScaleX;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * scaleY getter
     * @return {Number}
     */
    getScaleY:function () {
        return this._scaleY;
    },

    /**
     * scaleY setter
     * @param {Number} newScaleY
     */
    setScaleY:function (newScaleY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._scaleY = newScaleY;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * position setter
     * @param {cc.Point} newPosition
     */
    setPosition:function (newPosition) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._position = newPosition;
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            this._positionInPixels = this._position;
        } else {
            this._positionInPixels = cc.ccpMult(newPosition, cc.CONTENT_SCALE_FACTOR());
        }

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * set position in pixels
     * @param {cc.Point} newPosition
     */
    setPositionInPixels:function (newPosition) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._positionInPixels = newPosition;
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            this._position = this._positionInPixels;
        } else {
            this._position = cc.ccpMult(newPosition, 1 / cc.CONTENT_SCALE_FACTOR());
        }
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();// CC_NODE_TRANSFORM_USING_AFFINE_MATRIX
    },

    /**
     * get position in pixels
     * @return {cc.Point}
     */
    getPositionInPixels:function () {
        return new cc.Point(this._positionInPixels.x, this._positionInPixels.y);
    },

    /** <p>get/set Position for Lua (pass number faster than cc.Point object)</p>

     <p>lua code:<br/>
     local x, y = node:getPosition()    -- return x, y values from C++ <br/>
     local x    = node:getPositionX()<br/>
     local y    = node:getPositionY()<br/>
     node:setPosition(x, y)             -- pass x, y values to C++ <br/>
     node:setPositionX(x) <br/>
     node:setPositionY(y)<br/>
     node:setPositionInPixels(x, y)     -- pass x, y values to C++ <br/></P>
     * @return {cc.Point}
     */
    getPosition:function () {
        return new cc.Point(this._position.x, this._position.y);
    },

    /**
     * @return {Number}
     */
    getPositionX:function () {
        return this._position.x;
    },

    /**
     * @param {Number} x
     */
    setPositionX:function (x) {
        this.setPosition(cc.ccp(x, this._position.y));
    },

    /**
     * @return {Number}
     */
    getPositionY:function () {
        return  this._position.y;
    },

    /**
     * @param {Number} y
     */
    setPositionY:function (y) {
        this.setPosition(cc.ccp(this._position.x, y));
    },

    /**
     * Get children count
     * @return {Number}
     */

    getChildrenCount:function () {
        return this._children ? this._children.length : 0;
    },

    /**
     * children getter
     * @return {object}
     */
    getChildren:function () {
        return this._children;
    },

    /**
     * camera getter: lazy alloc
     * @return {cc.Camera}
     */
    getCamera:function () {
        if (!this._camera) {
            this._camera = new cc.Camera();
        }
        return this._camera;
    },

    /**
     * grid getter
     * @return {cc.GridBase}
     */
    getGrid:function () {
        return this._grid;
    },

    /**
     * grid setter
     * @param {cc.GridBase} grid
     */
    setGrid:function (grid) {
        this._grid = grid;
    },

    /**
     * isVisible getter
     * @return {Boolean}
     */
    getIsVisible:function () {
        return this._isVisible;
    },

    /**
     * isVisible setter
     * @param {Boolean} Var
     */
    setIsVisible:function (Var) {
        this._isVisible = Var;
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /** <p>anchorPoint is the point around which all transformations and positioning manipulations take place.<br/>
     It's like a pin in the node where it is "attached" to its parent. <br/>
     The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. <br/>
     But you can use values higher than (1,1) and lower than (0,0) too.  <br/>
     The default anchorPoint is (0.5,0.5), so it starts in the center of the node. <br/></p>
     */
    getAnchorPoint:function () {
        return new cc.Point(this._anchorPoint.x, this._anchorPoint.y);
    },

    /**
     * @param {cc.Point} point
     */
    setAnchorPoint:function (point) {
        if (!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

            this._anchorPoint = point;
            this._anchorPointInPixels = new cc.Point(this._contentSizeInPixels.width * this._anchorPoint.x,
                this._contentSizeInPixels.height * this._anchorPoint.y);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /** anchorPointInPixels getter
     * @return {cc.Point}
     */
    getAnchorPointInPixels:function () {
        return new cc.Point(this._anchorPointInPixels.x, this._anchorPointInPixels.y);
    },

    /**
     * @param {ss.Size} size
     */
    setContentSizeInPixels:function (size) {
        if (!cc.Size.CCSizeEqualToSize(size, this._contentSizeInPixels)) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this._contentSizeInPixels = size;
            if (cc.CONTENT_SCALE_FACTOR() == 1) {
                this._contentSize = this._contentSizeInPixels;
            } else {
                this._contentSize = new cc.Size(size.width / cc.CONTENT_SCALE_FACTOR(), size.height / cc.CONTENT_SCALE_FACTOR());
            }
            this._anchorPointInPixels = new cc.Point(this._contentSizeInPixels.width * this._anchorPoint.x,
                this._contentSizeInPixels.height * this._anchorPoint.y);

            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this.setNodeDirty(); // CC_NODE_TRANSFORM_USING_AFFINE_MATRIX
        }
    },

    /** <p>The untransformed size of the node. <br/>
     The contentSize remains the same no matter the node is scaled or rotated.<br/>
     All nodes has a size. Layer and Scene has the same size of the screen. <br/></p>
     * @return {cc.Size}
     */
    getContentSize:function () {
        return new cc.Size(this._contentSize.width, this._contentSize.height);
    },

    /**
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this._contentSize = size;

            if (cc.CONTENT_SCALE_FACTOR() == 1) {
                this._contentSizeInPixels = this._contentSize;
            }
            else {
                this._contentSizeInPixels = new cc.Size(size.width * cc.CONTENT_SCALE_FACTOR(), size.height * cc.CONTENT_SCALE_FACTOR());
            }

            this._anchorPointInPixels = new cc.Point(this._contentSizeInPixels.width * this._anchorPoint.x,
                this._contentSizeInPixels.height * this._anchorPoint.y);
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * @return {cc.Size}
     */
    getContentSizeInPixels:function () {
        return new cc.Size(this._contentSizeInPixels.width, this._contentSizeInPixels.height);
    },

    /**
     * isRunning getter
     * @return {Boolean}
     */
    getIsRunning:function () {
        return this._isRunning;
    },

    /** parent getter
     * @return {cc.Node}
     */
    getParent:function () {
        return this._parent;
    },

    /** parent setter
     * @param {cc.Node} Var
     */
    setParent:function (Var) {
        this._parent = Var;
    },

    /** isRelativeAnchorPoint getter
     * @return {Boolean}
     */
    getIsRelativeAnchorPoint:function () {
        return this._isRelativeAnchorPoint;
    },

    /** isRelativeAnchorPoint setter
     * @param {Boolean} newValue
     */
    setIsRelativeAnchorPoint:function (newValue) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this._isRelativeAnchorPoint = newValue;

        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * tag getter
     * @return {Number}
     */
    getTag:function () {
        return this._tag;
    },

    /** tag setter
     * @param {Number} Var
     */
    setTag:function (Var) {
        this._tag = Var;
    },

    /**
     * @return {object}
     */
    getUserData:function () {
        return this._userData;
    },

    /**
     * @param {object} Var
     */
    setUserData:function (Var) {
        this._userData = Var;
    },

    /** returns a "local" axis aligned bounding box of the node. <br/>
     * The returned box is relative only to its parent.
     * @return {Number}
     */
    boundingBox:function () {
        var ret = this.boundingBoxInPixels();
        return cc.RECT_PIXELS_TO_POINTS(ret);
    },

    /**
     * returns a "local" axis aligned bounding box of the node in pixels.<br/>
     * The returned box is relative only to its parent.<br/>
     * The returned box is in Points.
     * @return {cc.Rect}
     */
    boundingBoxInPixels:function () {
        var rect = cc.RectMake(0, 0, this._contentSizeInPixels.width, this._contentSizeInPixels.height);
        return cc.RectApplyAffineTransform(rect, this.nodeToParentTransform());
    },

    /**
     * @return {cc.Rect}
     */
    boundingBoxToWorld:function () {
        var rect = cc.RectMake(0, 0, this._contentSizeInPixels.width, this._contentSizeInPixels.height);
        rect = cc.RectApplyAffineTransform(rect, this.nodeToWorldTransform());
        rect = new cc.Rect(0 | rect.origin.x - 4, 0 | rect.origin.y - 4, 0 | rect.size.width + 8, 0 | rect.size.height + 8);
        //query child's boundingBox
        if (!this._children)
            return rect;

        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (child && child._isVisible) {
                var childRect = child.boundingBoxToWorld();
                if (childRect) {
                    rect = cc.Rect.CCRectUnion(rect, childRect);
                }
            }
        }
        return rect;
    },
    /**
     * Stops all running actions and schedulers
     */
    cleanup:function () {
        // actions
        this.stopAllActions();
        this.unscheduleAllSelectors();

        // timers
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup);
    },

    /**
     * @return {String}
     */
    description:function () {
        return "<cc.Node | Tag =" + this._tag + ">";
    },

    _childrenAlloc:function () {
        this._children = [];
    },

    // composition: GET
    /**
     * Gets a child from the container given its tag
     * @param {Number} aTag
     * @return {cc.Node}
     */
    getChildByTag:function (aTag) {
        cc.Assert(aTag != cc.CCNODE_TAG_INVALID, "Invalid tag");
        if (this._children != null) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && node._tag == aTag) {
                    return node;
                }
            }
        }
        //throw "not found";
        return null;
    },
    // composition: ADD

    /** <p>"add" logic MUST only be on this method <br/> </p>
     *
     * <p>If a class want's to extend the 'addChild' behaviour it only needs  <br/>
     * to override this method </p>
     *
     * @param {cc.Node} child
     * @param {Number} zOrder
     * @param {Number} tag
     */
    addChild:function (child, zOrder, tag) {
        var argnum = arguments.length;
        cc.Assert(child != null, "Argument must be non-nil");
        cc.Assert(child._parent == null, "child already added. It can't be added again");
        var tempzOrder = (zOrder != null) ? zOrder : child.getZOrder();
        var tmptag = (tag != null) ? tag : child.getTag();
        child.setTag(tmptag);

        if (!this._children) {
            this._childrenAlloc();
        }

        this._insertChild(child, tempzOrder);

        child.setParent(this);
        if (this._isRunning) {
            child.onEnter();
            child.onEnterTransitionDidFinish();
        }

    },

    // composition: REMOVE
    /** Remove itself from its parent node. If cleanup is true, then also remove all actions and callbacks. <br/>
     *  If the node orphan, then nothing happens.
     * @param {Boolean} cleanup
     */
    removeFromParentAndCleanup:function (cleanup) {
        this._parent.removeChild(this, cleanup);
    },

    /** <p>Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter. </p>
     *
     *<p> "remove" logic MUST only be on this method  <br/>
     * If a class want's to extend the 'removeChild' behavior it only needs <br/>
     * to override this method </p>
     *
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        // explicit nil handling
        if (this._children == null) {
            return;
        }

        if (this._children.indexOf(child) > -1) {
            this._detachChild(child, cleanup);
        }

        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter
     * @param {Number} tag
     * @param {Boolean} cleanup
     */
    removeChildByTag:function (tag, cleanup) {
        cc.Assert(tag != cc.CCNODE_TAG_INVALID, "Invalid tag");

        var child = this.getChildByTag(tag);
        if (child == null) {
            cc.Log("cocos2d: removeChildByTag: child not found!");
        }
        else {
            this.removeChild(child, cleanup);
        }
    },

    /**
     * Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter.
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        // not using detachChild improves speed here
        if (this._children != null) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    // IMPORTANT:
                    //  -1st do onExit
                    //  -2nd cleanup
                    if (this._isRunning) {
                        node.onExit();
                    }
                    if (cleanup) {
                        node.cleanup();
                    }
                    // set parent nil at the end
                    node.setParent(null);
                }
            }
            this._children = [];
        }
    },

    /**
     * @param {cc.Node} child
     * @param {Boolean} doCleanup
     * @private
     */
    _detachChild:function (child, doCleanup) {
        // IMPORTANT:
        //  -1st do onExit
        //  -2nd cleanup
        if (this._isRunning) {
            child.onExit();
        }

        // If you don't do cleanup, the child's actions will not get removed and the
        // its scheduledSelectors_ dict will not get released!
        if (doCleanup) {
            child.cleanup();
        }

        // set parent nil at the end
        child.setParent(null);

        cc.ArrayRemoveObject(this._children, child);
    },

    /** helper used by reorderChild & add
     * @param {cc.Node} child
     * @param {Number} z
     * @private
     */
    _insertChild:function (child, z) {
        var a = this._children[this._children.length - 1];
        if (!a || a.getZOrder() <= z) {
            this._children.push(child);
        } else {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && (node.getZOrder() > z )) {
                    this._children = cc.ArrayAppendObjectToIndex(this._children, child, i);
                    break;
                }
            }
        }
        child._setZOrder(z);
    },

    /** Reorders a child according to a new z value. <br/>
     * The child MUST be already added.
     * @param {cc.Node} child
     * @param {Number} zOrder
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "Child must be non-nil");

        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        cc.ArrayRemoveObject(this._children, child);
        this._insertChild(child, zOrder);

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    // draw
    /** <p>Override this method to draw your own node. <br/>
     * The following GL states will be enabled by default: <br/>
     - glEnableClientState(GL_VERTEX_ARRAY);  <br/>
     - glEnableClientState(GL_COLOR_ARRAY); <br/>
     - glEnableClientState(GL_TEXTURE_COORD_ARRAY); <br/>
     - glEnable(GL_TEXTURE_2D); </p>

     <p>AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE</p>

     <p>But if you enable any other GL state, you should disable it after drawing your node. </p>
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        //cc.Assert(0);
        // override me
        // Only use- this function to draw your staff.
        // DON'T draw your stuff outside this method
    },

    /**
     * recursive method that visit its children and draw them
     * @param {CanvasContext} ctx
     */
    visit:function (ctx) {
        // quick return if not visible
        if (!this._isVisible) {
            return;
        }
        var context = ctx || cc.renderContext;
        context.save();

        if (this._grid && this._grid.isActive()) {
            this._grid.beforeDraw();
            this.transformAncestors();
        }

        this.transform(context);
        var i, node;
        if (this._children) {
            // draw children zOrder < 0
            for (i = 0; i < this._children.length; i++) {
                node = this._children[i];
                if (node && node._zOrder < 0) {
                    node.visit(context);
                } else {
                    break;
                }
            }
        }

        //if (this._isInDirtyRegion()) {
        // self draw
        this.draw(context);
        //}

        // draw children zOrder >= 0
        if (this._children) {
            for (; i < this._children.length; i++) {
                node = this._children[i];
                if (node && node._zOrder >= 0) {
                    node.visit(context);
                }
            }
        }

        if (this._grid && this._grid.isActive()) {
            this._grid.afterDraw(this);
        }

        context.restore();
    },

    /** performs OpenGL view-matrix transformation of it's ancestors.<br/>
     * Generally the ancestors are already transformed, but in certain cases (eg: attaching a FBO) <br/>
     * it's necessary to transform the ancestors again.
     */
    transformAncestors:function () {
        if (this._parent != null) {
            this._parent.transformAncestors();
            this._parent.transform();
        }
    },

    /** transformations <br/>
     * performs OpenGL view-matrix transformation based on position, scale, rotation and other attributes.
     * @param {CanvasContext} ctx
     */
    transform:function (ctx) {
        var context = ctx || cc.renderContext;
        // transformations
        if (cc.renderContextType == cc.CANVAS) {
            var pAp;
            if (this._isRelativeAnchorPoint) {
                if (this._parent) {
                    pAp = this._parent._anchorPointInPixels;
                } else {
                    pAp = new cc.Point(0, 0);
                }
                context.translate(0 | (this._position.x - pAp.x), -(0 | (this._position.y - pAp.y)));
            } else {
                if (this._parent) {
                    pAp = this._parent._anchorPointInPixels;
                } else {
                    pAp = new cc.Point(0, 0);
                }
                var lAp = this._anchorPointInPixels;
                context.translate(0 | ( this._position.x - pAp.x + lAp.x), -(0 | (this._position.y - pAp.y + lAp.y)));
            }

            if (this._rotation != 0) {
                context.rotate(cc.DEGREES_TO_RADIANS(this._rotation));
            }
            if ((this._scaleX != 1) || (this._scaleY != 1)) {
                context.scale(this._scaleX, this._scaleY);
            }
            if ((this._skewX != 0) || (this._skewY != 0)) {
                context.transform(1,
                    -Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)),
                    -Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)),
                    1, 0, 0);
            }
        } else {
            //Todo WebGL implement need fixed
            if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
                // BEGIN alternative -- using cached transform
                //
                if (this._isTransformGLDirty) {
                    var t = this.nodeToParentTransform();
                    //cc.CGAffineToGL(t, this._transformGL);
                    this._isTransformGLDirty = false;
                }
                //glMultMatrixf(this._transformGL);
                if (this._vertexZ) {
                    //glTranslatef(0, 0, this._vertexZ);
                }

                // XXX: Expensive calls. Camera should be integrated into the cached affine matrix
                if (this._camera && !(this._grid && this._grid.isActive())) {
                    var translate = (this._anchorPointInPixels.x != 0.0 || this._anchorPointInPixels.y != 0.0);

                    if (translate) {
                        //cc.glTranslate(RENDER_IN_SUBPIXEL(this._anchorPointInPixels.x), RENDER_IN_SUBPIXEL(this._anchorPointInPixels.y), 0);
                    }
                    this._camera.locate();
                    if (translate) {
                        //cc.glTranslate(RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.x), RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.y), 0);
                    }
                }
                // END alternative
            } else {
                // BEGIN original implementation
                //
                // translate
                if (this._isRelativeAnchorPoint && (this._anchorPointInPixels.x != 0 || this._anchorPointInPixels.y != 0 )) {
                    //cc.glTranslatef(RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.x), RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.y), 0);
                }
                if (this._anchorPointInPixels.x != 0 || this._anchorPointInPixels.y != 0) {
                    //cc.glTranslatef(RENDER_IN_SUBPIXEL(this._positionInPixels.x + this._anchorPointInPixels.x), RENDER_IN_SUBPIXEL(this._positionInPixels.y + this._anchorPointInPixels.y), this._vertexZ);
                }
                else if (this._positionInPixels.x != 0 || this._positionInPixels.y != 0 || this._vertexZ != 0) {
                    //cc.glTranslatef(RENDER_IN_SUBPIXEL(this._positionInPixels.x), RENDER_IN_SUBPIXEL(this._positionInPixels.y), this._vertexZ);
                }
                // rotate
                if (this._rotation != 0.0) {
                    //glRotatef(-this._rotation, 0.0, 0.0, 1.0);
                }

                // skew
                //if ((skewX_ != 0.0) || (skewY_ != 0.0)) {
                //var skewMatrix = new cc.AffineTransform();
                //skewMatrix = cc.AffineTransformMake(1.0, Math.tan(cc.DEGREES_TO_RADIANS(skewY_)), Math.tan(cc.DEGREES_TO_RADIANS(skewX_)), 1.0, 0.0, 0.0);
                //TODO
                // glMatrix = new GLfloat();
                //cc.AffineToGL(skewMatrix, glMatrix);
                //TODO
                // glMultMatrixf(glMatrix);
                // }

                // scale
                if (this._scaleX != 1.0 || this._scaleY != 1.0) {
                    // glScalef(this._scaleX, this._scaleY, 1.0);
                }
                if (this._camera && !(this._grid && this._grid.isActive()))
                    this._camera.locate();

                // restore and re-position point
                if (this._anchorPointInPixels.x != 0.0 || this._anchorPointInPixels.y != 0.0) {
                    // glTranslatef(RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.x), RENDER_IN_SUBPIXEL(-this._anchorPointInPixels.y), 0);
                }
                //
                // END original implementation
            }
        }
    },

    //scene managment
    /**
     * callback that is called every time the cc.Node enters the 'stage'.<br/>
     * If the cc.Node enters the 'stage' with a transition, this callback is called when the transition starts.
     * During onEnter you can't a "sister/brother" node.
     */
    onEnter:function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resumeSchedulerAndActions();
        this._isRunning = true;
    },

    /**
     * callback that is called when the cc.Node enters in the 'stage'.  <br/>
     * If the cc.Node enters the 'stage' with a transition, this callback is called when the transition finishes.
     */
    onEnterTransitionDidFinish:function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish);
    },

    /**
     * callback that is called every time the cc.Node leaves the 'stage'.<br/>
     * If the cc.Node leaves the 'stage' with a transition, this callback is called when the transition finishes. <br/>
     * During onExit you can't access a sibling node.
     */
    onExit:function () {
        this.pauseSchedulerAndActions();
        this._isRunning = false;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit);
    },

    // actions
    /**
     * Executes an action, and returns the action that is executed.<br/>
     * The node becomes the action's target.
     * @warning Starting from v0.8 actions don't retain their target anymore.
     * @param {cc.Action} action
     * @return {cc.Action}
     */
    runAction:function (action) {
        cc.Assert(action != null, "Argument must be non-nil");
        cc.ActionManager.sharedManager().addAction(action, this, !this._isRunning);
        return action;
    },

    /**
     * Removes all actions from the running action list
     */
    stopAllActions:function () {
        cc.ActionManager.sharedManager().removeAllActionsFromTarget(this);
    },

    /**
     * Removes an action from the running action list
     * @param {cc.Action} action
     */
    stopAction:function (action) {
        cc.ActionManager.sharedManager().removeAction(action);
    },

    /**
     * Removes an action from the running action list given its tag
     * @param {Number} tag
     */
    stopActionByTag:function (tag) {
        cc.Assert(tag != cc.CCACTION_TAG_INVALID, "Invalid tag");
        cc.ActionManager.sharedManager().removeActionByTag(tag, this);
    },

    /**
     * Gets an action from the running action list given its tag
     * @param {Number} tag
     * @return {cc.Action}
     */
    getActionByTag:function (tag) {
        cc.Assert(tag != cc.CCACTION_TAG_INVALID, "Invalid tag");
        return cc.ActionManager.sharedManager().getActionByTag(tag, this);
    },

    /** Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).<br/>
     *    Composable actions are counted as 1 action. Example:<br/>
     *    If you are running 1 Sequence of 7 actions, it will return 1. <br/>
     *    If you are running 7 Sequences of 2 actions, it will return 7.
     * @return {Number}
     */
    numberOfRunningActions:function () {
        return cc.ActionManager.sharedManager.numberOfRunningActionsInTarget(this);
    },

    // cc.Node - Callbacks
    // timers

    /**
     * check whether a selector is scheduled.
     * @param {function} selector
     */
    isScheduled:function (selector) {
        //can't find this function in the cc.Node.cpp file
    },

    /**
     * schedules the "update" method. It will use the order number 0. This method will be called every frame.<br/>
     * Scheduled methods with a lower order value will be called before the ones that have a higher order value.<br/>
     * Only one "update" method could be scheduled per node.
     */
    scheduleUpdate:function () {
        this.scheduleUpdateWithPriority(0);
    },

    /**
     * schedules the "update" selector with a custom priority. This selector will be called every frame.<br/>
     * Scheduled selectors with a lower priority will be called before the ones that have a higher value.<br/>
     * Only one "update" selector could be scheduled per node (You can't have 2 'update' selectors).<br/>
     * @param {Number} priority
     */
    scheduleUpdateWithPriority:function (priority) {
        cc.Scheduler.sharedScheduler().scheduleUpdateForTarget(this, priority, !this._isRunning);
    },

    /**
     * unschedules the "update" method.
     */
    unscheduleUpdate:function () {
        cc.Scheduler.sharedScheduler().unscheduleUpdateForTarget(this);
    },

    /**
     * schedule
     * @param {function} selector
     * @param {Number} interval
     */
    schedule:function (selector, interval) {
        if (!interval)
            interval = 0;

        cc.Assert(selector, "Argument must be non-nil");
        cc.Assert(interval >= 0, "Argument must be positive");
        cc.Scheduler.sharedScheduler().scheduleSelector(selector, this, interval, !this._isRunning);
    },

    /**
     * unschedules a custom selector.
     * @param {function} selector
     */
    unschedule:function (selector) {
        // explicit nil handling
        if (!selector)
            return;

        cc.Scheduler.sharedScheduler().unscheduleSelector(selector, this);
    },

    /**
     * unschedule all scheduled selectors: custom selectors, and the 'update' selector.<br/>
     * Actions are not affected by this method.
     */
    unscheduleAllSelectors:function () {
        cc.Scheduler.sharedScheduler().unscheduleAllSelectorsForTarget(this);
    },

    /**
     * resumes all scheduled selectors and actions.<br/>
     * Called internally by onEnter
     */
    resumeSchedulerAndActions:function () {
        cc.Scheduler.sharedScheduler().resumeTarget(this);
        cc.ActionManager.sharedManager().resumeTarget(this);
    },

    /**
     * pauses all scheduled selectors and actions.<br/>
     * Called internally by onExit
     */
    pauseSchedulerAndActions:function () {
        cc.Scheduler.sharedScheduler().pauseTarget(this);
        cc.ActionManager.sharedManager().pauseTarget(this);
    },

    /** Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates.<br/>
     * The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    nodeToParentTransform:function () {
        if (this._isTransformDirty) {
            this._transform = cc.AffineTransformIdentity();
            if (!this._isRelativeAnchorPoint && !cc.Point.CCPointEqualToPoint(this._anchorPointInPixels, cc.PointZero())) {
                this._transform = cc.AffineTransformTranslate(this._transform, this._anchorPointInPixels.x, this._anchorPointInPixels.y);
            }

            if (!cc.Point.CCPointEqualToPoint(this._positionInPixels, cc.PointZero())) {
                this._transform = cc.AffineTransformTranslate(this._transform, this._positionInPixels.x, this._positionInPixels.y);
            }

            if (this._rotation != 0) {
                this._transform = cc.AffineTransformRotate(this._transform, -cc.DEGREES_TO_RADIANS(this._rotation));
            }

            if (this._skewX != 0 || this._skewY != 0) {
                // create a skewed coordinate system
                var skew = cc.AffineTransformMake(1.0, Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)), Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)), 1.0, 0.0, 0.0);
                // apply the skew to the transform
                this._transform = cc.AffineTransformConcat(skew, this._transform);
            }

            if (!(this._scaleX == 1 && this._scaleY == 1)) {
                this._transform = cc.AffineTransformScale(this._transform, this._scaleX, this._scaleY);
            }

            if (!cc.Point.CCPointEqualToPoint(this._anchorPointInPixels, cc.PointZero())) {
                this._transform = cc.AffineTransformTranslate(this._transform, -this._anchorPointInPixels.x, -this._anchorPointInPixels.y);
            }

            this._isTransformDirty = false;
        }

        return this._transform;
    },

    /**
     * Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.<br/>
     * The matrix is in Pixels.
     * @return {Number}
     */
    parentToNodeTransform:function () {
        if (this._isInverseDirty) {
            this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform());
            this._isInverseDirty = false;
        }

        return this._inverse;
    },

    /**
     *  Retrusn the world affine transform matrix. The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    nodeToWorldTransform:function () {
        var t = this.nodeToParentTransform();
        for (var p = this._parent; p != null; p = p.getParent()) {
            t = cc.AffineTransformConcat(t, p.nodeToParentTransform());
        }
        return t;
    },

    /**
     * Returns the inverse world affine transform matrix. The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    worldToNodeTransform:function () {
        return cc.AffineTransformInvert(this.nodeToWorldTransform());
    },

    /**
     * Converts a Point to node (local) space coordinates. The result is in Points.
     * @param {cc.Point} worldPoint
     * @return {cc.Point}
     */
    convertToNodeSpace:function (worldPoint) {
        var ret = new cc.Point();
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            ret = cc.PointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
        }
        else {
            ret = cc.ccpMult(worldPoint, cc.CONTENT_SCALE_FACTOR());
            ret = cc.PointApplyAffineTransform(ret, this.worldToNodeTransform());
            ret = cc.ccpMult(ret, 1 / cc.CONTENT_SCALE_FACTOR());
        }
        return ret;
    },

    /**
     * Converts a Point to world space coordinates. The result is in Points.
     * @param {cc.Point} nodePoint
     * @return {cc.Point}
     */
    convertToWorldSpace:function (nodePoint) {
        var ret = new cc.Point();
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            ret = cc.PointApplyAffineTransform(nodePoint, this.nodeToWorldTransform());
        }
        else {
            ret = cc.ccpMult(nodePoint, cc.CONTENT_SCALE_FACTOR());
            ret = cc.PointApplyAffineTransform(ret, this.nodeToWorldTransform());
            ret = cc.ccpMult(ret, 1 / cc.CONTENT_SCALE_FACTOR());
        }

        return ret;
    },

    /**
     * Converts a Point to node (local) space coordinates. The result is in Points.<br/>
     * treating the returned/received node point as anchor relative.
     * @param {cc.Point} worldPoint
     * @return {cc.Point}
     */
    convertToNodeSpaceAR:function (worldPoint) {
        var nodePoint = this.convertToNodeSpace(worldPoint);
        var anchorInPoints = new cc.Point();
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            anchorInPoints = this._anchorPointInPixels;
        } else {
            anchorInPoints = cc.ccpMult(this._anchorPointInPixels, 1 / cc.CONTENT_SCALE_FACTOR());
        }
        return cc.ccpSub(nodePoint, anchorInPoints);
    },

    /**
     * Converts a local Point to world space coordinates.The result is in Points.<br/>
     * treating the returned/received node point as anchor relative.
     * @param {cc.Point} nodePoint
     * @return {cc.Point}
     */
    convertToWorldSpaceAR:function (nodePoint) {
        var anchorInPoints = new cc.Point();
        if (cc.CONTENT_SCALE_FACTOR() == 1) {
            anchorInPoints = this._anchorPointInPixels;
        } else {
            anchorInPoints = cc.ccpMult(this._anchorPointInPixels, 1 / cc.CONTENT_SCALE_FACTOR());
        }
        var pt = new cc.Point();
        pt = cc.ccpAdd(nodePoint, anchorInPoints);
        return this.convertToWorldSpace(pt);
    },

    /**
     * @param nodePoint
     * @return {cc.Point}
     * @private
     */
    _convertToWindowSpace:function (nodePoint) {
        var worldPoint = new cc.Point();
        worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.Director.sharedDirector().convertToUI(worldPoint);
    },

    /** convenience methods which take a cc.Touch instead of cc.Point
     * @param {cc.Touch} touch
     * @return {cc.Point}
     */
    convertTouchToNodeSpace:function (touch) {
        var point = touch.locationInView(touch.view());
        point = cc.Director.sharedDirector().convertToGL(point);
        return this.convertToNodeSpace(point);
    },

    /**
     * converts a cc.Touch (world coordinates) into a local coordiante. This method is AR (Anchor Relative).
     * @param {cc.Touch}touch
     * @return {cc.Point}
     */
    convertTouchToNodeSpaceAR:function (touch) {
        var point = touch.locationInView(touch.view());
        point = cc.Director.sharedDirector().convertToGL(point);
        return this.convertToNodeSpaceAR(point);
    },

    /** implement cc.Object's method
     * @param {Number} dt
     */
    update:function (dt) {
    }
});

/**
 * cc.Node's state callback type
 * @constant
 * @type Number
 */
cc.Node.StateCallbackType = {onEnter:1, onExit:2, cleanup:3, onEnterTransitionDidFinish:4, updateTransform:5};


/**
 * allocates and initializes a node.
 * @constructs
 * @return {cc.Node}
 * @example
 * // example
 * var node = cc.Node.create();
 */
cc.Node.create = function () {
    return new cc.Node();
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/** <p> cc.AtlasNode is a subclass of cc.Node that implements the cc.RGBAProtocol and<br/>
 * cc.TextureProtocol protocol</p>
 *
 * <p> It knows how to render a TextureAtlas object.  <br/>
 * If you are going to render a TextureAtlas consider subclassing cc.AtlasNode (or a subclass of cc.AtlasNode)</p>
 *
 * <p> All features from cc.Node are valid, plus the following features:  <br/>
 * - opacity and RGB colors </p>
 * @class
 * @extends cc.Node
 */
cc.AtlasNode = cc.Node.extend(/** @lends cc.AtlasNode# */{
    //! chars per row
    _itemsPerRow:0,
    //! chars per column
    _itemsPerColumn:0,
    //! width of each char
    _itemWidth:0,
    //! height of each char
    _itemHeight:0,
    _colorUnmodified:new cc.Color3B(0, 0, 0),
    _textureAtlas:null,
    // protocol variables
    _isOpacityModifyRGB:false,
    _blendFunc:new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST),
    _opacity:0,
    _color:null,
    _originalTexture:null,
    // quads to draw
    _quadsToDraw:0,

    /** initializes an cc.AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render
     * @param {String} tile
     * @param {Number} tileWidth
     * @param {Number} tileHeight
     * @param {Number} itemsToRender
     * @return {Boolean}
     */
    initWithTileFile:function (tile, tileWidth, tileHeight, itemsToRender) {
        cc.Assert(tile != null, "title should not be null");
        this._itemWidth = tileWidth * cc.CONTENT_SCALE_FACTOR();
        this._itemHeight = tileHeight * cc.CONTENT_SCALE_FACTOR();

        this._opacity = 255;
        this._color = this._colorUnmodified = cc.WHITE();
        this._isOpacityModifyRGB = true;

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        // double retain to avoid the autorelease pool
        // also, using: self.textureAtlas supports re-initialization without leaking
        this._textureAtlas = new cc.TextureAtlas();
        this._textureAtlas.initWithFile(tile, itemsToRender);
        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = this._textureAtlas.getTexture();
        }
        if (!this._textureAtlas) {
            cc.Log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.");
            return false;
        }

        this._updateBlendFunc();
        this._updateOpacityModifyRGB();

        this._calculateMaxItems();

        this._quadsToDraw = itemsToRender;

        return true;

    },

    /** updates the Atlas (indexed vertex array).
     * Shall be overriden in subclasses
     */
    updateAtlasValues:function () {
        cc.Assert(false, "cc.AtlasNode:Abstract updateAtlasValue not overriden");
    },

    /**
     * @param {CanvasContext} ctx   CanvasContext
     */
    draw:function (ctx) {
        this._super();
        if (cc.renderContextType == cc.CANVAS) {

        }
        else {
            // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Unneeded states: GL_COLOR_ARRAY
            //TODO, for webgl porting.
            //glDisableClientState(GL_COLOR_ARRAY);

            // glColor4ub isn't implement on some android devices
            // glColor4ub( color.r, color.g, color.b, opacity);
            //glColor4f(((GLfloat)color.r) / 255, ((GLfloat)color.g) / 255, ((GLfloat)color.b) / 255, ((GLfloat)opacity) / 255);
            var newBlend = this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST;
            if (newBlend) {
                // TODO, need to be fixed
                //glBlendFunc( blendFunc.src, blendFunc.dst );
            }

            this._textureAtlas.drawNumberOfQuads(this._quadsToDraw, 0);

            if (newBlend) {
                //glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
            }

            // is this chepear than saving/restoring color state ?
            // XXX: There is no need to restore the color to (255,255,255,255). Objects should use the color
            // XXX: that they need
            //	glColor4ub( 255, 255, 255, 255);

            // restore default GL state
            //TODO, need to be fixed.
            //glEnableClientState(GL_COLOR_ARRAY);
        }
    },

    /** cc.AtlasNode - RGBA protocol
     * @return {cc.Color3B}
     */
    getColor:function () {
        if (this._isOpacityModifyRGB) {
            return this._colorUnmodified;
        }
        return this._color;
    },

    /**
     * @param {cc.Color3B} color3
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r)&&(this._color.g == color3.g)&&(this._color.b == color3.b)) {
            return;
        }
        this._color = this._colorUnmodified = color3;

        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.sharedTextureCache().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    //generate color texture cache
                    var tx = this.getTexture();
                    var textureRect = new cc.Rect(0,0,tx.width,tx.height);
                    var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color,textureRect);
                    var img = new Image();
                    img.src = colorTexture.toDataURL();
                    this.setTexture(img);
                }
            }
        }

        if (this._isOpacityModifyRGB) {
            this._color.r = color3.r * this._opacity / 255;
            this._color.g = color3.g * this._opacity / 255;
            this._color.b = color3.b * this._opacity / 255;
        }
    },

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} opacity
     */
    setOpacity:function (opacity) {
        this._opacity = opacity;
        return;
        // special opacity for premultiplied textures
        if (this._isOpacityModifyRGB) {
            this.setColor(this._colorUnmodified);
        }
    },

    /**
     * @param {Boolean} value
     */
    setIsOpacityModifyRGB:function (value) {
        var oldColor = this._color;
        this._isOpacityModifyRGB = value;
        this._color = oldColor;
    },

    /**
     * @return {Boolean}
     */
    getIsOpacityModifyRGB:function () {
        return this._isOpacityModifyRGB;
    },

    /** cc.AtlasNode - CocosNodeTexture protocol
     * @return {cc.BlendFunc}
     */

    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * @param {cc.BlendFunc} blendFunc
     */
    setBlendFunc:function (blendFunc) {
        this._blendFunc = blendFunc;
    },

    // cc.Texture protocol

    /** returns the used texture
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._textureAtlas.getTexture();
    },

    /** sets a new texture. it will be retained
     * @param {cc.Texture2D} texture
     */
    setTexture:function (texture) {
        this._textureAtlas.setTexture(texture);
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
    },

    /**
     * @param {cc.TextureAtlas} value
     */
    setTextureAtlas:function (value) {
        this._textureAtlas = value;
    },

    /**
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function () {
        return this._textureAtlas;
    },

    /**
     * @return {Number}
     */
    getQuadsToDraw:function () {
        return this._quadsToDraw;
    },

    /**
     * @param {Number} quadsToDraw
     */
    setQuadsToDraw:function (quadsToDraw) {
        this._quadsToDraw = quadsToDraw;
    },

    _calculateMaxItems:function () {
        var s = this._textureAtlas.getTexture();
        this._itemsPerColumn = parseInt(s.height / this._itemHeight);
        this._itemsPerRow = parseInt(s.width / this._itemWidth);
    },

    _updateBlendFunc:function () {
        /* if (!this._textureAtlas.getTexture().getHasPremultipliedAlpha()) {
         this._blendFunc.src = cc.GL_SRC_ALPHA;
         this._blendFunc.dst = cc.GL_ONE_MINUS_SRC_ALPHA;
         }*/
    },

    _updateOpacityModifyRGB:function () {
        //this._isOpacityModifyRGB = this._textureAtlas.getTexture().getHasPremultipliedAlpha();
    }

});

/** creates a cc.AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render
 * @param {String} tile
 * @param {Number} tileWidth
 * @param {Number} tileHeight
 * @param {Number} itemsToRender
 * @return {cc.AtlasNode}
 * @example
 * // example
 * var node = cc.AtlasNode.create("pathOfTile", 16, 16, 1);
 */
cc.AtlasNode.create = function (tile, tileWidth, tileHeight, itemsToRender) {
    var ret = new cc.AtlasNode();
    if (ret.initWithTileFile(tile, tileWidth, tileHeight, itemsToRender)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var cc = cc = cc || {};

//CONSTANTS:

/** @typedef CCTexture2DPixelFormat
 Possible texture pixel formats
 */
/*
 * Support for RGBA_4_4_4_4 and RGBA_5_5_5_1 was copied from:
 * https://devforums.apple.com/message/37855#37855 by a1studmuffin
 */
cc.CCTEXTURE_2D_PIXEL_FORMAT_AUTOMATIC = 0;
//! 32-bit texture: RGBA8888
cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888 = 1;
//! 24-bit texture: RGBA888
cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888 = 2;
//! 16-bit texture without Alpha channel
cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565 = 3;
//! 8-bit textures used as masks
cc.CCTEXTURE_2D_PIXEL_FORMAT_A8 = 4;
//! 8-bit intensity texture
cc.CCTEXTURE_2D_PIXEL_FORMAT_I8 = 5;
//! 16-bit textures used as masks
cc.CCTEXTURE_2D_PIXEL_FORMAT_AI88 = 6;
//! 16-bit textures: RGBA4444
cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444 = 7;
//! 16-bit textures: RGB5A1
cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1 = 8;
//! 4-bit PVRTC-compressed texture: PVRTC4
cc.CCTEXTURE_2D_PIXEL_FORMAT_PVRTC4 = 9;
//! 2-bit PVRTC-compressed texture: PVRTC2
cc.CCTEXTURE_2D_PIXEL_FORMAT_PVRTC2 = 10;

//! Default texture format: RGBA8888
cc.CCTEXTURE_2D_PIXEL_FORMAT_DEFAULT = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888;

// backward compatibility stuff
cc.TEXTURE_2D_PIXEL_FORMAT_AUTOMATIC = cc.CCTEXTURE_2D_PIXEL_FORMAT_AUTOMATIC;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB888 = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB565 = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565;
cc.TEXTURE_2D_PIXEL_FORMAT_A8 = cc.CCTEXTURE_2D_PIXEL_FORMAT_A8;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444 = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1 = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1;
cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT = cc.CCTEXTURE_2D_PIXEL_FORMAT_DEFAULT;

if (cc.FONT_LABEL_SUPPORT) {
//TODO
// FontLabel support
}// CC_FONT_LABEL_SUPPORT

if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
    //TODO include CCTextureCache.h
}

// If the image has alpha, you can create RGBA8 (32-bit) or RGBA4 (16-bit) or RGB5A1 (16-bit)
// Default is: RGBA8888 (32-bit textures)
cc.g_defaultAlphaPixelFormat = cc.CCTEXTURE_2D_PIXEL_FORMAT_DEFAULT;
// By default PVR images are treated as if they don't have the alpha channel premultiplied
cc.PVRHaveAlphaPremultiplied_ = false;
/**
 Extension to set the Min / Mag filter
 */

function _ccTexParams(minFilter, magFilter, wrapS, wrapT) {
    this.minFilter = minFilter;
    this.magFilter = magFilter;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
}

//CLASS INTERFACES:

/** @brief cc.Texture2D class.
 * This class allows to easily create OpenGL 2D textures from images, text or raw data.
 * The created cc.Texture2D object will always have power-of-two dimensions.
 * Depending on how you create the cc.Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. "contentSize" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).
 * Be aware that the content of the generated textures will be upside-down!
 */
cc.Texture2D = cc.Class.extend({
    // By default PVR images are treated as if they don't have the alpha channel premultiplied
    _pVRHaveAlphaPremultiplied:null,
    _pixelFormat:null,
    _pixelsWide:null,
    _pixelsHigh:null,
    _name:null,
    _contentSize:null,
    _maxS:null,
    _maxT:null,
    _hasPremultipliedAlpha:null,

    /*public:*/
    ctor:function () {
        // implementation CCTexture2D (PVRTC);
        if (cc.SUPPORT_PVRTC) {
            /**
             Extensions to make it easy to create a cc.Texture2D object from a PVRTC file
             Note that the generated textures don't have their alpha premultiplied - use the blending mode (cc.GL_SRC_ALPHA, cc.GL_ONE_MINUS_SRC_ALPHA).
             */
            /** Initializes a texture from a PVRTC buffer */
            this.initWithPVRTCData = function (data, level, bpp, hasAlpha, length, pixelFormat) {
                if (!(cc.Configuration.sharedConfiguration().isSupportsPVRTC())) {
                    cc.Log("cocos2d: WARNING: PVRTC images is not supported.");
                    return false;
                }

                //TODO
                // glGenTextures(1, this._name);
                //TODO
                // glBindTexture(cc.GL_TEXTURE_2D, this._name);

                this.setAntiAliasTexParameters();

                var format;
                var size = new cc.GLsizei();
                size = length * length * bpp / 8;
                if (hasAlpha) {
                    format = (bpp == 4) ? cc.GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG : cc.GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else {
                    format = (bpp == 4) ? cc.GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG : cc.GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                }
                if (size < 32) {
                    size = 32;
                }
                //TODO
                // glCompressedTexImage2D(cc.GL_TEXTURE_2D, level, format, length, length, 0, size, data);

                this._contentSize = cc.SizeMake(length, length);
                this._pixelsWide = length;
                this._pixelsHigh = length;
                this._maxS = 1.0;
                this._maxT = 1.0;
                this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
                this._pixelFormat = pixelFormat;

                return true;
            };
        }// cc.SUPPORT_PVRTC
    },
    /** pixel format of the texture */
    getPixelFormat:function () {
        return this._pixelFormat;
    },
    //** width in pixels *//
    getPixelsWide:function () {
        return this._pixelsWide;
    },
    //** hight in pixels *//
    getPixelsHigh:function () {
        return this._pixelsHigh;
    },
    //** texture name *//
    getName:function () {
        return this._name;
    },
    //** content size *//
    getContentSizeInPixels:function () {
        var ret = new cc.Size();
        ret.width = this._contentSize.width / cc.CONTENT_SCALE_FACTOR();
        ret.height = this._contentSize.height / cc.CONTENT_SCALE_FACTOR();

        return ret;
    },
    //** texture max S *//
    getMaxS:function () {
        return this._maxS;
    },
    setMaxS:function (maxS) {
        this._maxS = maxS;
    },
    //** texture max T *//
    getMaxT:function () {
        return this._maxT;
    },
    setMaxT:function (maxT) {
        this._maxT = maxT;
    },
    //** whether or not the texture has their Alpha premultiplied *//
    getHasPremultipliedAlpha:function () {
        return this._hasPremultipliedAlpha;
    },
    description:function () {
        var ret = "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh
            + " | Coordinates = (" + this._maxS + ", " + this._maxT + ")>";
        return ret;
    },
    /** These functions are needed to create mutable textures */
    releaseData:function (data) {
        cc.free(data);
    },
    keepData:function (data, length) {
        //The texture data mustn't be saved becuase it isn't a mutable texture.
        return data;
    },

    /** Intializes with a texture2d with data */
    initWithData:function (pixelFormat, pixelsWide, pixelsHigh, contentSize) {
        //TODO
        // glPixelStorei(cc.GL_UNPACK_ALIGNMENT,1);
        //TODO
        // glGenTextures(1, this._name);
        //TODO
        // glBindTexture(cc.GL_TEXTURE_2D, this._name);

        this.setAntiAliasTexParameters();

        // Specify OpenGL texture image

        switch (pixelFormat) {
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_RGBA, cc.GL_UNSIGNED_BYTE, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_RGB, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_RGB, cc.GL_UNSIGNED_BYTE, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_RGBA, cc.GL_UNSIGNED_SHORT_4_4_4_4, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_RGBA, cc.GL_UNSIGNED_SHORT_5_5_5_1, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_RGB, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_RGB, cc.GL_UNSIGNED_SHORT_5_6_5, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_AI88:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_LUMINANCE_ALPHA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_LUMINANCE_ALPHA, cc.GL_UNSIGNED_BYTE, data);
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_A8:
                //TODO
                // glTexImage2D(cc.GL_TEXTURE_2D, 0, cc.GL_ALPHA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, cc.GL_ALPHA, cc.GL_UNSIGNED_BYTE, data);
                break;
            default:
                cc.Assert(0, "NSInternalInconsistencyException");

        }

        this._contentSize = contentSize;
        this._pixelsWide = pixelsWide;
        this._pixelsHigh = pixelsHigh;
        this._pixelFormat = pixelFormat;
        this._maxS = contentSize.width / pixelsWide;
        this._maxT = contentSize.height / pixelsHigh;

        this._hasPremultipliedAlpha = false;

        return true;
    },

    /**
     Drawing extensions to make it easy to draw basic quads using a CCTexture2D object.
     These functions require cc.GL_TEXTURE_2D and both cc.GL_VERTEX_ARRAY and cc.GL_TEXTURE_COORD_ARRAY client states to be enabled.
     */
    /** draws a texture at a given point */
    drawAtPoint:function (point) {
        var coordinates = [
            0.0, this._maxT,
            this._maxS, this._maxT,
            0.0, 0.0,
            this._maxS, 0.0 ];

        var width = this._pixelsWide * this._maxS,
            height = this._pixelsHigh * this._maxT;

        var vertices = [
            point.x, point.y, 0.0,
            width + point.x, point.y, 0.0,
            point.x, height + point.y, 0.0,
            width + point.x, height + point.y, 0.0 ];

        //TODO
        // glBindTexture(cc.GL_TEXTURE_2D, this._name);
        //TODO
        // glVertexPointer(3, cc.GL_FLOAT, 0, vertices);
        //TODO
        // glTexCoordPointer(2, cc.GL_FLOAT, 0, coordinates);
        //TODO
        // glDrawArrays(cc.GL_TRIANGLE_STRIP, 0, 4);
    },

    /** draws a texture inside a rect */
    drawInRect:function (rect) {
        var coordinates = [
            0.0, this._maxT,
            this._maxS, this._maxT,
            0.0, 0.0,
            this._maxS, 0.0];

        var vertices = [    rect.origin.x, rect.origin.y, /*0.0,*/
            rect.origin.x + rect.size.width, rect.origin.y, /*0.0,*/
            rect.origin.x, rect.origin.y + rect.size.height, /*0.0,*/
            rect.origin.x + rect.size.width, rect.origin.y + rect.size.height        /*0.0*/ ];

        //TODO
        // glBindTexture(cc.GL_TEXTURE_2D, this._name);
        //TODO
        // glVertexPointer(2, cc.GL_FLOAT, 0, vertices);
        //TODO
        // glTexCoordPointer(2, cc.GL_FLOAT, 0, coordinates);
        //TODO
        // glDrawArrays(cc.GL_TRIANGLE_STRIP, 0, 4);
    },

    /**
     Extensions to make it easy to create a CCTexture2D object from an image file.
     Note that RGBA type textures will have their alpha premultiplied - use the blending mode (cc.GL_ONE, cc.GL_ONE_MINUS_SRC_ALPHA).
     */
    /** Initializes a texture from a UIImage object */
    initWithImage:function (uiImage) {
        var POTWide, POTHigh;

        if (uiImage == null) {
            cc.Log("cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil");
            return false;
        }

        var conf = cc.Configuration.sharedConfiguration();

        if (cc.TEXTURE_NPOT_SUPPORT) {
            if (conf.isSupportsNPOT()) {
                POTWide = uiImage.getWidth();
                POTHigh = uiImage.getHeight();
            }
        } else {
            POTWide = cc.NextPOT(uiImage.getWidth());
            POTHigh = cc.NextPOT(uiImage.getHeight());
        }


        var maxTextureSize = conf.getMaxTextureSize();
        if (POTHigh > maxTextureSize || POTWide > maxTextureSize) {
            cc.Log("cocos2d: WARNING: Image (%u x %u) is bigger than the supported %u x %u", POTWide, POTHigh, maxTextureSize, maxTextureSize);
            return null;
        }

        // always load premultiplied images
        return this._initPremultipliedATextureWithImage(uiImage, POTWide, POTHigh);
    },

    /**
     Extensions to make it easy to create a cc.Texture2D object from a string of text.
     Note that the generated textures are of type A8 - use the blending mode (cc.GL_SRC_ALPHA, cc.GL_ONE_MINUS_SRC_ALPHA).
     */
    /** Initializes a texture from a string with dimensions, alignment, font name and font size */
    initWithString:function (text, dimensions, alignment, fontName, fontSize) {
        if (arguments.length == 3) {
            fontName = arguments[1];
            fontSize = arguments[2];
            dimensions = cc.SizeMake(0, 0);
            alignment = cc.TEXT_ALIGNMENT_CENTER;
        }
        if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
            // cache the texture data
            cc.VolatileTexture.addStringTexture(this, text, dimensions, alignment, fontName, fontSize);
        }
        var image = new cc.Image();
        eAlign = new cc.Image.ETextAlign();
        eAlign = (cc.TEXT_ALIGNMENT_CENTER == alignment) ? cc.Image.ALIGN_CENTER : (cc.TEXT_ALIGNMENT_LEFT == alignment) ? cc.Image.ALIGN_LEFT : cc.Image.ALIGN_RIGHT;

        if (!image.initWithString(text, dimensions.width, dimensions.height, eAlign, fontName, fontSize)) {
            return false;
        }
        return this.initWithImage(image);
    },

    /** Initializes a texture from a PVR file */
    initWithPVRFile:function (file) {
        var ret = false;
        // nothing to do with cc.Object.init

        var pvr = new cc.TexturePVR;
        ret = pvr.initWithContentsOfFile(file);

        if (ret) {
            pvr.setRetainName(true); // don't dealloc texture on release

            this._name = pvr.getName();
            this._maxS = 1.0;
            this._maxT = 1.0;
            this._pixelsWide = pvr.getWidth();
            this._pixelsHigh = pvr.getHeight();
            this._contentSize = cc.SizeMake(this._pixelsWide, this._pixelsHigh);
            this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
            this._pixelFormat = pvr.getFormat();

            this.setAntiAliasTexParameters();
        }
        else {
            cc.Log("cocos2d: Couldn't load PVR image %s", file);
        }

        return ret;
    },

    /** sets the min filter, mag filter, wrap s and wrap t texture parameters.
     If the texture size is NPOT (non power of 2), then in can only use cc.GL_CLAMP_TO_EDGE in cc.GL_TEXTURE_WRAP_{S,T}.
     @since v0.8
     */
    setTexParameters:function (texParams) {
        cc.Assert((this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh)) ||
            (texParams.wrapS == cc.GL_CLAMP_TO_EDGE && texParams.wrapT == cc.GL_CLAMP_TO_EDGE),
            "cc.GL_CLAMP_TO_EDGE should be used in NPOT textures");
        //TODO
        // BindTexture( cc.GL_TEXTURE_2D, this.this._name );
        //TODO
        // glTexParameteri(cc.GL_TEXTURE_2D, cc.GL_TEXTURE_MIN_FILTER, texParams.minFilter );
        //TODO
        // glTexParameteri(cc.GL_TEXTURE_2D, cc.GL_TEXTURE_MAG_FILTER, texParams.magFilter );
        //TODO
        // glTexParameteri( cc.GL_TEXTURE_2D, cc.GL_TEXTURE_WRAP_S, texParams.wrapS );
        //TODO
        // glTexParameteri( cc.GL_TEXTURE_2D, cc.GL_TEXTURE_WRAP_T, texParams.wrapT );
    },

    /** sets antialias texture parameters:
     - cc.GL_TEXTURE_MIN_FILTER = cc.GL_LINEAR
     - cc.GL_TEXTURE_MAG_FILTER = cc.GL_LINEAR

     @since v0.8
     */
    setAntiAliasTexParameters:function () {
        var texParams = [ cc.GL_LINEAR, cc.GL_LINEAR, cc.GL_CLAMP_TO_EDGE, cc.GL_CLAMP_TO_EDGE ];
        this.setTexParameters(texParams);
    },

    /** sets alias texture parameters:
     - cc.GL_TEXTURE_MIN_FILTER = cc.GL_NEAREST
     - cc.GL_TEXTURE_MAG_FILTER = cc.GL_NEAREST

     @since v0.8
     */
    setAliasTexParameters:function () {
        var texParams = [ cc.GL_NEAREST, cc.GL_NEAREST, cc.GL_CLAMP_TO_EDGE, cc.GL_CLAMP_TO_EDGE ];
        this.setTexParameters(texParams);
    },


    /** Generates mipmap images for the texture.
     It only works if the texture size is POT (power of 2).
     @since v0.99.0
     */
    generateMipmap:function () {
        cc.Assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
        //TODO
        // glBindTexture( cc.GL_TEXTURE_2D, this.this._name );
        //cc.glGenerateMipmap(cc.GL_TEXTURE_2D);
    },

    /** returns the bits-per-pixel of the in-memory OpenGL texture
     @since v1.0
     */
    bitsPerPixelForFormat:function () {
        var ret = 0;

        switch (this._pixelFormat) {
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888:
                ret = 32;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565:
                ret = 16;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_A8:
                ret = 8;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444:
                ret = 16;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1:
                ret = 16;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_PVRTC4:
                ret = 4;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_PVRTC2:
                ret = 2;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_I8:
                ret = 8;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_AI88:
                ret = 16;
                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888:
                ret = 24;
                break;
            default:
                ret = -1;
                cc.Assert(false, "illegal pixel format");
                cc.Log("bitsPerPixelForFormat: %d, cannot give useful result", this._pixelFormat);
                break;
        }
        return ret;
    },


    /*private:*/
    _initPremultipliedATextureWithImage:function (image, POTWide, POTHigh) {
        var data = null;
        var tempData = null;
        var inPixel32 = null;
        var outPixel16 = null;
        var hasAlpha;
        var imageSize = new cc.Size();
        var pixelFormat = new cc.Texture2DPixelFormat();
        var bpp = new cc.size_t();
        hasAlpha = image.hasAlpha();
        bpp = image.getBitsPerComponent();

        // compute pixel format
        if (hasAlpha) {
            pixelFormat = cc.g_defaultAlphaPixelFormat;
        }
        else {
            if (bpp >= 8) {
                pixelFormat = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888;
            }
            else {
                cc.Log("cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha");
                pixelFormat = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565;
            }
        }


        imageSize = cc.SizeMake(image.getWidth(), image.getHeight());

        switch (pixelFormat) {
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888:
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444:
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1:
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565:
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_A8:
                tempData = image.getData();
                cc.Assert(tempData != null, "null image data.");

                if (image.getWidth() == POTWide && image.getHeight() == POTHigh) {
                    data = new (POTHigh * POTWide * 4);
                    cc.memcpy(data, tempData, POTHigh * POTWide * 4);
                }
                else {
                    data = new (POTHigh * POTWide * 4);

                    var pPixelData = tempData;
                    var pTargetData = data;

                    var imageHeight = image.getHeight();
                    for (var y = 0; y < imageHeight; ++y) {
                        cc.memcpy(pTargetData + POTWide * 4 * y, pPixelData + (image.getWidth()) * 4 * y, (image.getWidth()) * 4);
                    }
                }

                break;
            case cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888:
                tempData = image.getData();
                cc.Assert(tempData != null, "null image data.");
                if (image.getWidth() == POTWide && image.getHeight() == POTHigh) {
                    data = new (POTHigh * POTWide * 3);
                    cc.memcpy(data, tempData, POTHigh * POTWide * 3);
                }
                else {
                    data = new (POTHigh * POTWide * 3);

                    var pPixelData = tempData;
                    var pTargetData = data;

                    var imageHeight = image.getHeight();
                    for (var y = 0; y < imageHeight; ++y) {
                        cc.memcpy(pTargetData + POTWide * 3 * y, pPixelData + (image.getWidth()) * 3 * y, (image.getWidth()) * 3);
                    }
                }
                break;
            default:
                cc.Assert(0, "Invalid pixel format");
        }

        // Repack the pixel data into the right format

        if (pixelFormat == cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRRGGGGGGBBBBB"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 3) << 11) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 2) << 5) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 3) << 0);   // B
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRGGGGBBBBAAAA"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 4) << 12) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 4) << 8) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 4) << 4) | // B
                        ((((inPixel32 >> 24) & 0xFF) >> 4) << 0); // A
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRRGGGGGBBBBBA"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 3) << 11) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 3) << 6) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 3) << 1) | // B
                        ((((inPixel32 >> 24) & 0xFF) >> 7) << 0); // A
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.CCTEXTURE_2D_PIXEL_FORMAT_A8) {
            // fix me, how to convert to A8
            pixelFormat = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888;

            /*
             * The code can not work, how to convert to A8?
             *
             tempData = new unsigned char[POTHigh * POTWide];
             inPixel32 = (unsigned int*)data;
             outPixel8 = tempData;

             unsigned int length = POTWide * POTHigh;
             for(unsigned int i = 0; i < length; ++i, ++inPixel32)
             {
             outPixel8++ = (inPixel32 >> 24) & 0xFF;
             }

             delete []data;
             data = tempData;
             */
        }

        if (data) {
            this.initWithData(data, pixelFormat, POTWide, POTHigh, imageSize);

            // should be after calling super init
            this._hasPremultipliedAlpha = image.isPremultipliedAlpha();

            //CGContextRelease(context);
            delete data;
        }
        return true;
    }
});

/** sets the default pixel format for UIImagescontains alpha channel.
 If the UIImage contains alpha channel, then the options are:
 - generate 32-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888 (default one)
 - generate 24-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB888
 - generate 16-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA4444
 - generate 16-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB5A1
 - generate 16-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_RGB565
 - generate 8-bit textures: cc.CCTEXTURE_2D_PIXEL_FORMAT_A8 (only use it if you use just 1 color)

 How does it work ?
 - If the image is an RGBA (with Alpha) then the default pixel format will be used (it can be a 8-bit, 16-bit or 32-bit texture)
 - If the image is an RGB (without Alpha) then an RGB565 or RGB888 texture will be used (16-bit texture)

 @since v0.8
 */
cc.Texture2D.setDefaultAlphaPixelFormat = function (format) {
    cc.g_defaultAlphaPixelFormat = format;
};

/** returns the alpha pixel format
 @since v0.8
 */
cc.Texture2D.defaultAlphaPixelFormat = function () {
    return cc.g_defaultAlphaPixelFormat;
};

/** treats (or not) PVR files as if they have alpha premultiplied.
 Since it is impossible to know at runtime if the PVR images have the alpha channel premultiplied, it is
 possible load them as if they have (or not) the alpha channel premultiplied.

 By default it is disabled.

 @since v0.99.5
 */
cc.Texture2D.PVRImagesHavePremultipliedAlpha = function (haveAlphaPremultiplied) {
    cc.PVRHaveAlphaPremultiplied_ = haveAlphaPremultiplied;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * TextureCache - Alloc, Init & Dealloc
 * @type object
 */
cc.g_sharedTextureCache = null;

/**
 * Load the images to the cache
 * @param {String} imageUrl
 */
cc.loadImage = function (imageUrl) {
    // compute image type
    var imageType = cc.computeImageFormatType(imageUrl);
    if (imageType == cc.FMT_UNKNOWN) {
        cc.Log("unsupported format" + imageUrl);
        return;
    }
    var image = new Image();
    image.src = imageUrl;
    image.onLoad = function (e) {
        cc.TextureCache.sharedTextureCache().cacheImage(imageUrl, image);
    };
};

/**
 *  Support image format type
 * @param {String} filename
 * @return {Number}
 */
cc.computeImageFormatType = function (filename) {
    if (filename.toLowerCase().indexOf('.jpg') > 0 || filename.toLowerCase().indexOf('.jpeg') > 0) {
        return cc.FMT_JPG;
    } else if (filename.indexOf('.png') > 0 || filename.indexOf('.PNG') > 0) {
        return cc.FMT_PNG;
    }
    return cc.FMT_UNKNOWN;
};

/**
 *  Implementation TextureCache
 * @class
 * @extends cc.Class
 */
cc.TextureCache = cc.Class.extend(/** @lends cc.TextureCache# */{
    textures:{},
    _textureColorsCache:{},

    /**
     * Constructor
     */
    ctor:function () {
        cc.Assert(cc.g_sharedTextureCache == null, "Attempted to allocate a second instance of a singleton.");
    },

    /**
     *  Loading the images asynchronously
     * @param {String} path
     * @param {cc.Node} target
     * @param {Function} selector
     * @return {Image}
     * @example
     * //example
     * cc.TextureCache.sharedTextureCache().addImageAsync("hello.png", this, this.loadingCallBack);
     */
    addImageAsync:function (path, target, selector) {
        cc.Assert(path != null, "TextureCache: path MUST not be null");
        var texture = this.textures[path.toString()];

        if (texture) {
            this._addImageAsyncCallBack(target, selector);
        }
        else {
            texture = new Image();
            var that = this;
            texture.addEventListener("load", function () {
                that._addImageAsyncCallBack(target, selector);
            });
            texture.src = path;
            this.textures[path.toString()] = texture;
        }

        if (cc.renderContextType == cc.CANVAS) {
            return this.textures[path.toString()];
        } else {
            //todo texure for gl
        }
    },
    _addImageAsyncCallBack:function (target, selector) {
        if (target && (typeof(selector) == "string")) {
            target[selector]();
        } else if (target && (typeof(selector) == "function")) {
            selector.call(target);
        }
    },

    /**
     * AddPVRTCImage does not support
     */
    addPVRTCImage:function () {
        cc.Assert(0, "TextureCache:addPVRTCImage does not support");
    },

    /**
     * Description
     * @return {String}
     */
    description:function () {
        return "<TextureCache | Number of textures = " + this.textures.length + ">";
    },

    /**
     * <p>Returns a Texture2D object given an file image <br />
     * If the file image was not previously loaded, it will create a new Texture2D <br />
     *  object and it will return it. It will use the filename as a key.<br />
     * Otherwise it will return a reference of a previously loaded image. <br />
     * Supported image extensions: .png, .jpg, .gif</p>
     * @param {String} path
     * @return {Image}
     * @example
     * //example
     * cc.TextureCache.sharedTextureCache().addImage("hello.png");
     */
    addImage:function (path) {
        cc.Assert(path != null, "TextureCache: path MUST not be null");
        var texture = this.textures[path.toString()];
        if (texture) {
            cc.Loader.shareLoader().onResLoaded();
        }
        else {
            texture = new Image();
            var that = this;
            texture.addEventListener("load", function () {

                cc.Loader.shareLoader().onResLoaded();
            });
            texture.addEventListener("error", function () {
                cc.Loader.shareLoader().onResLoadingErr(path);
            });
            texture.src = path;
            this.textures[path.toString()] = texture;
        }

        if (cc.renderContextType == cc.CANVAS) {
            return this.textures[path.toString()];
        } else {
            //todo texture for gl
        }
    },

    /**
     *  Cache the image data
     * @param {String} path
     * @param {Image} texture
     */
    cacheImage:function (path, texture) {
        if (!this.textures[path.toString()]) {
            this.textures[path.toString()] = texture;
        }
    },

    /**
     * <p>Returns a Texture2D object given an UIImage image<br />
     * If the image was not previously loaded, it will create a new Texture2D object and it will return it.<br />
     * Otherwise it will return a reference of a previously loaded image<br />
     * The "key" parameter will be used as the "key" for the cache.<br />
     * If "key" is null, then a new texture will be created each time.</p>
     * @param {Image} image
     * @param {String} key
     * @return {cc.Texture2D}
     */
    addUIImage:function (image, key) {
        cc.Assert(image != null, "TextureCache: image MUST not be nulll");

        var texture = null;

        if (key) {
            if (this.textures.hasOwnProperty(key)) {
                texture = this.textures[key];
                if (texture) {
                    return texture;
                }
            }
        }

        // prevents overloading the autorelease pool
        texture = new cc.Texture2D();
        texture.initWithImage(image);

        if ((key != null) && (texture != null)) {
            this.textures[key] = texture;
        } else {
            cc.Log("cocos2d: Couldn't add UIImage in TextureCache");
        }

        return texture;
    },

    /**
     * Returns an already created texture. Returns null if the texture doesn't exist.
     * @param {String} key
     * @return {Image|Null}
     * @example
     * //example
     * var key = cc.TextureCache.sharedTextureCache().textureForKey("hello.png");
     */
    textureForKey:function (key) {
        if (this.textures.hasOwnProperty(key)) {
            return this.textures[key];
        } else {
            return null;
        }
    },

    /**
     * @param {Image} texture
     * @return {String|Null}
     * @example
     * //example
     * var key = cc.TextureCache.sharedTextureCache().getKeyByTexture(texture);
     */
    getKeyByTexture:function (texture) {
        for (var key in this.textures) {
            if (this.textures[key] == texture) {
                return key;
            }
        }
        return null;
    },

    /**
     * @param {Image} texture
     * @return {Array}
     * @example
     * //example
     * var cacheTextureForColor = cc.TextureCache.sharedTextureCache().getTextureColors(texture);
     */
    getTextureColors:function (texture) {
        var key = this.getKeyByTexture(texture);
        if (key) {
            if (texture instanceof HTMLImageElement) {
                key = texture.src;
            } else {
                return null;
            }
        }

        if (!this._textureColorsCache.hasOwnProperty(key)) {
            this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture);
        }
        return this._textureColorsCache[key];
    },

    /**
     * <p>Purges the dictionary of loaded textures. <br />
     * Call this method if you receive the "Memory Warning"  <br />
     * In the short term: it will free some resources preventing your app from being killed  <br />
     * In the medium term: it will allocate more resources <br />
     * In the long term: it will be the same</p>
     * @example
     * //example
     * cc.TextureCache.sharedTextureCache().removeAllTextures();
     */
    removeAllTextures:function () {
        this.textures = {};
    },

    /**
     * Deletes a texture from the cache given a texture
     * @param {Image} texture
     * @example
     * //example
     * cc.TextureCache.sharedTextureCache().removeTexture(texture);
     */
    removeTexture:function (texture) {
        if (!texture)
            return;

        for (var key in this.textures) {
            if (this.textures[key] == texture) {
                delete(this.textures[key]);
                return;
            }
        }
    },

    /**
     * Deletes a texture from the cache given a its key name
     * @param {String} textureKeyName
     * @example
     * //example
     * cc.TextureCache.sharedTextureCache().removeTexture("hello.png");
     */
    removeTextureForKey:function (textureKeyName) {
        if (textureKeyName == null) {
            return;
        }
        if (this.textures[textureKeyName]) {
            delete(this.textures[textureKeyName]);
        }
    },

    /**
     * <p>Output to cc.Log the current contents of this TextureCache <br />
     * This will attempt to calculate the size of each texture, and the total texture memory in use. </p>
     */
    dumpCachedTextureInfo:function () {
        var count = 0;
        var totalBytes = 0;
        for (var key in this.textures) {
            var tex = this.textures[key];
            var bpp = tex.bitsPerPixelForFormat();
            // Each texture takes up width * height * bytesPerPixel bytes.
            var bytes = tex.getPixelsWide() * tex.getPixelsHigh() * bpp / 8;
            totalBytes += bytes;
            count++;
            cc.Log("cocos2d: '" + tex.toString() + "' id=" + tex.getName() + " " + tex.getPixelsWide() + " x " + tex.getPixelsHigh() + " @ " + bpp + " bpp => " + bytes / 1024 + " KB");
        }

        cc.Log("cocos2d: TextureCache dumpDebugInfo: " + count + " textures, for " + (totalBytes / 1024) + " KB (" + (totalBytes / (1024.0 * 1024.0)).toFixed(2) + " MB)");
    },

    /**
     * <p>Returns a Texture2D object given an PVR filename<br />
     * If the file image was not previously loaded, it will create a new Texture2D<br />
     *  object and it will return it. Otherwise it will return a reference of a previously loaded image </p>
     * @param {String} path
     * @return {cc.Texture2D}
     */
    addPVRImage:function (path) {
        cc.Assert(path != null, "TextureCache: file image MUST not be null");

        var key = path;

        if (this.textures[key] != null) {
            return this.textures[key];
        }

        // Split up directory and filename
        var tex = new cc.Texture2D();
        if (tex.initWithPVRFile(key)) {
            this.textures[key] = tex;
        } else {
            cc.Log("cocos2d: Couldn't add PVRImage:" + key + " in TextureCache");
        }

        return tex;
    }
});

/**
 * Return ths shared instance of the cache
 * @return {cc.TextureCache}
 */
cc.TextureCache.sharedTextureCache = function () {
    if (!cc.g_sharedTextureCache)
        cc.g_sharedTextureCache = new cc.TextureCache();
    return cc.g_sharedTextureCache;
};

/**
 * Purges the cache. It releases the retained instance.
 */
cc.TextureCache.purgeSharedTextureCache = function () {
    cc.g_sharedTextureCache = null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * <p>A class that implements a Texture Atlas. <br />
 * Supported features: <br />
 * The atlas file can be a PNG, JPG. <br />
 * Quads can be updated in runtime <br />
 * Quads can be added in runtime <br />
 * Quads can be removed in runtime <br />
 * Quads can be re-ordered in runtime <br />
 * The TextureAtlas capacity can be increased or decreased in runtime.</p>
 * @class
 * @extends cc.Class
 */
cc.TextureAtlas = cc.Class.extend(/** @lends cc.TextureAtlas# */{
    _indices:[],
    //0: vertex  1: indices
    _buffersVBO:[0, 1],
    //indicates whether or not the array buffer of the VBO needs to be updated
    _dirty:false,
    _capacity:0,
    _texture:null,
    _quads:[],
    /**
     * Quantity of quads that are going to be drawn.
     * @return {Number}
     */
    getTotalQuads:function () {
        return this._quads.length;
    },

    /**
     * Quantity of quads that can be stored with the current texture atlas size
     * @return {Number}
     */
    getCapacity:function () {
        return this._capacity;
    },

    /**
     * Texture of the texture atlas
     * @return {Image}
     */
    getTexture:function () {
        return this._texture;
    },

    /**
     * @param {Image} texture
     */
    setTexture:function (texture) {
        this._texture = texture;
    },

    /**
     * Quads that are going to be rendered
     * @return {Array}
     */
    getQuads:function () {
        return this._quads;
    },

    /**
     * @param {Array} quads
     */
    setQuads:function (quads) {
        this._quads = quads;
    },

    /**
     * Description
     * @return {String}
     */
    description:function () {
        return '<CCTextureAtlas | totalQuads =' + this._totalQuads + '>';
    },
    _initIndices:function () {
        if (this._capacity == 0)
            return;

        for (var i = 0; i < this._capacity; i++) {
            this._indices[i * 6 + 0] = i * 4 + 0;
            this._indices[i * 6 + 1] = i * 4 + 0;
            this._indices[i * 6 + 2] = i * 4 + 2;
            this._indices[i * 6 + 3] = i * 4 + 1;
            this._indices[i * 6 + 4] = i * 4 + 3;
            this._indices[i * 6 + 5] = i * 4 + 3;
        }
    },

    /**
     * <p>Initializes a TextureAtlas with a filename and with a certain capacity for Quads.<br />
     * The TextureAtlas capacity can be increased in runtime.<br />
     * WARNING: Do not reinitialize the TextureAtlas because it will leak memory. </p>
     * @param {String} file
     * @param {Number} capacity
     * @return {Boolean|Null}
     * @example
     * //example
     * var textureAtlas = new cc.TextureAtlas();
     * textureAtlas.initWithTexture("hello.png", 3);
     */
    initWithFile:function (file, capacity) {
        // retained in property
        var texture = cc.TextureCache.sharedTextureCache().addImage(file);

        if (texture) {
            return this.initWithTexture(texture, capacity);
        } else {
            cc.Log("cocos2d: Could not open file: " + file);
            return null;
        }
    },

    /**
     * <p>Initializes a TextureAtlas with a previously initialized Texture2D object, and<br />
     * with an initial capacity for Quads.<br />
     * The TextureAtlas capacity can be increased in runtime.<br />
     * WARNING: Do not reinitialize the TextureAtlas because it will leak memory</p>
     * @param {Image} texture
     * @param {Number} capacity
     * @return {Boolean}
     * @example
     * //example
     * var texture = cc.TextureCache.sharedTextureCache().addImage("hello.png");
     * var textureAtlas = new cc.TextureAtlas();
     * textureAtlas.initWithTexture(texture, 3);
     */
    initWithTexture:function (texture, capacity) {
        cc.Assert(texture != null, "TextureAtlas.initWithTexture():texture should not be null");
        this._capacity = capacity;

        // retained in property
        this._texture = texture;

        // Re-initialization is not allowed
        cc.Assert(this._quads.length == 0 && this._indices.length == 0, "TextureAtlas.initWithTexture():_quads and _indices should not be null");

        //TODO init array
        this._quads = [];
        this._indices = [];

        if (!( this._quads && this._indices) && this._capacity > 0) {
            return false;
        }

        this._dirty = true;
        this._initIndices();
        return true;
    },

    /**
     * <p>Updates a Quad (texture, vertex and color) at a certain index <br />
     * index must be between 0 and the atlas capacity - 1 </p>
     * @param {cc.V2F_C4B_T2F_Quad} quad
     * @param {Number} index
     */
    updateQuad:function (quad, index) {
        this._quads[index] = quad;
        this._dirty = true;
    },

    /**
     * <p>Inserts a Quad (texture, vertex and color) at a certain index<br />
     * index must be between 0 and the atlas capacity - 1 </p>
     * @param {cc.V2F_C4B_T2F_Quad} quad
     * @param {Number} index
     */
    insertQuad:function (quad, index) {
        this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, index);
        this._dirty = true;
    },

    /**
     * <p>Removes the quad that is located at a certain index and inserts it at a new index <br />
     * This operation is faster than removing and inserting in a quad in 2 different steps</p>
     * @param {Number} fromIndex
     * @param {Number} newIndex
     */
    insertQuadFromIndex:function (fromIndex, newIndex) {
        if (fromIndex == newIndex)
            return;

        var quad = this._quads[fromIndex];
        cc.ArrayRemoveObjectAtIndex(this._quads, fromIndex);
        if (fromIndex > newIndex) {
            this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, newIndex);
        } else {
            this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, newIndex - 1);
        }

        this._dirty = true;
    },

    /**
     * <p>Removes a quad at a given index number.<br />
     * The capacity remains the same, but the total number of quads to be drawn is reduced in 1 </p>
     * @param {Number} index
     */
    removeQuadAtIndex:function (index) {
        cc.ArrayRemoveObjectAtIndex(this._quads, index);

        this._dirty = true;
    },

    /**
     * <p>Removes all Quads. <br />
     * The TextureAtlas capacity remains untouched. No memory is freed.<br />
     * The total number of quads to be drawn will be 0</p>
     */
    removeAllQuads:function () {
        this._quads.length = 0;
    },

    /**
     * <p>Resize the capacity of the CCTextureAtlas.<br />
     * The new capacity can be lower or higher than the current one<br />
     * It returns YES if the resize was successful. <br />
     * If it fails to resize the capacity it will return NO with a new capacity of 0. <br />
     * no used for js</p>
     * @param {Number} newCapacity
     * @return {Boolean}
     */
    resizeCapacity:function (newCapacity) {
        if (newCapacity == this._capacity) {
            return true;
        }

        this._totalQuads = Math.min(this._totalQuads, newCapacity);
        this._capacity = newCapacity;

        return true;
    },

    /**
     * <p>Draws n quads from an index (offset). <br />
     * n + start can't be greater than the capacity of the atlas</p>
     * @param {Number} n
     * @param {Number} start
     */
    drawNumberOfQuads:function (n, start) {
        if (0 == n)
            return;
    },
    /**
     * Draws all the Atlas's Quads
     */
    drawQuads:function () {
        this.drawNumberOfQuads(this._quads.length, 0);
    }
});

/**
 * <p>Creates a TextureAtlas with an filename and with an initial capacity for Quads. <br />
 * The TextureAtlas capacity can be increased in runtime. </p>
 * @param {String} file
 * @param {Number} capacity
 * @return {cc.TextureAtlas|Null}
 * @example
 * //example
 * var textureAtlas = cc.TextureAtlas.create("hello.png", 3);
 */
cc.TextureAtlas.create = function (file, capacity) {
    var textureAtlas = new cc.TextureAtlas();
    if (textureAtlas && textureAtlas.initWithFile(file, capacity)) {
        return textureAtlas;
    }
    return null;
};

/**
 * <p>Creates a TextureAtlas with a previously initialized Texture2D object, and with an initial capacity for n Quads.
 * The TextureAtlas capacity can be increased in runtime.</p>
 * @param {Image} texture
 * @param {Number} capacity
 * @return {cc.TextureAtlas}
 * @example
 * //example
 * var texture = cc.TextureCache.sharedTextureCache().addImage("hello.png");
 * var textureAtlas = cc.TextureAtlas.createWithTexture(texture, 3);
 */
cc.TextureAtlas.createWithTexture = function (texture, capacity) {
    var textureAtlas = new cc.TextureAtlas();
    if (textureAtlas && textureAtlas.initWithTexture(texture, capacity)) {
        return textureAtlas;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2009      Jason Booth
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * enum for jpg
 * @constant
 * @type Number
 */
cc.CCIMAGE_FORMAT_JPG = 0;
/**
 * enum for png
 * @constant
 * @type Number
 */
cc.CCIMAGE_FORMAT_PNG = 1;
/**
 * enum for raw
 * @constant
 * @type Number
 */
cc.CCIMAGE_FORMAT_RAWDATA = 2;

/**
 * @param {Number} x
 * @return {Number}
 * Constructor
 */
cc.NextPOT = function (x) {
    x = x - 1;
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    return x + 1;
};

/**
 * cc.RenderTexture is a generic rendering target. To render things into it,<br/>
 * simply construct a render target, call begin on it, call visit on any cocos<br/>
 * scenes or objects to render them, and call end. For convienience, render texture<br/>
 * adds a sprite as it's display child with the results, so you can simply add<br/>
 * the render texture to your scene and treat it like any other CocosNode.<br/>
 * There are also functions for saving the render texture to disk in PNG or JPG format.
 * @class
 * @extends cc.Node
 */
cc.RenderTexture = cc.Node.extend(/** @lends cc.RenderTexture# */{
    /**
     * the offscreen canvas for rendering and storing the texture
     * @type HTMLCanvasElement
     */
    canvas:null,
    /**
     * stores a reference to the canvas context object
     * @type CanvasContext
     */
    context:null,
    _fBO:0,
    _oldFBO:0,
    _texture:null,
    _uITextureImage:null,
    _pixelFormat:cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888,
    _sprite:null,

    /**
     * Constructor
     */
    ctor:function () {
        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');
        this.setAnchorPoint(new cc.Point(0, 0));
    },

    /**
     * The sprite
     * @return {cc.Sprite}
     */
    getSprite:function () {
        return this._sprite;
    },

    /**
     * @param {cc.Sprite} sprite
     */
    setSprite:function (sprite) {
        this._sprite = sprite;
    },

    /**
     * @return {HTMLCanvasElement}
     */
    getCanvas:function () {
        return this.canvas;
    },

    /**
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        if (!size) {
            return;
        }

        //if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
        this._super(size);
        this.canvas.width = size.width * 1.5;
        this.canvas.height = size.height * 1.5;

        this.context.translate(0, this.canvas.height);
        //}
    },

    /**
     * @param {Number} width
     * @param {Number} height
     * @param {cc.CCIMAGE_FORMAT_JPG|cc.CCIMAGE_FORMAT_PNG|cc.CCIMAGE_FORMAT_RAWDATA} format
     * @return {Boolean}
     */
    initWithWidthAndHeight:function (width, height, format) {
        if (cc.renderContextType == cc.CANVAS) {
            this.canvas.width = width || 10;
            this.canvas.height = height || 10;

            this.context.translate(0, this.canvas.height);
            return true;
        }
        //TODO
        // If the gles version is lower than GLES_VER_1_0,
        // some extended gles functions can't be implemented, so return false directly.
        if (cc.Configuration.sharedConfiguration().getGlesVersion() <= GLES_VER_1_0) {
            return false;
        }

        var ret = false;
        do
        {
            width *= cc.CONTENT_SCALE_FACTOR();
            height *= cc.CONTENT_SCALE_FACTOR();

            glGetIntegerv(cc.GL_FRAMEBUFFER_BINDING, this._oldFBO);

            // textures must be power of two squared
            var powW = cc.NextPOT(width);
            var powH = cc.NextPOT(height);

            //void *data = malloc(powW * powH * 4);
            var data = [];
            cc.BREAK_IF(!data);

            //memset(data, 0, (int)(powW * powH * 4));
            for (var i = 0; i < powW * powH * 4; i++) {
                data[i] = 0;
            }

            this._pixelFormat = format;

            this._texture = new cc.Texture2D();
            cc.BREAK_IF(!this._texture);

            this._texture.initWithData(data, this._pixelFormat, powW, powH, cc.SizeMake(width, height));
            //free( data );

            // generate FBO
            ccglGenFramebuffers(1, this._fBO);
            ccglBindFramebuffer(cc.GL_FRAMEBUFFER, this._fBO);

            // associate texture with FBO
            ccglFramebufferTexture2D(cc.GL_FRAMEBUFFER, cc.GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture.getName(), 0);

            // check if it worked (probably worth doing :) )
            var status = ccglCheckFramebufferStatus(cc.GL_FRAMEBUFFER);
            if (status != cc.GL_FRAMEBUFFER_COMPLETE) {
                cc.Assert(0, "Render Texture : Could not attach texture to framebuffer");
                break;
            }

            this._texture.setAliasTexParameters();

            this._sprite = cc.Sprite.createWithTexture(this._texture);

            this._sprite.setScaleY(-1);
            this.addChild(this._sprite);

            var tBlendFunc = new cc.BlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
            this._sprite.setBlendFunc(tBlendFunc);

            ccglBindFramebuffer(cc.GL_FRAMEBUFFER, this._oldFBO);
            ret = true;
        } while (0);
        return ret;
    },

    /**
     * starts grabbing
     */
    begin:function () {
        //TODO
        // Save the current matrix
        glPushMatrix();

        var texSize = this._texture.getContentSizeInPixels();

        // Calculate the adjustment ratios based on the old and new projections
        var size = cc.Director.sharedDirector().getDisplaySizeInPixels();
        var widthRatio = size.width / texSize.width;
        var heightRatio = size.height / texSize.height;

        // Adjust the orthographic propjection and viewport
        ccglOrtho(-1.0 / widthRatio, 1.0 / widthRatio, -1.0 / heightRatio, 1.0 / heightRatio, -1, 1);
        glViewport(0, 0, texSize.width, texSize.height);
//     CCDirector::sharedDirector()->getOpenGLView()->setViewPortInPoints(0, 0, texSize.width, texSize.height);

        glGetIntegerv(cc.GL_FRAMEBUFFER_BINDING, this._oldFBO);
        ccglBindFramebuffer(cc.GL_FRAMEBUFFER, this._fBO);//Will direct drawing to the frame buffer created above

        // Issue #1145
        // There is no need to enable the default GL states here
        // but since CCRenderTexture is mostly used outside the "render" loop
        // these states needs to be enabled.
        // Since this bug was discovered in API-freeze (very close of 1.0 release)
        // This bug won't be fixed to prevent incompatibilities with code.
        //
        // If you understand the above mentioned message, then you can comment the following line
        // and enable the gl states manually, in case you need them.

        cc.ENABLE_DEFAULT_GL_STATES();
    },

    /**
     * starts rendering to the texture while clearing the texture first.<br/>
     * This is more efficient then calling -clear first and then -begin
     * @param {Number} r red 0-255
     * @param {Number} g green 0-255
     * @param {Number} b blue 0-255
     * @param {Number} a alpha 0-255 0 is transparent
     */
    beginWithClear:function (r, g, b, a) {
        //TODO
        this.begin();

        // save clear color
        var clearColor = [0, 0, 0, 0];
        glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);

        glClearColor(r, g, b, a);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // restore clear color
        glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    },

    /**
     * ends grabbing
     * @param {Boolean} isTOCacheTexture the parameter is only used for android to cache the texture
     */
    end:function (isTOCacheTexture) {
        ccglBindFramebuffer(cc.GL_FRAMEBUFFER, this._oldFBO);
        // Restore the original matrix and viewport
        glPopMatrix();
        var size = cc.Director.sharedDirector().getDisplaySizeInPixels();
        //	glViewport(0, 0, (GLsizei)size.width, (GLsizei)size.height);
        cc.Director.sharedDirector().getOpenGLView().setViewPortInPoints(0, 0, size.width, size.height);

        if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
            if (isTOCacheTexture) {
                // to get the rendered texture data
                var s = this._texture.getContentSizeInPixels();
                var tx = s.width;
                var ty = s.height;
                this._uITextureImage = new cc.Image();
                if (true == this.getUIImageFromBuffer(this._uITextureImage, 0, 0, tx, ty)) {
                    cc.VolatileTexture.addDataTexture(this._texture, this._uITextureImage.getData(), cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, s);
                } else {
                    cc.Log("Cache rendertexture failed!");
                }
            }
        }
    },

    /**
     * clears the texture with a color
     * @param {Number} r red 0-255
     * @param {Number} g green 0-255
     * @param {Number} b blue 0-255
     * @param {Number} a alpha 0-255
     */
    clear:function (r, g, b, a) {
        if (cc.renderContextType == cc.CANVAS) {
            var rect = r;
            if (rect) {
                this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            } else {
                this.context.clearRect(0, 0, this.canvas.width, -this.canvas.height);
            }
        } else {
            this.beginWithClear(r, g, b, a);
            this.end();
        }
    },

    /**
     * saves the texture into a file<br/>
     * when width = 0 and height = 0, the image size to save equals to buffer texture size
     * @param {cc.CCIMAGE_FORMAT_JPG|cc.CCIMAGE_FORMAT_PNG|cc.CCIMAGE_FORMAT_RAWDATA} format
     * @param {String} filePath the absolute path to save
     * @param {Number} x the lower left corner coordinates of the buffer to save
     * @param {Number} y the lower left corner coordinates of the buffer to save
     * @param {Number} width
     * @param {Number} height
     * @return {Boolean}
     */
    saveBuffer:function (format, filePath, x, y, width, height) {
        if (typeof(format) == "number") {
            x = x || 0;
            y = y || 0;
            width = width || 0;
            height = height || 0;

            var ret = false;
            cc.Assert(format == cc.CCIMAGE_FORMAT_JPG || format == cc.CCIMAGE_FORMAT_PNG,
                "the image can only be saved as JPG or PNG format");

            var image = new cc.Image();
            if (image != null && this.getUIImageFromBuffer(image, x, y, width, height)) {
                var fullpath = cc.FileUtils.getWriteablePath() + filePath;

                ret = image.saveToFile(fullpath);
            }

            return ret;
        } else if (typeof(format) == "string") {
            height = width || 0;
            width = y || 0;
            y = x || 0;
            x = filePath || 0;

            filePath = format;

            var ret = false;

            var image = new cc.Image();
            if (image != null && this.getUIImageFromBuffer(image, x, y, width, height)) {
                ret = image.saveToFile(filePath);
            }
            return ret;
        }
    },

    /* get buffer as UIImage, can only save a render buffer which has a RGBA8888 pixel format */
    getUIImageAsDataFromBuffer:function (format) {
        var pData = null;
        //@ todo CCRenderTexture::getUIImageAsDataFromBuffer

        // #include "Availability.h"
        // #include "UIKit.h"

        //     GLubyte * pBuffer   = NULL;
        //     GLubyte * pPixels   = NULL;
        //     do
        //     {
        //         CC_BREAK_IF(! texture);
        //
        //         CCAssert(pixelFormat == CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888, "only RGBA8888 can be saved as image");
        //
        //         const CCSize& s = texture->getContentSizeInPixels();
        //         int tx = s.width;
        //         int ty = s.height;
        //
        //         int bitsPerComponent = 8;
        //         int bitsPerPixel = 32;
        //
        //         int bytesPerRow = (bitsPerPixel / 8) * tx;
        //         int myDataLength = bytesPerRow * ty;
        //
        //         CC_BREAK_IF(! (pBuffer = new GLubyte[tx * ty * 4]));
        //         CC_BREAK_IF(! (pPixels = new GLubyte[tx * ty * 4]));
        //
        //         this->begin();
        //         glReadPixels(0,0,tx,ty,GL_RGBA,GL_UNSIGNED_BYTE, pBuffer);
        //         this->end();
        //
        //         int x,y;
        //
        //         for(y = 0; y <ty; y++) {
        //             for(x = 0; x <tx * 4; x++) {
        //                 pPixels[((ty - 1 - y) * tx * 4 + x)] = pBuffer[(y * 4 * tx + x)];
        //             }
        //         }
        //
        //         if (format == CCIMAGE_FORMAT_RAWDATA)
        //         {
        //             pData = CCData::dataWithBytesNoCopy(pPixels, myDataLength);
        //             break;
        //         }

        //@ todo impliment save to jpg or png
        /*
         CGImageCreate(size_t width, size_t height,
         size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow,
         CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider,
         const CGFloat decode[], bool shouldInterpolate,
         CGColorRenderingIntent intent)
         */
        // make data provider with data.
        //         CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast | kCGBitmapByteOrderDefault;
        //         CGDataProviderRef provider		= CGDataProviderCreateWithData(NULL, pixels, myDataLength, NULL);
        //         CGColorSpaceRef colorSpaceRef	= CGColorSpaceCreateDeviceRGB();
        //         CGImageRef iref					= CGImageCreate(tx, ty,
        //             bitsPerComponent, bitsPerPixel, bytesPerRow,
        //             colorSpaceRef, bitmapInfo, provider,
        //             NULL, false,
        //             kCGRenderingIntentDefault);
        //
        //         UIImage* image					= [[UIImage alloc] initWithCGImage:iref];
        //
        //         CGImageRelease(iref);
        //         CGColorSpaceRelease(colorSpaceRef);
        //         CGDataProviderRelease(provider);
        //
        //
        //
        //         if (format == CCIMAGE_FORMAT_PNG)
        //             data = UIImagePNGRepresentation(image);
        //         else
        //             data = UIImageJPEGRepresentation(image, 1.0f);
        //
        //         [image release];
        //     } while (0);
        //
        //     CC_SAFE_DELETE_ARRAY(pBuffer);
        //     CC_SAFE_DELETE_ARRAY(pPixels);
        return pData;
    },

    /**
     * read the buffer data<br/>
     * when width = 0 and height = 0, the image size to save equals to buffer texture size
     * @param {Image} image the CCImage to save
     * @param {Number} x the lower left corner coordinates of the buffer to save
     * @param {Number} y the lower left corner coordinates of the buffer to save
     * @param {Number} width
     * @param {Number} height
     * @return {Boolean}
     */
    getUIImageFromBuffer:function (image, x, y, width, height) {
        //TODO
        if (null == image || null == this._texture) {
            return false;
        }

        var s = this._texture.getContentSizeInPixels();
        var tx = s.width;
        var ty = s.height;

        if (x < 0 || x >= tx || y < 0 || y >= ty) {
            return false;
        }

        if (width < 0
            || height < 0
            || (0 == width && 0 != height)
            || (0 == height && 0 != width)) {
            return false;
        }

        // to get the image size to save
        //		if the saving image domain exeeds the buffer texture domain,
        //		it should be cut
        var savedBufferWidth = width;
        var savedBufferHeight = height;
        if (0 == width) {
            savedBufferWidth = tx;
        }
        if (0 == height) {
            savedBufferHeight = ty;
        }
        savedBufferWidth = x + savedBufferWidth > tx ? (tx - x) : savedBufferWidth;
        savedBufferHeight = y + savedBufferHeight > ty ? (ty - y) : savedBufferHeight;

        var buffer = null;
        var tempData = null;
        var ret = false;

        do {
            cc.Assert(this._pixelFormat == cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888, "only RGBA8888 can be saved as image");

            buffer = [];
            for (var i = 0; i < savedBufferWidth * savedBufferHeight * 4; i++) {
                buffer[i] = 0;
            }
            cc.BREAK_IF(!buffer);

            // On some machines, like Samsung i9000, Motorola Defy,
            // the dimension need to be a power of 2
            var readBufferWidth = 0;
            var readBufferHeight = 0;
            var maxTextureSize = 0;
            glGetIntegerv(GL_MAX_TEXTURE_SIZE, maxTextureSize);

            readBufferWidth = cc.NextPOT(tx);
            readBufferHeight = cc.NextPOT(ty);

            cc.BREAK_IF(0 == readBufferWidth || 0 == readBufferHeight);
            cc.BREAK_IF(readBufferWidth > maxTextureSize || readBufferHeight > maxTextureSize);

            for (i = 0; i < readBufferWidth * readBufferHeight * 4; i++) {
                tempData[i] = 0;
            }
            cc.BREAK_IF(!tempData);

            this.begin();
            glPixelStorei(GL_PACK_ALIGNMENT, 1);
            glReadPixels(0, 0, readBufferWidth, readBufferHeight, GL_RGBA, GL_UNSIGNED_BYTE, tempData);
            this.end(false);

            // to get the actual texture data
            // #640 the image read from rendertexture is upseted
            for (i = 0; i < savedBufferHeight; ++i) {
                this._memcpy(buffer, i * savedBufferWidth * 4,
                    tempData, (y + savedBufferHeight - i - 1) * readBufferWidth * 4 + x * 4,
                    savedBufferWidth * 4);
            }

            ret = image.initWithImageData(buffer, savedBufferWidth * savedBufferHeight * 4, cc.FMT_RAWDATA, savedBufferWidth, savedBufferHeight, 8);
        } while (0);

        return ret;
    },
    _memcpy:function (destArr, destIndex, srcArr, srcIndex, size) {
        for (var i = 0; i < size; i++) {
            destArr[destIndex + i] = srcArr[srcIndex + i];
        }
    }
});

/**
 * creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid
 * @param {Number} width
 * @param {Number} height
 * @param {cc.CCIMAGE_FORMAT_JPG|cc.CCIMAGE_FORMAT_PNG|cc.CCIMAGE_FORMAT_RAWDATA} format
 * @return {cc.RenderTexture}
 * @example
 * // Example
 * var rt = cc.RenderTexture.create()
 */
cc.RenderTexture.create = function (width, height, format) {
    if (!format) {
        format = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888;
    }

    var ret = new cc.RenderTexture();
    if (ret && ret.initWithWidthAndHeight(width, height, format)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2011 cocos2d-x.org
 Copyright (c) 2010      Lam Pham

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * Radial Counter-Clockwise
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_RADIAL_CCW = 0;
/**
 * Radial ClockWise
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW = 1;
/**
 * Horizontal Left-Right
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR = 2;
/**
 * Horizontal Right-Left
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL = 3;
/**
 * Vertical Bottom-top
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT = 4;
/**
 * Vertical Top-Bottom
 * @type Number
 * @constant
 */
cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB = 5;

/**
 * @constant
 * @type Number
 */
cc.PROGRESS_TEXTURE_COORDS_COUNT = 4;

/**
 * @constant
 * @type Number
 */
cc.PROGRESS_TEXTURE_COORDS = 0x1e;


/**
 * cc.Progresstimer is a subclass of cc.Node.<br/>
 * It renders the inner sprite according to the percentage.<br/>
 * The progress can be Radial, Horizontal or vertical.
 * @class
 * @extends cc.Node
 */
cc.ProgressTimer = cc.Node.extend(/** @lends cc.ProgressTimer# */{

    /**
     *  Change the percentage to change progress
     * @return {cc.CCPROGRESS_TIMER_RADIAL_CCW|cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW|cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR|cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL|cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT|cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB}
     */
    getType:function () {
        return this._type;
    },

    /**
     * Percentages are from 0 to 100
     * @return {Number}
     */
    getPercentage:function () {
        return this._percentage;
    },

    /**
     * The image to show the progress percentage, retain
     * @return {cc.Sprite}
     */
    getSprite:function () {
        return this._sprite;
    },

    /**
     * @param {String} fileName
     * @return {Boolean}
     */
    initWithFile:function (fileName) {
        return this.initWithTexture(cc.TextureCache.sharedTextureCache().addImage(fileName));
    },

    /**
     * @param {Image} texture
     * @return {Boolean}
     */
    initWithTexture:function (texture) {
        this._sprite = cc.Sprite.createWithTexture(texture);

        this._percentage = 0.0;
        this._vertexData = null;
        this._vertexDataCount = 0;
        this.setAnchorPoint(cc.ccp(0.5, 0.5));
        this.setContentSize(this._sprite.getContentSize());
        this._type = cc.CCPROGRESS_TIMER_RADIAL_CCW;

        return true;
    },

    /**
     * from 0-100
     * @param {Number} percentage
     */
    setPercentage:function (percentage) {
        if (this._percentage != percentage) {
            this._percentage = cc.clampf(percentage, 0, 100);
            this._updateProgress();
        }
    },

    /**
     * @param {cc.Sprite} sprite
     */
    setSprite:function (sprite) {
        if (this._sprite != sprite) {
            this._sprite = sprite;
            this.setContentSize(this._sprite.getContentSize());

            //	Everytime we set a new sprite, we free the current vertex data
            if (this._vertexData) {
                this._vertexData = null;
                this._vertexDataCount = 0;
            }
        }
    },

    /**
     * @param {cc.CCPROGRESS_TIMER_RADIAL_CCW|cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW|cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR|cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL|cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT|cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB} type
     */
    setType:function (type) {
        if (type != this._type) {
            //	release all previous information
            if (this._vertexData) {
                this._vertexData = null;
                this._vertexDataCount = 0;
            }

            this._type = type;
        }

    },

    /**
     * stuff gets drawn here
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            if (this._type > 1) {
                var pos = new cc.Point(0 | ( -this._anchorPointInPixels.x + this._drawPosition.x),
                    0 | ( -this._anchorPointInPixels.y + this._drawPosition.y));
                context.drawImage(this._sprite._texture, this._origin.x, this._origin.y, this._drawSize.width, this._drawSize.height,
                    pos.x, -(pos.y + this._drawSize.height),
                    this._drawSize.width, this._drawSize.height);
            } else {
                var size = this.getContentSize();
                context.beginPath();
                var startAngle_1 = (Math.PI / 180) * this._startAngle;
                var endAngle_1 = (Math.PI / 180) * this._endAngle;
                var radius = size.width > size.height ? size.width : size.height;
                context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
                context.lineTo(0, 0);
                context.clip();
                context.closePath();

                var offsetPixels = this._sprite._offsetPositionInPixels;
                var pos = new cc.Point(0 | ( -this._sprite._anchorPointInPixels.x + offsetPixels.x),
                    0 | ( -this._sprite._anchorPointInPixels.y + offsetPixels.y));
                context.drawImage(this._sprite._texture,
                    this._sprite._rect.origin.x, this._sprite._rect.origin.y,
                    this._sprite._rect.size.width, this._sprite._rect.size.height,
                    pos.x, -(pos.y + this._sprite._rect.size.height),
                    this._sprite._rect.size.width, this._sprite._rect.size.height);
            }
        } else {
            this._super();

            if (!this._vertexData) {
                return;
            }

            if (!this._sprite) {
                return;
            }

            var bf = this._sprite.getBlendFunc();
            var newBlend = (bf.src != cc.BLEND_SRC || bf.dst != cc.BLEND_DST) ? true : false;
            if (newBlend) {
                //glBlendFunc(bf.src, bf.dst);
            }

            ///	========================================================================
            //	Replaced [texture_ drawAtPoint:CCPointZero] with my own vertexData
            //	Everything above me and below me is copied from CCTextureNode's draw
            //glBindTexture(GL_TEXTURE_2D, sprite->getTexture()->getName());
            //glVertexPointer(2, GL_FLOAT, sizeof(ccV2F_C4B_T2F), &vertexData[0].vertices);
            //glTexCoordPointer(2, GL_FLOAT, sizeof(ccV2F_C4B_T2F), &vertexData[0].texCoords);
            //glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(ccV2F_C4B_T2F), &vertexData[0].colors);

            if (this._type == cc.CCPROGRESS_TIMER_RADIAL_CCW || this._type == cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW) {
                //glDrawArrays(GL_TRIANGLE_FAN, 0, vertexDataCount);
            } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR ||
                this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL ||
                this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT ||
                this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB) {
                //glDrawArrays(GL_TRIANGLE_STRIP, 0, vertexDataCount);
            }
            //glDrawElements(GL_TRIANGLES, indicesCount_, GL_UNSIGNED_BYTE, indices_);
            ///	========================================================================

            if (newBlend) {
                //glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);
            }
        }
    },

    _vertexFromTexCoord:function (texCoord) {
        var tmp;
        var ret = new cc.Vertex2F(0, 0);

        var texture = this._sprite.getTexture();
        if (texture) {
            var fXMax = Math.max(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
            var fXMin = Math.min(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
            var fYMax = Math.max(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
            var fYMin = Math.min(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
            var tMax = cc.ccp(fXMax, fYMax);
            var tMin = cc.ccp(fXMin, fYMin);

            var texSize = cc.SizeMake(this._sprite.getQuad().br.vertices.x - this._sprite.getQuad().bl.vertices.x,
                this._sprite.getQuad().tl.vertices.y - this._sprite.getQuad().bl.vertices.y);
            tmp = cc.ccp(texSize.width * (texCoord.x - tMin.x) / (tMax.x - tMin.x),
                texSize.height * (1 - (texCoord.y - tMin.y) / (tMax.y - tMin.y)));
        } else {
            tmp = cc.PointZero();
        }

        ret.x = tmp.x;
        ret.y = tmp.y;
        return ret;

    },

    _origin:cc.PointZero(),
    _drawSize:cc.SizeZero(),
    _drawPosition:cc.PointZero(),
    _startAngle:270,
    _endAngle:270,
    _updateProgress:function () {
        if (cc.renderContextType == cc.CANVAS) {
            var size = this.getContentSize();
            switch (this._type) {
                case cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW:
                    this._endAngle = 270 + 3.6 * this._percentage;
                    break;
                case cc.CCPROGRESS_TIMER_RADIAL_CCW:
                    this._startAngle = 270 - 3.6 * this._percentage;
                    break;
                case cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR:
                    //left to right
                    this._origin = cc.PointZero();
                    this._drawPosition = cc.PointZero();
                    this._drawSize = cc.SizeMake(0 | ((this._percentage / 100) * size.width), size.height);
                    break;
                case cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL:
                    //right to left
                    this._drawSize = cc.SizeMake(0 | ((this._percentage / 100) * size.width), size.height);
                    this._origin = cc.ccp((size.width - this._drawSize.width) | 0, 0);
                    this._drawPosition = cc.ccp(size.width - this._drawSize.width, 0);
                    break;
                case cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT:
                    //buttom to top
                    this._drawSize = cc.SizeMake(size.width, 0 | ((this._percentage / 100) * size.height));
                    this._drawPosition = cc.PointZero();
                    this._origin = cc.ccp(0, 0 | (size.height - this._drawSize.height));
                    break;
                case cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB:
                    //top to buttom
                    this._drawSize = cc.SizeMake(size.width, 0 | ((this._percentage / 100) * size.height));
                    this._drawPosition = cc.ccp(0, (size.height - this._drawSize.height) | 0);
                    this._origin = cc.ccp(0, 0);
                    break;
            }
        } else {
            switch (this._type) {
                case cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW:
                case cc.CCPROGRESS_TIMER_RADIAL_CCW:
                    this._updateRadial();
                    break;
                case cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR:
                case cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL:
                case cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT:
                case cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB:
                    this._updateBar();
                    break;
                default:
                    break;
            }
        }
    },
    _updateBar:function () {
        var alpha = this._percentage / 100;

        var fXMax = Math.max(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
        var fXMin = Math.min(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
        var fYMax = Math.max(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
        var fYMin = Math.min(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
        var tMax = cc.ccp(fXMax, fYMax);
        var tMin = cc.ccp(fXMin, fYMin);

        var indexes = [];
        var index = 0;

        //	We know vertex data is always equal to the 4 corners
        //	If we don't have vertex data then we create it here and populate
        //	the side of the bar vertices that won't ever change.
        if (!this._vertexData) {
            this._vertexDataCount = cc.PROGRESS_TEXTURE_COORDS_COUNT;
            this._vertexData = [];
            for (var i = 0; i < this._vertexDataCount; i++) {
                this._vertexData[i] = cc.V2F_C4B_T2F_QuadZero();
            }
            cc.Assert(this._vertexData, "");

            if (this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR) {
                this._vertexData[indexes[0] = 0].texCoords = cc.tex2(tMin.x, tMin.y);
                this._vertexData[indexes[1] = 1].texCoords = cc.tex2(tMin.x, tMax.y);
            } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL) {
                this._vertexData[indexes[0] = 2].texCoords = cc.tex2(tMax.x, tMax.y);
                this._vertexData[indexes[1] = 3].texCoords = cc.tex2(tMax.x, tMin.y);
            } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT) {
                this._vertexData[indexes[0] = 1].texCoords = cc.tex2(tMin.x, tMax.y);
                this._vertexData[indexes[1] = 3].texCoords = cc.tex2(tMax.x, tMax.y);
            } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB) {
                this._vertexData[indexes[0] = 0].texCoords = cc.tex2(tMin.x, tMin.y);
                this._vertexData[indexes[1] = 2].texCoords = cc.tex2(tMax.x, tMin.y);
            }

            index = indexes[0];
            this._vertexData[index].vertices = this._vertexFromTexCoord(cc.ccp(this._vertexData[index].texCoords.u,
                this._vertexData[index].texCoords.v));

            index = indexes[1];
            this._vertexData[index].vertices = this._vertexFromTexCoord(cc.ccp(this._vertexData[index].texCoords.u,
                this._vertexData[index].texCoords.v));

            if (this._sprite.isFlipY() || this._sprite.isFlipX()) {
                if (this._sprite.isFlipX()) {
                    index = indexes[0];
                    this._vertexData[index].texCoords.u = tMin.x + tMax.x - this._vertexData[index].texCoords.u;
                    index = indexes[1];
                    this._vertexData[index].texCoords.u = tMin.x + tMax.x - this._vertexData[index].texCoords.u;
                }

                if (this._sprite.isFlipY()) {
                    index = indexes[0];
                    this._vertexData[index].texCoords.v = tMin.y + tMax.y - this._vertexData[index].texCoords.v;
                    index = indexes[1];
                    this._vertexData[index].texCoords.v = tMin.y + tMax.y - this._vertexData[index].texCoords.v;
                }
            }

            this._updateColor();
        }

        if (this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_LR) {
            this._vertexData[indexes[0] = 3].texCoords = cc.tex2(tMin.x + (tMax.x - tMin.x) * alpha, tMax.y);
            this._vertexData[indexes[1] = 2].texCoords = cc.tex2(tMin.x + (tMax.x - tMin.x) * alpha, tMin.y);
        } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_HORIZONTATAL_BAR_RL) {
            this._vertexData[indexes[0] = 1].texCoords = cc.tex2(tMin.x + (tMax.x - tMin.x) * (1.0 - alpha), tMin.y);
            this._vertexData[indexes[1] = 0].texCoords = cc.tex2(tMin.x + (tMax.x - tMin.x) * (1.0 - alpha), tMax.y);
        } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_BT) {
            this._vertexData[indexes[0] = 0].texCoords = cc.tex2(tMin.x, tMin.y + (tMax.y - tMin.y) * (1.0 - alpha));
            this._vertexData[indexes[1] = 2].texCoords = cc.tex2(tMax.x, tMin.y + (tMax.y - tMin.y) * (1.0 - alpha));
        } else if (this._type == cc.CCPROGRESS_TIMER_TYPE_VERTICAL_BAR_TB) {
            this._vertexData[indexes[0] = 1].texCoords = cc.tex2(tMin.x, tMin.y + (tMax.y - tMin.y) * alpha);
            this._vertexData[indexes[1] = 3].texCoords = cc.tex2(tMax.x, tMin.y + (tMax.y - tMin.y) * alpha);
        }

        index = indexes[0];
        this._vertexData[index].vertices = this._vertexFromTexCoord(cc.ccp(this._vertexData[index].texCoords.u,
            this._vertexData[index].texCoords.v));
        index = indexes[1];
        this._vertexData[index].vertices = this._vertexFromTexCoord(cc.ccp(this._vertexData[index].texCoords.u,
            this._vertexData[index].texCoords.v));

        if (this._sprite.isFlipY() || this._sprite.isFlipX()) {
            if (this._sprite.isFlipX()) {
                index = indexes[0];
                this._vertexData[index].texCoords.u = tMin.x + tMax.x - this._vertexData[index].texCoords.u;
                index = indexes[1];
                this._vertexData[index].texCoords.u = tMin.x + tMax.x - this._vertexData[index].texCoords.u;
            }

            if (this._sprite.isFlipY()) {
                index = indexes[0];
                this._vertexData[index].texCoords.v = tMin.y + tMax.y - this._vertexData[index].texCoords.v;
                index = indexes[1];
                this._vertexData[index].texCoords.v = tMin.y + tMax.y - this._vertexData[index].texCoords.v;
            }
        }

    },
    _updateRadial:function () {
        //	Texture Max is the actual max coordinates to deal with non-power of 2 textures
        var xMax = Math.max(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
        var xMin = Math.min(this._sprite.getQuad().br.texCoords.u, this._sprite.getQuad().bl.texCoords.u);
        var yMax = Math.max(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
        var yMin = Math.min(this._sprite.getQuad().tl.texCoords.v, this._sprite.getQuad().bl.texCoords.v);
        var max = cc.ccp(xMax, yMax);
        var min = cc.ccp(xMin, yMin);

        //	Grab the midpoint
        var midpoint = cc.ccpAdd(min, cc.ccpCompMult(this._anchorPoint, cc.ccpSub(max, min)));  //??? anchorPoint

        var alpha = this._percentage / 100;

        //	Otherwise we can get the angle from the alpha
        var angle = 2.0 * (Math.PI) * (this._type == cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW ? alpha : 1.0 - alpha);

        //	We find the vector to do a hit detection based on the percentage
        //	We know the first vector is the one @ 12 o'clock (top,mid) so we rotate
        //	from that by the progress angle around the midpoint pivot
        var topMid = cc.ccp(midpoint.x, min.y);
        var percentagePt = cc.ccpRotateByAngle(topMid, midpoint, angle);

        var index = 0;
        var hit = cc.PointZero();

        if (alpha == 0.0) {
            //	More efficient since we don't always need to check intersection
            //	If the alpha is zero then the hit point is top mid and the index is 0.
            hit = topMid;
            index = 0;
        } else if (alpha == 1.0) {
            //	More efficient since we don't always need to check intersection
            //	If the alpha is one then the hit point is top mid and the index is 4.
            hit = topMid;
            index = 4;
        } else {
            //	We run a for loop checking the edges of the texture to find the
            //	intersection point
            //	We loop through five points since the top is split in half

            var min_t = Infinity;

            for (var i = 0; i <= cc.PROGRESS_TEXTURE_COORDS_COUNT; ++i) {
                var pIndex = (i + (cc.PROGRESS_TEXTURE_COORDS_COUNT - 1)) % cc.PROGRESS_TEXTURE_COORDS_COUNT;

                var edgePtA = cc.ccpAdd(min, cc.ccpCompMult(this._boundaryTexCoord(i % cc.PROGRESS_TEXTURE_COORDS_COUNT), cc.ccpSub(max, min)));
                var edgePtB = cc.ccpAdd(min, cc.ccpCompMult(this._boundaryTexCoord(pIndex), cc.ccpSub(max, min)));

                //	Remember that the top edge is split in half for the 12 o'clock position
                //	Let's deal with that here by finding the correct endpoints
                if (i == 0) {
                    edgePtB = cc.ccpLerp(edgePtA, edgePtB, 0.5);
                } else if (i == 4) {
                    edgePtA = cc.ccpLerp(edgePtA, edgePtB, 0.5);
                }

                //	s and t are returned by ccpLineIntersect
                var reP = cc.PointZero();

                if (cc.ccpLineIntersect(edgePtA, edgePtB, midpoint, percentagePt, reP)) {
                    //	Since our hit test is on rays we have to deal with the top edge
                    //	being in split in half so we have to test as a segment
                    if (i == 0 || i == 4) {
                        //	s represents the point between edgePtA--edgePtB
                        if (!(0.0 <= reP.x && reP.x <= 1.0)) {
                            continue;
                        }
                    }

                    //	As long as our t isn't negative we are at least finding a
                    //	correct hitpoint from midpoint to percentagePt.
                    if (reP.y >= 0.0) {
                        //	Because the percentage line and all the texture edges are
                        //	rays we should only account for the shortest intersection
                        if (reP.y < min_t) {
                            min_t = reP.y;
                            index = i;
                        }
                    }
                }

            }

            //	Now that we have the minimum magnitude we can use that to find our intersection
            hit = cc.ccpAdd(midpoint, cc.ccpMult(cc.ccpSub(percentagePt, midpoint), min_t));
        }

        //	The size of the vertex data is the index from the hitpoint
        //	the 3 is for the midpoint, 12 o'clock point and hitpoint position.

        var sameIndexCount = true;
        if (this._vertexDataCount != index + 3) {
            sameIndexCount = false;
            if (this._vertexData) {
                this._vertexData = null;
                this._vertexDataCount = 0;
            }
        }

        if (!this._vertexData) {
            this._vertexDataCount = index + 3;
            this._vertexData = [];
            for (var i = 0; i < this._vertexDataCount; i++) {
                this._vertexData[i] = cc.V2F_C4B_T2F_QuadZero();
            }
            cc.Assert(this._vertexData, "");

            this._updateColor();
        }

        if (!sameIndexCount) {
            //	First we populate the array with the midpoint, then all
            //	vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint
            this._vertexData[0].texCoords = cc.tex2(midpoint.x, midpoint.y);
            this._vertexData[0].vertices = this._vertexFromTexCoord(midpoint);

            this._vertexData[1].texCoords = cc.tex2(midpoint.x, min.y);
            this._vertexData[1].vertices = this._vertexFromTexCoord(cc.ccp(midpoint.x, min.y));

            for (var i = 0; i < index; ++i) {
                var texCoords = cc.ccpAdd(min, cc.ccpCompMult(this._boundaryTexCoord(i), cc.ccpSub(max, min)));

                this._vertexData[i + 2].texCoords = cc.tex2(texCoords.x, texCoords.y);
                this._vertexData[i + 2].vertices = this._vertexFromTexCoord(texCoords);
            }

            //	Flip the texture coordinates if set
            if (this._sprite.isFlipX() || this._sprite.isFlipY()) {
                for (var i = 0; i < this._vertexDataCount - 1; ++i) {
                    if (this._sprite.isFlipX()) {
                        this._vertexData[i].texCoords.u = min.x + max.x - this._vertexData[i].texCoords.u;
                    }

                    if (this._sprite.isFlipY()) {
                        this._vertexData[i].texCoords.v = min.y + max.y - this._vertexData[i].texCoords.v;
                    }
                }
            }
        }

        //	hitpoint will go last
        this._vertexData[this._vertexDataCount - 1].texCoords = cc.tex2(hit.x, hit.y);
        this._vertexData[this._vertexDataCount - 1].vertices = this._vertexFromTexCoord(hit);

        if (this._sprite.isFlipX() || this._sprite.isFlipY()) {
            if (this._sprite.isFlipX()) {
                this._vertexData[this._vertexDataCount - 1].texCoords.u = min.x + max.x - this._vertexData[this._vertexDataCount - 1].texCoords.u;
            }

            if (this._sprite.isFlipY()) {
                this._vertexData[this._vertexDataCount - 1].texCoords.v = min.y + max.y - this._vertexData[this._vertexDataCount - 1].texCoords.v;
            }
        }

    },
    _updateColor:function () {
        var op = this._sprite.getOpacity();
        var c3b = this._sprite.getColor();

        var color = new cc.Color4B(c3b.r, c3b.g, c3b.b, op);
        if ((this._sprite.getTexture() instanceof HTMLImageElement) || (this._sprite.getTexture() instanceof HTMLCanvasElement)) {
            color.r *= op / 255;
            color.g *= op / 255;
            color.b *= op / 255;
        } else {
            if (this._sprite.getTexture().getHasPremultipliedAlpha()) {
                color.r *= op / 255;
                color.g *= op / 255;
                color.b *= op / 255;
            }
        }

        if (this._vertexData) {
            for (var i = 0; i < this._vertexDataCount; ++i) {
                this._vertexData[i].colors = color;
            }
        }

    },
    _boundaryTexCoord:function (index) {
        if (index < cc.PROGRESS_TEXTURE_COORDS_COUNT) {
            switch (this._type) {
                case cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW:
                    return cc.ccp(((cc.PROGRESS_TEXTURE_COORDS >> ((index << 1) + 1)) & 1), ((cc.PROGRESS_TEXTURE_COORDS >> (index << 1)) & 1));
                case cc.CCPROGRESS_TIMER_RADIAL_CCW:
                    return cc.ccp(((cc.PROGRESS_TEXTURE_COORDS >> (7 - (index << 1))) & 1), ((cc.PROGRESS_TEXTURE_COORDS >> (7 - ((index << 1) + 1))) & 1));
                default:
                    break;
            }
        }
        return cc.PointZero();
    },
    _type:null,
    _percentage:0.0,
    _sprite:null,
    _vertexDataCount:0,
    _vertexData:null
});

/**
 * create a progress timer object with image file name that renders the inner sprite according to the percentage
 * @param {String} fileName
 * @return {cc.ProgressTimer}
 * @example
 * // Example
 * var progress = cc.ProgressTimer.create('progress.png')
 */
cc.ProgressTimer.create = function (fileName) {
    var progressTimer = new cc.ProgressTimer();
    if (progressTimer.initWithFile(fileName)) {
        return progressTimer;
    } else {
        return null;
    }
};

/**
 * create a progress timer object with texture that renders the inner sprite according to the percentage
 * @param {Image} texture
 * @return {cc.ProgressTimer}
 * @example
 * // Example
 * var progress = cc.ProgressTimer.create(progressTexture)
 *
 * //OR
 * var progress = cc.ProgressTimer.create(cc.TextureCache.sharedTextureCache().addImage('progress.png'))
 */
cc.ProgressTimer.createWithTexture = function (texture) {
    var progressTimer = new cc.ProgressTimer();
    if (progressTimer.initWithTexture(texture)) {
        return progressTimer;
    } else {
        return null;
    }
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** Base class for other
 */
cc.GridBase = cc.Class.extend({
    _active:null,
    _reuseGrid:null,
    _gridSize:null,
    _texture:null,
    _step:new cc.Point(),
    _grabber:null,
    _isTextureFlipped:null,
    /** wheter or not the grid is active */
    isActive:function () {
        return this._active;
    },
    setActive:function (active) {
        this._active = active;
        if (!active) {
            var director = cc.Director.sharedDirector();
            var proj = director.getProjection();
            director.setProjection(proj);
        }
    },

    /** number of times that the grid will be reused */
    getReuseGrid:function () {
        return this._reuseGrid;
    },
    setReuseGrid:function (reuseGrid) {
        this._reuseGrid = reuseGrid;
    },

    /** size of the grid */
    getGridSize:function () {
        return this._gridSize;
    },
    setGridSize:function (gridSize) {
        this._gridSize.x = parseInt(gridSize.x);
        this._gridSize.y = parseInt(gridSize.y);
    },

    /** pixels between the grids */
    getStep:function () {
        return this._step;
    },
    setStep:function (step) {
        this._step = step;
    },

    /** is texture flipped */
    isTextureFlipped:function () {
        return this._isTextureFlipped;
    },
    setIsTextureFlipped:function (flipped) {
        if (this._isTextureFlipped != flipped) {
            this._isTextureFlipped = flipped;
            this.calculateVertexPoints();
        }
    },

    initWithSize:function (gridSize, texture, flipped) {
        var argnum = arguments.length;
        if (argnum = 1) {
            var director = cc.Director.sharedDirector();
            var s = director.getWinSizeInPixels();

            var POTWide = cc.NextPOT(s.width);
            var POTHigh = cc.NextPOT(s.height);

            // we only use rgba8888
            var format = cc.CCTEXTURE_2D_PIXEL_FORMAT_RGBA8888;

            var pTextureTemp = new cc.Texture2D();
            pTextureTemp.initWithData(format, POTWide, POTHigh, s);
            if (!pTextureTemp) {
                cc.Log("cocos2d: CCGrid: error creating texture");
                return false;
            }
            texture = pTextureTemp;

            flipped = false;
        }


        var ret = true;

        this._active = false;
        this._reuseGrid = 0;
        this._gridSize = gridSize;
        this._texture = texture;
        this._isTextureFlipped = flipped;

        var texSize = this._texture.getContentSizeInPixels();
        this._step.x = texSize.width / this._gridSize.x;
        this._step.y = texSize.height / this._gridSize.y;

        this._grabber = new cc.Grabber();
        if (this._grabber) {
            this._grabber.grab(this._texture);
        }
        else {
            ret = false;
        }


        this.calculateVertexPoints();

        return ret;

    },

    beforeDraw:function () {
        this.set2DProjection();
        this._grabber.beforeRender(this._texture);
    },
    afterDraw:function (target) {
        this._grabber.afterRender(this._texture);

        this.set3DProjection();
        this._applyLandscape();

        if (target.getCamera().getDirty()) {
            var offset = target.getAnchorPointInPixels();

            //
            // XXX: Camera should be applied in the AnchorPoint
            //
            //todo gl
            //ccglTranslate(offset.x, offset.y, 0);
            target.getCamera().locate();
            //ccglTranslate(-offset.x, -offset.y, 0);
        }
//todo gl
        //glBindTexture(GL_TEXTURE_2D, this._texture.getName());

        // restore projection for default FBO .fixed bug #543 #544
        cc.Director.sharedDirector().setProjection(cc.Director.sharedDirector().getProjection());
        cc.Director.sharedDirector().applyOrientation();
        this.blit();
    },
    blit:function () {
        cc.Assert(0, "");
    },
    reuse:function () {
        cc.Assert(0, "");
    },
    calculateVertexPoints:function () {
        cc.Assert(0, "");
    },
    set2DProjection:function () {
        var winSize = cc.Director.sharedDirector().getWinSizeInPixels();
//todo gl
        /* glLoadIdentity();

         // set view port for user FBO, fixed bug #543 #544
         glViewport(0, 0, winSize.width, winSize.height);
         glMatrixMode(GL_PROJECTION);
         glLoadIdentity();
         ccglOrtho(0, winSize.width, 0, winSize.height, -1024, 1024);
         glMatrixMode(GL_MODELVIEW);*/
    },
    set3DProjection:function () {
        var winSize = cc.Director.sharedDirector().getDisplaySizeInPixels();
//todo gl
        /* // set view port for user FBO, fixed bug #543 #544
         glViewport(0, 0, winSize.width, winSize.height);
         glMatrixMode(GL_PROJECTION);
         glLoadIdentity();
         gluPerspective(60, winSize.width/winSize.height, 0.5, 1500.0);

         glMatrixMode(GL_MODELVIEW);
         glLoadIdentity();
         gluLookAt( winSize.width/2, winSize.height/2, cc.Director.sharedDirector().getZEye(),
         winSize.width/2, winSize.height/2, 0,
         0.0, 1.0, 0.0
         );*/
    },
    _applyLandscape:function () {
        var director = cc.Director.sharedDirector();

        var winSize = director.getDisplaySizeInPixels();
        var w = winSize.width / 2;
        var h = winSize.height / 2;

        var orientation = director.getDeviceOrientation();

        switch (orientation) {
            //todo gl
            case cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT:
                /*glTranslatef(w,h,0);
                 glRotatef(-90,0,0,1);
                 glTranslatef(-h,-w,0);*/
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT:
                /*glTranslatef(w,h,0);
                 glRotatef(90,0,0,1);
                 glTranslatef(-h,-w,0);*/
                break;
            case cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN:
                /*glTranslatef(w,h,0);
                 glRotatef(180,0,0,1);
                 glTranslatef(-w,-h,0);*/
                break;
            default:
                break;
        }
    }
});
cc.GridBase.create = function () {
    var pGridBase = new cc.GridBase();
    return pGridBase;
};

/**
 cc.Grid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z
 */
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates:null,
    _vertices:null,
    _originalVertices:null,
    _indices:null,
    /** returns the vertex at a given position */
    vertex:function (pos) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._vertices;

        var vert = new cc.Vertex3F(vertArray[index], vertArray[index + 1], vertArray[index + 2]);

        return vert;
    },
    /** returns the original (non-transformed) vertex at a given position */
    originalVertex:function (pos) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._originalVertices;

        var vert = new cc.Vertex3F(vertArray[index], vertArray[index + 1], vertArray[index + 2]);

        return vert;
    },
    /** sets a new vertex at a given position */
    setVertex:function (pos, vertex) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._vertices;
        vertArray[index] = vertex.x;
        vertArray[index + 1] = vertex.y;
        vertArray[index + 2] = vertex.z;
    },

    blit:function () {
        var n = this._gridSize.x * this._gridSize.y;

        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Unneeded states: GL_COLOR_ARRAY
        //todo gl
        /*glDisableClientState(GL_COLOR_ARRAY);

         glVertexPointer(3, GL_FLOAT, 0, this._vertices);
         glTexCoordPointer(2, GL_FLOAT, 0, this._texCoordinates);
         glDrawElements(GL_TRIANGLES, n*6, GL_UNSIGNED_SHORT, this._indices);

         // restore default GL state
         glEnableClientState(GL_COLOR_ARRAY);*/
    },
    reuse:function () {
        if (this._reuseGrid > 0) {
            --this._reuseGrid;
        }
    },
    calculateVertexPoints:function () {
        var width = this._texture.getPixelsWide();
        var height = this._texture.getPixelsHigh();
        var imageH = this._texture.getContentSizeInPixels().height;

        var numQuads = this._gridSize.x * this._gridSize.y;

        this._vertices = [];
        this._originalVertices = [];
        this._texCoordinates = [];
        this._indices = [];

        var vertArray = this._vertices;
        var texArray = this._texCoordinates;
        var idxArray = this._indices;

        var x, y;

        for (x = 0; x < this._gridSize.x; x++) {
            for (y = 0; y < this._gridSize.y; y++) {
                var x1 = x * this._step.x;
                var x2 = x1 + this._step.x;
                var y1 = y * this._step.y;
                var y2 = y1 + this._step.y;

                vertArray[x * y] = x1;
                vertArray[x * y + 1] = y1;
                vertArray[x * y + 2] = 0;
                vertArray[x * y + 3] = x2;
                vertArray[x * y + 4] = y1;
                vertArray[x * y + 5] = 0;
                vertArray[x * y + 6] = x1;
                vertArray[x * y + 7] = y2;
                vertArray[x * y + 8] = 0;
                vertArray[x * y + 9] = x2;
                vertArray[x * y + 10] = y2;
                vertArray[x * y + 11] = 0;

                var newY1 = y1;
                var newY2 = y2;

                if (this._isTextureFlipped) {
                    newY1 = imageH - y1;
                    newY2 = imageH - y2;
                }

                texArray[x * y + 12] = x1 / width;
                texArray[x * y + 13] = newY1 / height;
                texArray[x * y + 14] = x2 / width;
                texArray[x * y + 15] = newY1 / height;
                texArray[x * y + 16] = x1 / width;
                texArray[x * y + 17] = newY2 / height;
                texArray[x * y + 18] = x2 / width;
                texArray[x * y + 19] = newY2 / height;
            }
        }

        for (x = 0; x < numQuads; x++) {
            idxArray[x * 6 + 0] = x * 4 + 0;
            idxArray[x * 6 + 1] = x * 4 + 1;
            idxArray[x * 6 + 2] = x * 4 + 2;

            idxArray[x * 6 + 3] = x * 4 + 1;
            idxArray[x * 6 + 4] = x * 4 + 2;
            idxArray[x * 6 + 5] = x * 4 + 3;
        }

    }
});

cc.Grid3D.create = function (gridSize, texture, flipped) {

};

/**
 cc.TiledGrid3D is a 3D grid implementation. It differs from Grid3D in that
 the tiles can be separated from the grid.
 */
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates:null,
    _vertices:null,
    _originalVertices:null,
    _indices:null,
    /** returns the tile at the given position */
    tile:function (pos) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._vertices;
        var ret = new cc.Quad3();
        return ret;
    },
    /** returns the original tile (untransformed) at the given position */
    originalTile:function (pos) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._originalVertices;

        var ret = new cc.Quad3(vertArray[idx], vertArray[idx + 1], vertArray[idx + 2], vertArray[idx + 3]);

        return ret;
    },
    /** sets a new tile */
    setTile:function (pos, coords) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._vertices;
        vertArray[idx] = coords;
    },

    blit:function () {
        var n = this._gridSize.x * this._gridSize.y;

        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Unneeded states: GL_COLOR_ARRAY
        //todo gl
        /*glDisableClientState(GL_COLOR_ARRAY);

         glVertexPointer(3, GL_FLOAT, 0, this._vertices);
         glTexCoordPointer(2, GL_FLOAT, 0, this._texCoordinates);
         glDrawElements(GL_TRIANGLES, (GLsizei)n*6, GL_UNSIGNED_SHORT, this._indices);

         // restore default GL state
         glEnableClientState(GL_COLOR_ARRAY);*/
    },
    reuse:function () {
        if (this._reuseGrid > 0) {
            var numQuads = this._gridSize.x * this._gridSize.y;
            for (var i = 0, len = numQuads.length * 12; i < len; i++) {
                this._originalVertices.push(this._vertices[i])
            }
            //todo fix
            //memcpy(this._originalVertices, this._vertices, numQuads * 12 * sizeof(GLfloat));
            --this._reuseGrid;
        }
    },
    calculateVertexPoints:function () {
        var width = this._texture.getPixelsWide();
        var height = this._texture.getPixelsHigh();
        var imageH = this._texture.getContentSizeInPixels().height;

        var numQuads = this._gridSize.x * this._gridSize.y;

        this._vertices = [];
        this._originalVertices = [];
        this._texCoordinates = [];
        this._indices = [];

        var vertArray = this._vertices;
        var texArray = this._texCoordinates;
        var idxArray = this._indices;

        var x, y;

        for (x = 0; x < this._gridSize.x; x++) {
            for (y = 0; y < this._gridSize.y; y++) {
                var x1 = x * this._step.x;
                var x2 = x1 + this._step.x;
                var y1 = y * this._step.y;
                var y2 = y1 + this._step.y;

                vertArray[x * y] = x1;
                vertArray[x * y + 1] = y1;
                vertArray[x * y + 2] = 0;
                vertArray[x * y + 3] = x2;
                vertArray[x * y + 4] = y1;
                vertArray[x * y + 5] = 0;
                vertArray[x * y + 6] = x1;
                vertArray[x * y + 7] = y2;
                vertArray[x * y + 8] = 0;
                vertArray[x * y + 9] = x2;
                vertArray[x * y + 10] = y2;
                vertArray[x * y + 11] = 0;
                var newY1 = y1;
                var newY2 = y2;

                if (this._isTextureFlipped) {
                    newY1 = imageH - y1;
                    newY2 = imageH - y2;
                }

                texArray[x * y + 12] = x1 / width;
                texArray[x * y + 13] = newY1 / height;
                texArray[x * y + 14] = x2 / width;
                texArray[x * y + 15] = newY1 / height;
                texArray[x * y + 16] = x1 / width;
                texArray[x * y + 17] = newY2 / height;
                texArray[x * y + 18] = x2 / width;
                texArray[x * y + 19] = newY2 / height;
            }
        }

        for (x = 0; x < numQuads; x++) {
            idxArray[x * 6 + 0] = x * 4 + 0;
            idxArray[x * 6 + 1] = x * 4 + 1;
            idxArray[x * 6 + 2] = x * 4 + 2;

            idxArray[x * 6 + 3] = x * 4 + 1;
            idxArray[x * 6 + 4] = x * 4 + 2;
            idxArray[x * 6 + 5] = x * 4 + 3;
        }
        for (var i = 0, len = numQuads.length * 12; i < len; i++) {
            this._originalVertices.push(this._vertices[i])
        }
        //todo fix
        //memcpy(this._originalVertices, this._vertices, numQuads * 12 * sizeof(GLfloat));
    }
});

cc.TiledGrid3D.create = function (gridSize, texture, flipped) {
    var ret = new cc.TiledGrid3D();
    ret.initWithSize(gridSize, texture, flipped)
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** FBO class that grabs the the contents of the screen */
cc.Grabber = cc.Class.extend({
    _fbo:0,
    _oldFBO:0,
    _glesVersion:null,
    ctor:function () {
        // generate FBO
        //todo gl
        //ccglGenFramebuffers(1, this._fbo);
    },
    grab:function (texture) {
        //todo gl
        /*glGetIntegerv(CC_GL_FRAMEBUFFER_BINDING, this._oldFBO);

         // bind
         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._fbo);

         // associate texture with FBO
         ccglFramebufferTexture2D(CC_GL_FRAMEBUFFER, CC_GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
         texture.getName(), 0);

         // check if it worked (probably worth doing :) )
         var status = ccglCheckFramebufferStatus(CC_GL_FRAMEBUFFER);
         if (status != CC_GL_FRAMEBUFFER_COMPLETE) {
         cc.Log("Frame Grabber: could not attach texture to frmaebuffer");
         }

         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._oldFBO);*/
    },
    beforeRender:function (texture) {
        //todo gl
        /*glGetIntegerv(CC_GL_FRAMEBUFFER_BINDING, this._oldFBO);
         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._fbo);

         // BUG XXX: doesn't work with RGB565.

         */
        /*glClearColor(0, 0, 0, 0);*/
        /*

         // BUG #631: To fix #631, uncomment the lines with #631
         // Warning: But it CCGrabber won't work with 2 effects at the same time
         glClearColor(0.0, 0.0, 0.0, 1.0);	// #631

         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

         glColorMask(true, true, true, false);	// #631*/
    },
    afterRender:function (texture) {
        //todo gl
        /* ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._oldFBO);
         glColorMask(true, true, true, true);	// #631*/
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** Default Action tag
 * @constant
 * @type {Number}
 */

cc.CCACTION_TAG_INVALID = -1;

/**
 * Base class for cc.Action objects.
 * @class
 * @extends cc.Class
 */
cc.Action = cc.Class.extend(/** @lends cc.Action# */{
    //***********variables*************
    _originalTarget:null,

    /** The "target".
     The target will be set with the 'startWithTarget' method.
     When the 'stop' method is called, target will be set to nil.
     The target is 'assigned', it is not 'retained'.
     */
    _target:null,
    _tag:cc.CCACTION_TAG_INVALID,

    //**************Public Functions***********
    /**
     * @return {String}
     */
    description:function () {
        return "<cc.Action | Tag = " + this._tag + ">";
    },

    /**
     * to copy object with deep copy.
     * @param {object} zone
     * @return {object}
     */
    copyWithZone:function (zone) {
        return this.copy();
    },

    /**
     * to copy object with deep copy.
     * @return {object}
     */
    copy:function () {
        return cc.clone(this);
    },

    /**
     * return true if the action has finished
     * @return {Boolean}
     */
    isDone:function () {
        return true;
    },

    /**
     * called before the action start. It will also set the target.
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._originalTarget = target;
        this._target = target;
    },

    /**
     * called after the action has finished. It will set the 'target' to nil.
     * IMPORTANT: You should never call "action stop" manually. Instead, use: "target.stopAction(action);"
     */
    stop:function () {
        this._target = null;
    },
    /** called every frame with it's delta time. DON'T override unless you know what you are doing.
     *
     * @param {Number} dt
     */

    step:function (dt) {
        cc.Log("[Action step]. override me");
    },

    /**
     <p>called once per frame. time a value between 0 and 1  </P>

     <p>For example:  <br/>
     - 0 means that the action just started <br/>
     - 0.5 means that the action is in the middle<br/>
     - 1 means that the action is over </P>
     * @param {Number}  time
     */
    update:function (time) {
        cc.Log("[Action update]. override me");
    },

    /**
     *
     * @return {cc.Node}
     */
    getTarget:function () {
        return this._target;
    },

    /** The action will modify the target properties.
     *
     * @param {cc.Node} target
     */
    setTarget:function (target) {
        this._target = target;
    },

    /**
     *
     * @return {cc.Node}
     */
    getOriginalTarget:function () {
        return this._originalTarget;
    },

    /** Set the original target, since target can be nil. <br/>
     * Is the target that were used to run the action.  <br/>
     * Unless you are doing something complex, like cc.ActionManager, you should NOT call this method. <br/>
     * The target is 'assigned', it is not 'retained'. <br/>
     * @param {cc.Node} originalTarget
     */
    setOriginalTarget:function (originalTarget) {
        this._originalTarget = originalTarget;
    },

    /**
     *
     * @return {Number}
     */
    getTag:function () {
        return this._tag;
    },

    /**
     *
     * @param {Number} tag
     */
    setTag:function (tag) {
        this._tag = tag;
    }
});
/** Allocates and initializes the action
 * @returns {cc.Action}
 * @example
 * // example
 * var action = cc.Action.create();
 */
cc.Action.create = function () {
    var ret = new cc.Action();
    return ret;
};


/**
 * <p>Base class actions that do have a finite time duration.<br/>
 * Possible actions: <br/>
 * - An action with a duration of 0 seconds<br/>
 * - An action with a duration of 35.5 seconds  </p>

 * Infinite time actions are valid
 * @class
 * @extends cc.Action
 */
cc.FiniteTimeAction = cc.Action.extend(/** @lends cc.FiniteTimeAction# */{
    //! duration in seconds
    _duration:0,

    /** get duration in seconds of the action
     *
     * @return {Number}
     */
    getDuration:function () {
        return this._duration;
    },

    /** set duration in seconds of the action
     *
     * @param {Number} duration
     */
    setDuration:function (duration) {
        this._duration = duration;
    },

    /** returns a reversed action
     *
     * @return {Null}
     */
    reverse:function () {
        cc.Log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null;
    }
});


/**
 * Changes the speed of an action, making it take longer (speed>1)
 * or less (speed<1) time. <br/>
 * Useful to simulate 'slow motion' or 'fast forward' effect.
 * @warning This action can't be Sequenceable because it is not an cc.IntervalAction
 * @class
 * @extends cc.Action
 */
cc.Speed = cc.Action.extend(/** @lends cc.Speed# */{
    _speed:0.0,
    _innerAction:null,

    /**
     * @return {Number}
     */
    getSpeed:function () {
        return this._speed;
    },

    /** alter the speed of the inner function in runtime
     * @param {Number} speed
     */
    setSpeed:function (speed) {
        this._speed = speed;
    },

    /** initializes the action
     * @param {cc.ActionInterval} action
     * @param {Number} rate
     * @return {Boolean}
     */
    initWithAction:function (action, rate) {
        cc.Assert(action != null, "");
        this._innerAction = action;
        this._speed = rate;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._innerAction.startWithTarget(target);
    },

    /**
     *  Stop the action
     */
    stop:function () {
        this._innerAction.stop();
        cc.Action.stop();
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        this._innerAction.step(dt * this._speed);
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return this._innerAction.isDone();
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return (cc.Speed.create(this._innerAction.reverse(), this._speed));
    },

    /**
     *
     * @param {cc.ActionInterval} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     *
     * @return {cc.ActionInterval}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/** creates the action
 *
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.Speed}
 */
cc.Speed.create = function (action, rate) {
    var ret = new cc.Speed();
    if (ret && ret.initWithAction(action, rate)) {
        return ret;
    }
    return null;
};

/**
 * cc.Follow is an action that "follows" a node.

 * @example
 * //example
 * //Instead of using cc.Camera as a "follower", use this action instead.
 * layer.runAction(cc.Follow.actionWithTarget(hero));

 * @class
 * @extends cc.Action
 */
cc.Follow = cc.Action.extend(/** @lends cc.Follow# */{
    /**
     * @return {Boolean}
     */
    isBoundarySet:function () {
        return this._boundarySet;
    },

    /** alter behavior - turn on/off boundary
     * @param {Boolean} value
     */
    setBoudarySet:function (value) {
        this._boundarySet = value;
    },

    /** initializes the action
     * initializes the action with a set boundary
     * @param {cc.Node} followedNode
     * @param {cc.Rect} rect
     * @return {Boolean}
     */
    initWithTarget:function (followedNode, rect) {
        cc.Assert(followedNode != null, "");
        this._followedNode = followedNode;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;

        var winSize = cc.Director.sharedDirector().getWinSize();
        this._fullScreenSize = cc.PointMake(winSize.width, winSize.height);
        this._halfScreenSize = cc.ccpMult(this._fullScreenSize, 0.5);

        if (rect) {
            this.leftBoundary = -((rect.origin.x + rect.size.width) - this._fullScreenSize.x);
            this.rightBoundary = -rect.origin.x;
            this.topBoundary = -rect.origin.y;
            this.bottomBoundary = -((rect.origin.y + rect.size.height) - this._fullScreenSize.y);

            if (this.rightBoundary < this.leftBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2;
            }
            if (this.topBoundary < this.bottomBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2;
            }

            if ((this.topBoundary == this.bottomBoundary) && (this.leftBoundary == this.rightBoundary)) {
                this._boundaryFullyCovered = true;
            }
        }
        return true;
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        if (this._boundarySet) {
            // whole map fits inside a single screen, no need to modify the position - unless map boundaries are increased
            if (this._boundaryFullyCovered)
                return;

            var tempPos = cc.ccpSub(this._halfScreenSize, this._followedNode.getPosition());

            this._target.setPosition(cc.ccp(cc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary),
                cc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary)));
        }
        else {
            this._target.setPosition(cc.ccpSub(this._halfScreenSize, this._followedNode.getPosition()));
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return ( !this._followedNode.getIsRunning() );
    },

    /**
     * Stop the action.
     */
    stop:function () {
        this._target = null;
        cc.Action.stop();
    },

    // node to follow
    _followedNode:null,
    // whether camera should be limited to certain area
    _boundarySet:false,
    // if screen size is bigger than the boundary - update not needed
    _boundaryFullyCovered:false,
    // fast access to the screen dimensions
    _halfScreenSize:null,
    _fullScreenSize:null,

    /** world leftBoundary
     * @Type {Number}
     */
    leftBoundary:0.0,
    /** world rightBoundary
     * @Type Number
     */
    rightBoundary:0.0,
    /** world topBoundary
     * @Type Number
     */
    topBoundary:0.0,
    /** world bottomBoundary
     * @Type {Number}
     */
    bottomBoundary:0.0
});
/** creates the action with a set boundary <br/>
 * creates the action with no boundary set
 * @param {cc.Node} followedNode
 * @param {cc.Rect} rect
 * @return {cc.Follow|Null} returns the cc.Follow object on success
 * @example
 * // example
 * // creates the action with a set boundary
 * var sprite = cc.Sprite.create("spriteFileName");
 * var followAction = cc.Follow.create(sprite, cc.RectMake(0, 0, s.width * 2 - 100, s.height));
 * this.runAction(followAction);
 *
 * // creates the action with no boundary set
 * var sprite = cc.Sprite.create("spriteFileName");
 * var followAction = cc.Follow.create(sprite);
 * this.runAction(followAction);
 */
cc.Follow.create = function (followedNode, rect) {
    var ret = new cc.Follow();
    if (rect != null && ret && ret.initWithTarget(followedNode, rect)) {
        return ret;
    }
    else if (ret && ret.initWithTarget(followedNode)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p> An interval action is an action that takes place within a certain period of time. <br/>
 * It has an start time, and a finish time. The finish time is the parameter<br/>
 * duration plus the start time.</p>
 *
 * <p>These CCActionInterval actions have some interesting properties, like:<br/>
 * - They can run normally (default)  <br/>
 * - They can run reversed with the reverse method   <br/>
 * - They can run with the time altered with the Accelerate, AccelDeccel and Speed actions. </p>
 *
 * <p>For example, you can simulate a Ping Pong effect running the action normally and<br/>
 * then running it again in Reverse mode. </p>
 *
 * @class
 * @extends cc.FiniteTimeAction
 * @Example
 * // example
 * var pingPongAction = cc.Sequence.create(action, action.reverse());
 */
cc.ActionInterval = cc.FiniteTimeAction.extend(/** @lends cc.ActionInterval# */{
    _elapsed:0,
    _firstTick:false,

    /** how many seconds had elapsed since the actions started to run.
     * @return {Number}
     */
    getElapsed:function () {
        return this._elapsed;
    },

    /** initializes the action
     * @param {Number} d duration in seconds
     * @return {Boolean}
     */
    initWithDuration:function (d) {
        this._duration = (d == 0) ? cc.FLT_EPSILON : d;
        // prevent division by 0
        // This comparison could be in step:, but it might decrease the performance
        // by 3% in heavy based action games.
        this._elapsed = 0;
        this._firstTick = true;
        return true;
    },

    /** returns true if the action has finished
     * @return {Boolean}
     */
    isDone:function () {
        return (this._elapsed >= this._duration);
    },

    /**
     * @param {Number} dt delta time in seconds
     */
    step:function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
        }
        else {
            this._elapsed += dt;
        }
        this.update((1 > (this._elapsed / this._duration)) ? this._elapsed / this._duration : 1);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._elapsed = 0;
        this._firstTick = true;
    },

    /**
     * @return {Null}
     */
    reverse:function () {
        /*
         NSException* myException = [NSException
         exceptionWithName:@"ReverseActionNotImplemented"
         reason:@"Reverse Action not implemented"
         userInfo:nil];
         @throw myException;
         */
        return null;
    },

    /**
     * @param {Number} amp
     */
    setAmplitudeRate:function (amp) {
        cc.Assert(0, 'Actioninterval setAmplitudeRate');
    },

    /**
     * @return {Number}
     */
    getAmplitudeRate:function () {
        cc.Assert(0, 'Actioninterval getAmplitudeRate');
        return 0;
    }
});

/**
 * @param {Number} d duration in seconds
 * @return {cc.ActionInterval}
 * @example
 * // example
 * var actionInterval = cc.ActionInterval.create(3);
 */
cc.ActionInterval.create = function (d) {
    var action = new cc.ActionInterval();
    action.initWithDuration(d);
    return action;
};


/** Runs actions sequentially, one after another
 * @class
 * @extends cc.ActionInterval
 */
cc.Sequence = cc.ActionInterval.extend(/** @lends cc.Sequence# */{
    _actions:null,
    _split:null,
    _last:0,

    /**
     * Constructor
     */
    ctor:function () {
        this._actions = [];
    },

    /** initializes the action <br/>
     * @param {cc.FiniteTimeAction} actionOne
     * @param {cc.FiniteTimeAction} actionTwo
     * @return {Boolean}
     */
    initOneTwo:function (actionOne, actionTwo) {
        cc.Assert(actionOne != null, "Sequence.initOneTwo");
        cc.Assert(actionTwo != null, "Sequence.initOneTwo");

        var one = actionOne.getDuration();
        var two = actionTwo.getDuration();
        if (isNaN(one) || isNaN(two)) {
            console.log(actionOne);
            console.log(actionTwo);
        }
        var d = actionOne.getDuration() + actionTwo.getDuration();
        this.initWithDuration(d);

        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;

        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._split = this._actions[0].getDuration() / this._duration;
        this._last = -1;
    },

    /**
     * stop the action
     */
    stop:function () {
        this._actions[0].stop();
        this._actions[1].stop();
        this._super();
    },

    /**
     * @param {Number} time  time in seconds
     */
    update:function (time) {
        var found = 0;
        var new_t = 0;
        if (time >= this._split) {
            found = 1;
            new_t = (this._split == 1) ? 1 : (time - this._split) / (1 - this._split);
        }
        else {
            found = 0;
            new_t = (this._split != 0) ? time / this._split : 1;
        }
        if (this._last == -1 && found == 1) {
            this._actions[0].startWithTarget(this._target);
            this._actions[0].update(1);
            this._actions[0].stop();
        }
        if (this._last != found) {
            if (this._last != -1) {
                this._actions[this._last].update(1);
                this._actions[this._last].stop();
            }

            this._actions[found].startWithTarget(this._target);
        }
        this._actions[found].update(new_t);
        this._last = found;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
    }
});
/** helper constructor to create an array of sequenceable actions
 * @param {Array|cc.FiniteTimeAction} tempArray
 * @return {cc.FiniteTimeAction}
 * @example
 * // example
 * // create sequence with actions
 * var seq = cc.Sequence.create(act1, act2);
 *
 * // create sequence with array
 * var seq = cc.Sequence.create(actArray);
 */
cc.Sequence.create = function (/*Multiple Arguments*/tempArray) {
    var paraArray = (typeof tempArray == "Array") ? tempArray : arguments;
    var prev = paraArray[0];
    for (var i = 1; i < paraArray.length; i++) {
        if (paraArray[i] != null) {
            prev = cc.Sequence._actionOneTwo(prev, paraArray[i]);
        }
    }
    return prev;

};

/** creates the action
 * @param {cc.FiniteTimeAction} actionOne
 * @param {cc.FiniteTimeAction} actionTwo
 * @return {cc.Sequence}
 * @private
 */
cc.Sequence._actionOneTwo = function (actionOne, actionTwo) {
    var sequence = new cc.Sequence();
    sequence.initOneTwo(actionOne, actionTwo);
    return sequence;
};


/** Repeats an action a number of times.
 * To repeat an action forever use the CCRepeatForever action.
 * @class
 * @extends cc.ActionInterval
 */
cc.Repeat = cc.ActionInterval.extend(/** @lends cc.Repeat# */{
    _times:0,
    _total:0,
    _innerAction:null, //CCFiniteTimeAction

    /**
     * @param {cc.FiniteTimeAction} action
     * @param {Number} times
     * @return {Boolean}
     */
    initWithAction:function (action, times) {
        var d = action.getDuration() * times;

        if (this.initWithDuration(d)) {
            this._times = times;
            this._innerAction = action;
            this._total = 0;
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._total = 0;
        this._super(target);
        this._innerAction.startWithTarget(target);
    },

    /**
     * stop the action
     */
    stop:function () {
        this._innerAction.stop();
        this._super();
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        var t = time * this._times;
        if (t > this._total + 1) {
            this._innerAction.update(1);
            this._total++;
            this._innerAction.stop();
            this._innerAction.startWithTarget(this._target);

            // repeat is over?
            if (this._total == this._times) {
                // so, set it in the original position
                this._innerAction.update(0);
            }
            else {
                // no ? start next repeat with the right update
                // to prevent jerk (issue #390)
                this._innerAction.update(t - this._total);
            }
        }
        else {
            var r = t % 1;

            // fix last repeat position
            // else it could be 0.
            if (time == 1) {
                r = 1;
                this._total++; // this is the added line
            }

            //		other->update(min(r, 1));
            this._innerAction.update((r > 1) ? 1 : r);
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return this._total == this._times;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Repeat.create(this._innerAction.reverse(), this._times);
    },

    /**
     * @param {cc.FiniteTimeAction} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/** creates a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)
 * @param {cc.FiniteTimeAction} action
 * @param {Number} times
 * @return {cc.Repeat}
 * @example
 * // example
 * var rep = cc.Repeat.create(cc.Sequence.create(jump2, jump1), 5);
 */
cc.Repeat.create = function (action, times) {
    var repeat = new cc.Repeat();
    repeat.initWithAction(action, times);
    return repeat;
};


/**  Repeats an action for ever.  <br/>
 * To repeat the an action for a limited number of times use the Repeat action. <br/>
 * @warning This action can't be Sequenceable because it is not an IntervalAction
 * @class
 * @extends cc.ActionInterval
 */

cc.RepeatForever = cc.ActionInterval.extend(/** @lends cc.RepeatForever# */{
    _innerAction:null, //CCActionInterval

    /**
     * @param {cc.ActionInterval} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");

        this._innerAction = action;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._innerAction.startWithTarget(target);
    },

    /**
     * @param dt delta time in seconds
     */
    step:function (dt) {
        this._innerAction.step(dt);
        if (this._innerAction.isDone()) {
            var diff = dt + this._innerAction.getDuration() - this._innerAction.getElapsed();
            this._innerAction.startWithTarget(this._target);
            // to prevent jerk. issue #390
            this._innerAction.step(diff);
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return false;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return (cc.RepeatForever.create(this._innerAction.reverse()));
    },

    /**
     *
     * @param {cc.ActionInterval} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/**
 * Repeat the acton forever
 * @param action
 * @return {cc.RepeatForever}
 * @example
 * // example
 * var repeat = cc.RepeatForever.create(cc.RotateBy.create(1.0, 360));
 */
cc.RepeatForever.create = function (action) {
    var ret = new cc.RepeatForever();
    if (ret && ret.initWithAction(action)) {
        return ret;
    }
    return null;
};


/** Spawn a new action immediately
 * @class
 * @extends cc.ActionInterval
 */
cc.Spawn = cc.ActionInterval.extend(/** @lends cc.Spawn# */{
    /** initializes the Spawn action with the 2 actions to spawn
     * @param {cc.FiniteTimeAction} action1
     * @param {cc.FiniteTimeAction} action2
     * @return {Boolean}
     */
    initOneTwo:function (action1, action2) {
        cc.Assert(action1 != null, "no action1");
        cc.Assert(action2 != null, "no action2");

        var ret = false;

        var d1 = action1.getDuration();
        var d2 = action2.getDuration();

        if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;

            if (d1 > d2) {
                this._two = cc.Sequence._actionOneTwo(action2, cc.DelayTime.create(d1 - d2));
            } else if (d1 < d2) {
                this._one = cc.Sequence._actionOneTwo(action1, cc.DelayTime.create(d2 - d1));
            }

            ret = true;
        }
        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
    },

    /**
     * Stop the action
     */
    stop:function () {
        this._one.stop();
        this._two.stop();
        this._super();
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._one) {
            this._one.update(time);
        }
        if (this._two) {
            this._two.update(time);
        }
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
    },
    _one:null,
    _two:null
});

/**
 * @param {Array|cc.FiniteTimeAction}tempArray
 * @return {cc.FiniteTimeAction}
 * @example
 * // example
 * var action = cc.Spawn.create(cc.JumpBy.create(2, cc.PointMake(300, 0), 50, 4), cc.RotateBy.create(2, 720));
 */
cc.Spawn.create = function (/*Multiple Arguments*/tempArray) {
    var paramArray = (typeof tempArray == "Array") ? tempArray : arguments;
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i] != null) {
            prev = this._actionOneTwo(prev, paramArray[i]);
        }
    }
    return prev;
};

/**
 * @param {cc.FiniteTimeAction} action1
 * @param {cc.FiniteTimeAction} action2
 * @return {cc.Spawn}
 * @private
 */
cc.Spawn._actionOneTwo = function (action1, action2) {
    var pSpawn = new cc.Spawn();
    pSpawn.initOneTwo(action1, action2);

    return pSpawn;
};


/** Rotates a cc.Node object to a certain angle by modifying it's
 * rotation attribute. <br/>
 * The direction will be decided by the shortest angle.
 * @class
 * @extends cc.ActionInterval
 */
cc.RotateTo = cc.ActionInterval.extend(/** @lends cc.RotateTo# */{
    _dstAngle:0,
    _startAngle:0,
    _diffAngle:0,
    /**
     * @param {Number} duration
     * @param {Number} deltaAngle
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaAngle) {
        if (this._super(duration)) {
            this._dstAngle = deltaAngle;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);

        this._startAngle = target.getRotation();

        if (this._startAngle > 0) {
            this._startAngle = this._startAngle % 360.0;
        }
        else {
            this._startAngle = this._startAngle % 360.0;
        }

        this._diffAngle = this._dstAngle - this._startAngle;
        if (this._diffAngle > 180) {
            this._diffAngle -= 360;
        }

        if (this._diffAngle < -180) {
            this._diffAngle += 360;
        }
    },

    /**
     * RotateTo reverse not implemented
     */
    reverse:function () {
        cc.Assert(0, "RotateTo reverse not implemented");
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target) {
            this._target.setRotation(this._startAngle + this._diffAngle * time);
        }
    }
});

/**
 * @param {Number} duration duration in seconds
 * @param {Number} deltaAngle deltaAngle in degrees.
 * @return {cc.RotateTo}
 * @example
 * // example
 * var rotateTo = cc.RotateTo.create(2, 61.0);
 */
cc.RotateTo.create = function (duration, deltaAngle) {
    var rotateTo = new cc.RotateTo();
    rotateTo.initWithDuration(duration, deltaAngle);

    return rotateTo;
};


/** Rotates a cc.Node object clockwise a number of degrees by modifying it's rotation attribute.
 * @class
 * @extends  cc.ActionInterval
 */
cc.RotateBy = cc.ActionInterval.extend(/** @lends cc.RotateBy# */{
    _angle:0,
    _startAngle:0,

    /**
     * @param {Number} duration duration in seconds
     * @param {Number} deltaAngle deltaAngle in degrees
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaAngle) {
        if (this._super(duration)) {
            this._angle = deltaAngle;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startAngle = target.getRotation();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            this._target.setRotation(this._startAngle + this._angle * time);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.RotateBy.create(this._duration, -this._angle);
    }
});

/**
 * @param {Number} duration druation in seconds
 * @param {Number} deltaAngle deltaAngle in degrees
 * @return {cc.RotateBy}
 * @example
 * // example
 * var actionBy = cc.RotateBy.create(2, 360);
 */
cc.RotateBy.create = function (duration, deltaAngle) {
    var rotateBy = new cc.RotateBy();
    rotateBy.initWithDuration(duration, deltaAngle);

    return rotateBy;
};


/** Moves a cc.Node object to the position x,y. x and y are absolute coordinates by modifying it's position attribute.
 * @class
 * @extends cc.ActionInterval
 */
cc.MoveTo = cc.ActionInterval.extend(/** @lends cc.MoveTo# */{
    /**
     * @param {Number} duration duration in seconds
     * @param {cc.Poin} position
     * @return {Boolean}
     */
    initWithDuration:function (duration, position) {
        if (this._super(duration)) {
            this._endPosition = position;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startPosition = target.getPosition();
        this._delta = cc.ccpSub(this._endPosition, this._startPosition);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target) {
            this._target.setPosition(cc.ccp(this._startPosition.x + this._delta.x * time,
                this._startPosition.y + this._delta.y * time));
        }
    },

    /**
     * MoveTo reverse is not implemented
     */
    reverse:function () {
        cc.Assert(0, "moveto reverse is not implemented");
    },
    _endPosition:new cc.Point(),
    _startPosition:new cc.Point(),
    _delta:new cc.Point()
});

/**
 * @param {Number} duration duration in seconds
 * @param {cc.Point} position
 * @return {cc.MoveTo}
 * @example
 * // example
 * var actionTo = cc.MoveTo.create(2, cc.PointMake(windowSize.width - 40, windowSize.height - 40));
 */
cc.MoveTo.create = function (duration, position) {
    var moveTo = new cc.MoveTo();
    moveTo.initWithDuration(duration, position);

    return moveTo;
};


/** Moves a cc.Node object x,y pixels by modifying it's position attribute. <br/>
 * x and y are relative to the position of the object. <br/>
 * @class
 * @extends cc.MoveTo
 */
cc.MoveBy = cc.MoveTo.extend(/** @lends cc.MoveBy# */{

    /**
     * @param {Number} duration  duration in seconds
     * @param {cc.Point} position
     * @return {Boolean}
     */
    initWithDuration:function (duration, position) {
        if (this._super(duration, position)) {
            this._delta = position;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        var temp = this._delta;
        this._super(target);
        this._delta = temp;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.MoveBy.create(this._duration, cc.ccp(-this._delta.x, -this._delta.y));
    }
});
/**
 * @param {Number} duration duration in seconds
 * @param {cc.Point} position
 * @return {cc.MoveBy}
 * @example
 * // example
 * var actionBy = cc.MoveBy.create(2, cc.PointMake(80, 80));
 */
cc.MoveBy.create = function (duration, position) {
    var moveBy = new cc.MoveBy();
    moveBy.initWithDuration(duration, position);

    return moveBy;
};


/** Skews a cc.Node object to given angles by modifying it's skewX and skewY attributes
 * @class
 * @extends cc.ActionInterval
 */
cc.SkewTo = cc.ActionInterval.extend(/** @lends cc.SkewTo# */{
    /**
     * @param {Number} t time in seconds
     * @param {Number} sx
     * @param {Number} sy
     * @return {Boolean}
     */
    initWithDuration:function (t, sx, sy) {
        var ret = false;

        if (this._super(t)) {
            this._endSkewX = sx;
            this._endSkewY = sy;

            ret = true;
        }

        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);

        this._startSkewX = target.getSkewX();


        if (this._startSkewX > 0) {
            this._startSkewX = this._startSkewX % 180;
        }
        else {
            this._startSkewX = this._startSkewX % -180;
        }

        this._deltaX = this._endSkewX - this._startSkewX;

        if (this._deltaX > 180) {
            this._deltaX -= 360;
        }
        if (this._deltaX < -180) {
            this._deltaX += 360;
        }


        this._startSkewY = target.getSkewY();
        if (this._startSkewY > 0) {
            this._startSkewY = this._startSkewY % 360;
        }
        else {
            this._startSkewY = this._startSkewY % -360;
        }

        this._deltaY = this._endSkewY - this._startSkewY;

        if (this._deltaY > 180) {
            this._deltaY -= 360;
        }
        if (this._deltaY < -180) {
            this._deltaY += 360;
        }
    },

    /**
     * @param {Number} t time in seconds
     */
    update:function (t) {
        this._target.setSkewX(this._startSkewX + this._deltaX * t);

        this._target.setSkewY(this._startSkewY + this._deltaY * t);
    },
    _skewX:0,
    _skewY:0,
    _startSkewX:0,
    _startSkewY:0,
    _endSkewX:0,
    _endSkewY:0,
    _deltaX:0,
    _deltaY:0
});
/**
 * @param {Number} t time in seconds
 * @param {Number} sx
 * @param {Number} sy
 * @return {cc.SkewTo}
 * @example
 * // example
 * var actionTo = cc.SkewTo.create(2, 37.2, -37.2);
 */

cc.SkewTo.create = function (t, sx, sy) {
    var skewTo = new cc.SkewTo();
    if (skewTo) {
        skewTo.initWithDuration(t, sx, sy)
    }
    return skewTo;
};


/** Skews a cc.Node object by skewX and skewY degrees
 * @class
 * @extends cc.SkewTo
 */
cc.SkewBy = cc.SkewTo.extend(/** @lends cc.SkewBy# */{
    /**
     * @param {Number} t time in seconds
     * @param {Number} deltaSkewX  skew in degrees for X axis
     * @param {Number} deltaSkewY  skew in degrees for Y axis
     * @return {Boolean}
     */
    initWithDuration:function (t, deltaSkewX, deltaSkewY) {
        var ret = false;

        if (this._super(t, deltaSkewX, deltaSkewY)) {
            this._skewX = deltaSkewX;
            this._skewY = deltaSkewY;

            ret = true;
        }

        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.SkewBy.create(this._duration, -this._skewX, -this._skewY);
    }
});
/**
 * @param {Number} t time in seconds
 * @param {Number} sx sx skew in degrees for X axis
 * @param {Number} sy sy skew in degrees for Y axis
 * @return {cc.SkewBy}
 * @example
 * // example
 * var actionBy = cc.SkewBy.create(2, 0, -90);
 */
cc.SkewBy.create = function (t, sx, sy) {
    var skewBy = new cc.SkewBy();
    if (skewBy) {
        skewBy.initWithDuration(t, sx, sy);
    }

    return skewBy;
};


/**  Moves a cc.Node object simulating a parabolic jump movement by modifying it's position attribute.
 * @class
 * @extends cc.ActionInterval
 */
cc.JumpBy = cc.ActionInterval.extend(/** @lends cc.JumpBy# */{
    /**
     * @param {Number} duration
     * @param {cc.Point} position
     * @param {Number} height
     * @param {Number} jumps
     * @return {Boolean}
     */
    initWithDuration:function (duration, position, height, jumps) {
        if (this._super(duration)) {
            this._delta = position;
            this._height = height;
            this._jumps = jumps;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startPosition = target.getPosition();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            var frac = time * this._jumps % 1.0;
            var y = this._height * 4 * frac * (1 - frac);
            y += this._delta.y * time;
            var x = this._delta.x * time;
            this._target.setPosition(cc.ccp(this._startPosition.x + x, this._startPosition.y + y));
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.JumpBy.create(this._duration, cc.ccp(-this._delta.x, -this._delta.y), this._height, this._jumps);
    },
    _startPosition:new cc.Point(),
    _delta:new cc.Point(),
    _height:0,
    _jumps:0
});

/**
 * @param {Number} duration
 * @param {cc.Point} position
 * @param {Number} height
 * @param {Number} jumps
 * @return {cc.JumpBy}
 * @example
 * // example
 * var actionBy = cc.JumpBy.create(2, cc.PointMake(300, 0), 50, 4);
 */
cc.JumpBy.create = function (duration, position, height, jumps) {
    var jumpBy = new cc.JumpBy();
    jumpBy.initWithDuration(duration, position, height, jumps);

    return jumpBy;
};


/**  Moves a cc.Node object to a parabolic position simulating a jump movement by modifying it's position attribute.
 * @class
 * @extends cc.JumpBy
 */
cc.JumpTo = cc.JumpBy.extend(/** @lends cc.JumpTo# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._delta = cc.ccp(this._delta.x - this._startPosition.x, this._delta.y - this._startPosition.y);
    }
});

/**
 * @param {Number} duration
 * @param {cc.Point} position
 * @param {Number} height
 * @param {Number} jumps
 * @return {cc.JumpTo}
 * @example
 * // example
 * var actionTo = cc.JumpTo.create(2, cc.PointMake(300, 300), 50, 4);
 */
cc.JumpTo.create = function (duration, position, height, jumps) {
    var jumpTo = new cc.JumpTo();
    jumpTo.initWithDuration(duration, position, height, jumps);

    return jumpTo;
};

/**
 * Bezier configuration structure
 * @class
 * @extends cc.Class
 */
cc.BezierConfig = cc.Class.extend(/** @lends cc.BezierConfig# */{
    /**
     * Constructor
     */
    ctor:function () {
        this.endPosition = new cc.Point();
        this.controlPoint_1 = new cc.Point();
        this.controlPoint_2 = new cc.Point();
    }
});

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} t
 * @return {Number}
 */
cc.bezierat = function (a, b, c, d, t) {
    return (Math.pow(1 - t, 3) * a +
        3 * t * (Math.pow(1 - t, 2)) * b +
        3 * Math.pow(t, 2) * (1 - t) * c +
        Math.pow(t, 3) * d );
};

/** An action that moves the target with a cubic Bezier curve by a certain distance.
 * @class
 * @extends cc.ActionInterval
 */
cc.BezierBy = cc.ActionInterval.extend(/** @lends cc.BezierBy# */{
    /**
     * @param {Number} t time in seconds
     * @param {cc.BezierConfig} c
     * @return {Boolean}
     */
    initWithDuration:function (t, c) {
        if (this._super(t)) {
            this._config = c;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startPosition = target.getPosition();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            var xa = 0;
            var xb = this._config.controlPoint_1.x;
            var xc = this._config.controlPoint_2.x;
            var xd = this._config.endPosition.x;

            var ya = 0;
            var yb = this._config.controlPoint_1.y;
            var yc = this._config.controlPoint_2.y;
            var yd = this._config.endPosition.y;

            var x = cc.bezierat(xa, xb, xc, xd, time);
            var y = cc.bezierat(ya, yb, yc, yd, time);
            this._target.setPosition(cc.ccpAdd(this._startPosition, cc.ccp(x, y)));
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        var r = new cc.BezierConfig();

        r.endPosition = cc.ccpNeg(this._config.endPosition);
        r.controlPoint_1 = cc.ccpAdd(this._config.controlPoint_2, cc.ccpNeg(this._config.endPosition));
        r.controlPoint_2 = cc.ccpAdd(this._config.controlPoint_1, cc.ccpNeg(this._config.endPosition));

        var action = cc.BezierBy.create(this._duration, r);
        return action;
    },

    /**
     * Constructor
     */
    ctor:function () {
        this._config = new cc.BezierConfig();
        this._startPosition = new cc.Point();
    }
});

/**
 * @param {Number} t time in seconds
 * @param {cc.BezierConfig} c
 * @return {cc.BezierBy}
 * @example
 * // example
 * var bezier = new cc.BezierConfig();
 * bezier.controlPoint_1 = cc.PointMake(0, windowSize.height / 2);
 * bezier.controlPoint_2 = cc.PointMake(300, -windowSize.height / 2);
 * bezier.endPosition = cc.PointMake(300, 100);
 *
 * var bezierForward = cc.BezierBy.create(3, bezier);
 *
 */
cc.BezierBy.create = function (t, c) {
    var bezierBy = new cc.BezierBy();
    bezierBy.initWithDuration(t, c);

    return bezierBy;
};


/** An action that moves the target with a cubic Bezier curve to a destination point.
 * @class
 * @extends cc.BezierBy
 */
cc.BezierTo = cc.BezierBy.extend(/** @lends cc.BezierTo# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._config.controlPoint_1 = cc.ccpSub(this._config.controlPoint_1, this._startPosition);
        this._config.controlPoint_2 = cc.ccpSub(this._config.controlPoint_2, this._startPosition);
        this._config.endPosition = cc.ccpSub(this._config.endPosition, this._startPosition);
    }
});
/**
 * @param {Number} t
 * @param {cc.BezierConfig} c
 * @return {cc.BezierTo}
 * @example
 * // example
 *  var bezier = new cc.BezierConfig();
 * bezier.controlPoint_1 = cc.PointMake(100, windowSize.height / 2);
 * bezier.controlPoint_2 = cc.PointMake(200, -windowSize.height / 2);
 * bezier.endPosition = cc.PointMake(240, 160);
 *
 * var bezierTo = cc.BezierTo.create(2, bezier);
 */
cc.BezierTo.create = function (t, c) {
    var bezierTo = new cc.BezierTo();
    bezierTo.initWithDuration(t, c);

    return bezierTo;
};


/** Scales a cc.Node object to a zoom factor by modifying it's scale attribute.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.ScaleTo = cc.ActionInterval.extend(/** @lends cc.ScaleTo# */{
    /**
     * @param {Number} duration
     * @param {Number} sx
     * @param {Number} sy
     * @return {Boolean}
     */
    initWithDuration:function (duration, sx, sy)//function overload here
    {
        if (this._super(duration)) {
            this._endScaleX = sx;
            this._endScaleY = (sy != null) ? sy : sx;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startScaleX = target.getScaleX();
        this._startScaleY = target.getScaleY();
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            this._target.setScaleX(this._startScaleX + this._deltaX * time);
            this._target.setScaleY(this._startScaleY + this._deltaY * time);
        }
    },
    _scaleX:1,
    _scaleY:1,
    _startScaleX:1,
    _startScaleY:1,
    _endScaleX:0,
    _endScaleY:0,
    _deltaX:0,
    _deltaY:0
});
/**
 * @param {Number} duration
 * @param {Number} sx  scale parameter in X
 * @param {Number|Null} sy scale parameter in Y, if Null equal to sx
 * @return {cc.ScaleTo}
 * @example
 * // example
 * // It scales to 0.5 in both X and Y.
 * var actionTo = cc.ScaleTo.create(2, 0.5);
 *
 * // It scales to 0.5 in x and 2 in Y
 * var actionTo = cc.ScaleTo.create(2, 0.5, 2);
 */
cc.ScaleTo.create = function (duration, sx, sy)//function overload
{
    var scaleTo = new cc.ScaleTo();
    if (sy) {
        scaleTo.initWithDuration(duration, sx, sy);
    }
    else {
        scaleTo.initWithDuration(duration, sx);
    }

    return scaleTo;
};


/** Scales a cc.Node object a zoom factor by modifying it's scale attribute.
 * @class
 * @extends cc.ScaleTo
 */
cc.ScaleBy = cc.ScaleTo.extend(/** @lends cc.ScaleBy# */{
    /**
     * @param {Number} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ScaleBy.create(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
    }
});
/**
 * @param {Number} duration duration in seconds
 * @param {Number} sx sx  scale parameter in X
 * @param {Number|Null} sy sy scale parameter in Y, if Null equal to sx
 * @return {cc.ScaleBy}
 * @example
 * // example without sy, it scales by 2 both in X and Y
 * var actionBy = cc.ScaleBy.create(2, 2);
 *
 * //example with sy, it scales by 0.25 in X and 4.5 in Y
 * var actionBy2 = cc.ScaleBy.create(2, 0.25, 4.5);
 */
cc.ScaleBy.create = function (duration, sx, sy) {
    var scaleBy = new cc.ScaleBy();
    if (arguments.length == 3) {
        scaleBy.initWithDuration(duration, sx, sy);
    }
    else {
        scaleBy.initWithDuration(duration, sx);
    }

    return scaleBy;
};

/** Blinks a cc.Node object by modifying it's visible attribute
 * @class
 * @extends cc.ActionInterval
 */
cc.Blink = cc.ActionInterval.extend(/** @lends cc.Blink# */{
    /**
     * @param {Number} duration duration in seconds
     * @param {Number} blinks blinks in times
     * @return {Boolean}
     */
    initWithDuration:function (duration, blinks) {
        if (this._super(duration)) {
            this._times = blinks;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target && !this.isDone()) {
            var slice = 1.0 / this._times;
            var m = time % slice;
            this._target.setIsVisible(m > slice / 2 ? true : false);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Blink.create(this._duration, this._times);
    },
    _times:0
});
/**
 * @param {Number} duration  duration in seconds
 * @param blinks blinks in times
 * @return {cc.Blink}
 * @example
 * // example
 * var action = cc.Blink.create(2, 10);
 */
cc.Blink.create = function (duration, blinks) {
    var blink = new cc.Blink();
    blink.initWithDuration(duration, blinks);

    return blink;
};


/** Fades In an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 0 to 255.<br/>
 * The "reverse" of this action is FadeOut
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeIn = cc.ActionInterval.extend(/** @lends cc.FadeIn# */{
    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setOpacity(255 * time);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.FadeOut.create(this._duration);
    }
});

/**
 * @param {Number} duration duration in seconds
 * @return {cc.FadeIn}
 * @example
 * //example
 * var action = cc.FadeIn.create(1.0);
 */
cc.FadeIn.create = function (duration) {
    var action = new cc.FadeIn();

    action.initWithDuration(duration);

    return action;
};


/** Fades Out an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 255 to 0.
 * The "reverse" of this action is FadeIn
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeOut = cc.ActionInterval.extend(/** @lends cc.FadeOut# */{
    /**
     * @param {Number} time  time in seconds
     */
    update:function (time) {
        this._target.setOpacity(255 * (1 - time));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.FadeIn.create(this._duration);
    }
});

/**
 * @param {Number} d  duration in seconds
 * @return {cc.FadeOut}
 * @example
 * // example
 * var action = cc.FadeOut.create(1.0);
 */
cc.FadeOut.create = function (d) {
    var action = new cc.FadeOut();

    action.initWithDuration(d);

    return action;
};


/** Fades an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from the current value to a custom one.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeTo = cc.ActionInterval.extend(/** @lends cc.FadeTo# */{
    /**
     * @param {Number} duration  duration in seconds
     * @param {Number} opacity
     * @return {Boolean}
     */
    initWithDuration:function (duration, opacity) {
        if (this._super(duration)) {
            this._toOpacity = opacity;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setOpacity((this._fromOpacity + (this._toOpacity - this._fromOpacity) * time));
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._fromOpacity = target.getOpacity();
    },
    _toOpacity:'',
    _fromOpacity:''
});

/**
 * @param {Number} duration
 * @param {Number} opacity 0-255, 0 is transparent
 * @return {cc.FadeTo}
 * @example
 * // example
 * var action = cc.FadeTo.create(1.0, 0);
 */
cc.FadeTo.create = function (duration, opacity) {
    var fadeTo = new cc.FadeTo();
    fadeTo.initWithDuration(duration, opacity);

    return fadeTo;
};


/** Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.TintTo = cc.ActionInterval.extend(/** @lends cc.TintTo# */{
    /**
     * @param {Number} duration
     * @param {Number} red 0-255
     * @param {Number} green  0-255
     * @param {Number} blue 0-255
     * @return {Boolean}
     */
    initWithDuration:function (duration, red, green, blue) {
        if (this._super(duration)) {
            this._to = cc.ccc3(red, green, blue);
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._from = this._target.getColor();
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setColor(cc.ccc3(this._from.r + (this._to.r - this._from.r) * time,
            (this._from.g + (this._to.g - this._from.g) * time),
            (this._from.b + (this._to.b - this._from.b) * time)));
    },
    _to:new cc.Color3B(),
    _from:new cc.Color3B()
});

/**
 * @param {Number} duration
 * @param {Number} red 0-255
 * @param {Number} green  0-255
 * @param {Number} blue 0-255
 * @return {cc.TintTo}
 * @example
 * // example
 * var action = cc.TintTo.create(2, 255, 0, 255);
 */
cc.TintTo.create = function (duration, red, green, blue) {
    var tintTo = new cc.TintTo();
    tintTo.initWithDuration(duration, red, green, blue);

    return tintTo;
};


/**  Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
 * @class
 * @extends cc.ActionInterval
 */
cc.TintBy = cc.ActionInterval.extend(/** @lends cc.TintBy# */{
    /**
     * @param {Number} duration
     * @param {Number} deltaRed 0-255
     * @param {Number} deltaGreen 0-255
     * @param {Number} deltaBlue 0-255
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaRed, deltaGreen, deltaBlue) {
        if (this._super(duration)) {
            this._deltaR = deltaRed;
            this._deltaG = deltaGreen;
            this._deltaB = deltaBlue;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        //if (target.RGBAProtocol) {
        var color = target.getColor();
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
        //}
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        //if (this._target.RGBAProtocol) {
        this._target.setColor(cc.ccc3((this._fromR + this._deltaR * time),
            (this._fromG + this._deltaG * time),
            (this._fromB + this._deltaB * time)));
        //}
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
    },
    _deltaR:0,
    _deltaG:0,
    _deltaB:0,

    _fromR:0,
    _fromG:0,
    _fromB:0
});

/**
 * @param {Number} duration  duration in seconds
 * @param {Number} deltaRed
 * @param {Number} deltaGreen
 * @param {Number} deltaBlue
 * @return {cc.TintBy}
 * @example
 * // example
 * var action = cc.TintBy.create(2, -127, -255, -127);
 */
cc.TintBy.create = function (duration, deltaRed, deltaGreen, deltaBlue) {
    var tintBy = new cc.TintBy();
    tintBy.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);

    return tintBy;
};


/** Delays the action a certain amount of seconds
 * @class
 * @extends cc.ActionInterval
 */
cc.DelayTime = cc.ActionInterval.extend(/** @lends cc.DelayTime# */{

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.DelayTime.create(this._duration);
    }
});

/**
 * @param {Number} d duration in seconds
 * @return {cc.DelayTime}
 * @example
 * // example
 * var delay = cc.DelayTime.create(1);
 */
cc.DelayTime.create = function (d) {
    var action = new cc.DelayTime();

    action.initWithDuration(d);

    return action;
};


/** Executes an action in reverse order, from time=duration to time=0

 * @warning Use this action carefully. This action is not
 * sequenceable. Use it as the default "reversed" method
 * of your own actions, but using it outside the "reversed"
 * scope is not recommended.
 * @class
 * @extends cc.ActionInterval
 */
cc.ReverseTime = cc.ActionInterval.extend(/** @lends cc.ReverseTime# */{
    /**
     * @param {cc.FiniteTimeAction} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");
        cc.Assert(action != this._other, "");

        if (this._super(action.getDuration())) {
            // Don't leak if action is reused

            this._other = action;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._other.startWithTarget(target);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._other) {
            this._other.update(1 - time);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return this._other.copy();
    },

    /**
     * Stop the action
     */
    stop:function () {
        this._other.stop();
        this._super();
    },
    _other:null
});

/**
 * @param {cc.FiniteTimeAction} action
 * @return {cc.ReverseTime}
 * @example
 * // example
 *  var reverse = cc.ReverseTime.create(this);
 */
cc.ReverseTime.create = function (action) {
    var reverseTime = new cc.ReverseTime();
    reverseTime.initWithAction(action);

    return reverseTime;
};


/**  Animates a sprite given the name of an Animation
 * @class
 * @extends cc.ActionInterval
 */
cc.Animate = cc.ActionInterval.extend(/** @lends cc.Animate# */{
    _animation:null,
    _origFrame:null,
    _restoreOriginalFrame:false,

    /**
     * @return {cc.Animation}
     */
    getAnimation:function () {
        return this._animation;
    },

    /**
     * @param {cc.Animation} animation
     */
    setAnimation:function (animation) {
        this._animation = animation;
    },

    /**
     * @param {cc.Animation} animation
     * @param {Boolean} restoreOriginalFrame
     * @return {Boolean}
     */
    initWithAnimation:function (animation, restoreOriginalFrame) {
        cc.Assert(animation != null, "");
        if (this.initWithDuration(animation.getFrames().length * animation.getDelay(), null, null, true)) {
            this._restoreOriginalFrame = restoreOriginalFrame;
            this._animation = animation;
            this._origFrame = null;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} duration
     * @param {cc.Animation} animation
     * @param {Boolean} restoreOriginalFrame
     * @param {Boolean} isSuperCall
     * @return {*}
     */
    initWithDuration:function (duration, animation, restoreOriginalFrame, isSuperCall) {
        if (isSuperCall) {
            return this._super(duration);
        }
        cc.Assert(animation != null, "");

        if (this._super(duration)) {
            this._restoreOriginalFrame = restoreOriginalFrame;
            this._animation = animation;
            this._origFrame = null;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);

        if (this._restoreOriginalFrame) {
            this._origFrame = target.displayedFrame();
        }
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        var frames = this._animation.getFrames();
        var numberOfFrames = frames.length;

        var idx = 0 | (time * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this._target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.setDisplayFrame(frames[idx]);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        var newAnim = cc.Animation.create(this._animation.getFrames().reverse(), this._animation.getDelay());
        return cc.Animate.create(this._duration, newAnim, this._restoreOriginalFrame);
    },

    /**
     * stop the action
     */
    stop:function () {
        if (this._restoreOriginalFrame && this._target) {
            this._target.setDisplayFrame(this._origFrame);
        }

        this._super();
    }
});

/**
 * It accepts three groups of parameters:
 * a) animation
 * b) animation, restoreOriginalFrame
 * c) duration, animation, restoreOriginalFrame
 * @return {cc.Animate}
 * @example
 * // example
 * // create the animation with animation
 * var anim = cc.Animate.create(dance_grey);
 *
 * // create the animation with animation and restoreOriginalFrame
 * var anim = cc.Animate.create(dance_grey, false);
 *
 * // create the animation with duration, animation and restoreOriginalFrame
 * var anim = cc.Animate.create(10, dance_grey, false);  // duration in seconds
 */
cc.Animate.create = function (/* Multi arguments */) {
    var animate = new cc.Animate();
    if (arguments.length == 3) {
        animate.initWithDuration(arguments[0], arguments[1], arguments[2]);
    } else {
        animate.initWithAnimation(arguments[0], arguments[1]);
    }

    return animate;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Instant actions are immediate actions. They don't have a duration like
 * the CCIntervalAction actions.
 * @class
 * @extends cc.FiniteTimeAction
 */
cc.ActionInstant = cc.FiniteTimeAction.extend(/** @lends cc.ActionInstant# */{
    /**
     * @return {Boolean}
     */
    isDone:function () {
        return true;
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        this.update(1);
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
    }
});

/**  Show the node
 * @class
 * @extends cc.ActionInstant
 */
cc.Show = cc.ActionInstant.extend(/** @lends cc.Show# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        target.setIsVisible(true);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Hide.create.call(this);
    }
});
/**
 * @return {cc.Show}
 * @example
 * // example
 * var showAction = cc.Show.create();
 */
cc.Show.create = function () {
    return new cc.Show();
};

/**
 * Hide the node
 * @class
 * @extends cc.ActionInstant
 */
cc.Hide = cc.ActionInstant.extend(/** @lends cc.Hide# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        target.setIsVisible(false);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Show.create.call(this);
    }
});
/**
 * @return {cc.Hide}
 * @example
 * // example
 * var hideAction = cc.Hide.create();
 */
cc.Hide.create = function () {
    return (new cc.Hide());
};


/** Toggles the visibility of a node
 * @class
 * @extends cc.ActionInstant
 */
cc.ToggleVisibility = cc.ActionInstant.extend(/** @lends cc.ToggleVisibility# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super();
        target.setIsVisible(!target.getIsVisible());
    },

    /**
     * @return {cc.ToggleVisibility}
     */
    reverse:function () {
        return new cc.ToggleVisibility();
    }
});

/**
 * @return {cc.ToggleVisibility}
 * @example
 * // example
 * var toggleVisibilityAction = cc.ToggleVisibility.create();
 */
cc.ToggleVisibility.create = function () {
    return (new cc.ToggleVisibility());
};

/**
 * Flips the sprite horizontally
 * @class
 * @extends cc.ActionInstant
 */
cc.FlipX = cc.ActionInstant.extend(/** @lends cc.FlipX# */{
    /**
     * @param {Boolean} x
     * @return {Boolean}
     */
    initWithFlipX:function (x) {
        this._flipX = x;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super();
        target.setFlipX(this._flipX);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        this.initWithFlipX(!this._flipX);
        return this;
    },
    _flipX:false
});

/**
 * @param {Boolean} x
 * @return {cc.FlipX}
 * var flipXAction = cc.FlipX.create(true);
 */
cc.FlipX.create = function (x) {
    var ret = new cc.FlipX();
    if (ret.initWithFlipX(x))
        return ret;
};

/**
 * Flips the sprite vertically
 * @class
 * @extends cc.ActionInstant
 */
cc.FlipY = cc.ActionInstant.extend(/** @lends cc.FlipY# */{
    /**
     * @param {Boolean} Y
     * @return {Boolean}
     */
    initWithFlipY:function (Y) {
        this._flipY = Y;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super();
        target.setFlipY(this._flipY);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return this.actionWithFlipY(!this._flipY);
    },
    _flipY:false
});
/**
 * @param {Boolean} y
 * @return {cc.FlipY}
 * @example
 * // example
 * var flipYAction = cc.FlipY.create();
 */
cc.FlipY.create = function (y) {
    var ret = new cc.FlipY();
    if (ret.initWithFlipY(y))
        return ret;
};


/** Places the node in a certain position
 * @class
 * @extends cc.ActionInstant
 */
cc.Place = cc.ActionInstant.extend(/** @lends cc.Place# */{
    /** Initializes a Place action with a position
     * @param {cc.Point} pos
     * @return {Boolean}
     */
    initWithPosition:function (pos) {
        this._position = pos;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._target.setPosition(this._position);
    }
});
/** creates a Place action with a position
 * @param {cc.Point} pos
 * @return {cc.Place}
 * @example
 * // example
 * var placeAction = cc.Place.create(cc.PointMake(200, 200));
 */
cc.Place.create = function (pos) {
    var ret = new cc.Place();
    ret.initWithPosition(pos);
    return ret;
};


/** Calls a 'callback'
 * @class
 * @extends cc.ActionInstant
 */
cc.CallFunc = cc.ActionInstant.extend(/** @lends cc.CallFunc# */{
    /**
     * @param {object} selectorTarget
     * @param {function|Null} selector
     * @param {*|Null} data data for function, it accepts all data types.
     * @return {Boolean}
     */
    initWithTarget:function (selectorTarget, selector, data) {
        this._data = data || null;
        this._callFunc = selector || null;
        this._selectorTarget = selectorTarget || null;
        return true;
    },

    /**
     * execute the function.
     */
    execute:function () {
        if (this._callFunc != null)//CallFunc, N, ND
        {
            this._callFunc.call(this._selectorTarget, this._target, this._data);
        }
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this.execute();
    },

    /**
     * @return {object}
     */
    getTargetCallback:function () {
        return this._selectorTarget;
    },

    /**
     * @param {object} sel
     */
    setTargetCallback:function (sel) {
        if (sel != this._selectorTarget) {
            if (this._selectorTarget) {
                this._selectorTarget = null;
            }
            this._selectorTarget = sel;
        }
    },
    _selectorTarget:null,
    _callFunc:null
});
/** creates the action with the callback
 * @param {object} selectorTarget
 * @param {function|Null} selector
 * @param {*|Null} data data for function, it accepts all data types.
 * @return {cc.CallFunc}
 * @example
 * // example
 * // CallFunc without data
 * var finish = cc.CallFunc.create(this, this.removeSprite);
 *
 * // CallFunc with data
 * var finish = cc.CallFunc.create(this._grossini, this.removeFromParentAndCleanup, true),
 */

cc.CallFunc.create = function (selectorTarget, selector, data) {
    var ret = new cc.CallFunc();
    if (ret && ret.initWithTarget(selectorTarget, selector, data)) {
        ret._callFunc = selector;
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */

cc.HashElement = cc.Class.extend(/** @lends cc.HashElement# */{
    actions:null,
    target:null, //ccobject
    actionIndex:0,
    currentAction:null, //CCAction
    currentActionSalvaged:false,
    paused:false,
    hh:null, //ut hash handle
    /**
     * Constructor
     */
    ctor:function () {
        this.actions = [];
    }
});

/**
 * cc.ActionManager is a singleton that manages all the actions.<br/>
 * Normally you won't need to use this singleton directly. 99% of the cases you will use the CCNode interface,
 * which uses this singleton.
 * But there are some cases where you might need to use this singleton. <br/>
 * Examples:<br/>
 * - When you want to run an action where the target is different from a CCNode.<br/>
 * - When you want to pause / resume the actions<br/>
 * @class
 * @extends cc.Class
 */
cc.ActionManager = cc.Class.extend({
    _targets:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,

    _searchElementByTarget:function (arr, target) {
        for (var k = 0; k < arr.length; k++) {
            if (target == arr[k].target) {
                return arr[k];
            }
        }
        return null;
    },

    /**
     * Constructor
     */
    ctor:function () {
        cc.Assert(cc.sharedManager == null, "");
        this._targets = [];
    },

    /**
     * @return {Boolean}
     */
    init:function () {
        cc.Scheduler.sharedScheduler().scheduleUpdateForTarget(this, 0, false);
        return true;
    },

    selTarget:null,
    /** Adds an action with a target.
     * If the target is already present, then the action will be added to the existing target.
     * If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
     * When the target is paused, the queued actions won't be 'ticked'.
     * @param {cc.Action} action
     * @param {cc.Node} target
     * @param {Boolean} paused
     */
    addAction:function (action, target, paused) {
        cc.Assert(action != null, "no action");
        cc.Assert(target != null, "");
        //check if the action target already exists
        var element = this._searchElementByTarget(this._targets, target);
        //if doesnt exists, create a hashelement and push in mpTargets
        if (!element) {
            element = new cc.HashElement();
            element.paused = paused;
            element.target = target;
            element.id = target.id || "no id";
            this.selTarget = element;
            this._targets.push(element);
        }
        //creates a array for that eleemnt to hold the actions
        this._actionAllocWithHashElement(element);
        cc.Assert((element.actions.indexOf(action) == -1), "ActionManager.addAction(),");

        element.actions.push(action);
        action.startWithTarget(target);
    },

    /**
     * Removes all actions from all the targets.
     */
    removeAllActions:function () {
        for (var i = 0; i < this._targets.length; i++) {
            var element = this._targets[i];
            if (element) {
                this.removeAllActionsFromTarget(element.target);
            }
        }
    },
    /** Removes all actions from a certain target. <br/>
     * All the actions that belongs to the target will be removed.
     * @param {object} target
     */
    removeAllActionsFromTarget:function (target) {
        // explicit null handling
        if (target == null) {
            return;
        }
        var element = this._searchElementByTarget(this._targets, target);

        //var element = (target in this._targets)? this._targets[ptarget]: null;
        if (element) {
            if (element.currentAction in element.actions && !(element.currentActionSalvaged)) {
                element.currentActionSalvaged = true;
            }

            element.actions = [];
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            }
            else {
                this._deleteHashElement(element);
            }
        } else {
            //cc.Log("cocos2d: removeAllActionsFromTarget: Target not found");
        }
    },
    /** Removes an action given an action reference.
     * @param {cc.Action} action
     */
    removeAction:function (action) {
        // explicit null handling
        if (action == null) {
            return;
        }
        var target = action.getOriginalTarget();
        var element = this._searchElementByTarget(this._targets, target);

        if (element) {
            for (var i = 0; i < element.actions.length; i++) {
                if (element.actions[i] == action) {
                    element.actions.splice(i, 1);
                    break;
                }
            }
        } else {
            cc.Log("cocos2d: removeAction: Target not found");
        }
    },

    /** Removes an action given its tag and the target
     * @param {Number} tag
     * @param {object} target
     */
    removeActionByTag:function (tag, target) {
        cc.Assert(tag != cc.CCACTION_TAG_INVALID, "");
        cc.Assert(target != null, "");

        var element = this._searchElementByTarget(this._targets, target);

        if (element) {
            var limit = element.actions.length;
            for (var i = 0; i < limit; ++i) {
                var action = element.actions[i];
                if (action) {
                    if (action.getTag() == tag && action.getOriginalTarget() == target) {
                        this._removeActionAtIndex(i, element);
                        break;
                    }
                }
            }
        }
    },

    /** Gets an action given its tag an a target
     * @param {Number} tag
     * @param {object} target
     * @return {cc.Action|Null}  return the Action with the given tag on success
     */
    getActionByTag:function (tag, target) {
        cc.Assert(tag != cc.CCACTION_TAG_INVALID, "");
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            if (element.actions != null) {
                for (var i = 0; i < element.actions.length; ++i) {
                    var action = element.actions[i];
                    if (action) {
                        if (action.getTag() == tag) {
                            return action;
                        }
                    }
                }
            }
        }

        return null;
    },


    /** Returns the numbers of actions that are running in a certain target. <br/>
     * Composable actions are counted as 1 action. <br/>
     * Example: <br/>
     * - If you are running 1 Sequence of 7 actions, it will return 1. <br/>
     * - If you are running 7 Sequences of 2 actions, it will return 7.
     * @param {object} target
     * @return {Number}
     */
    numberOfRunningActionsInTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            return (element.actions) ? element.actions.length : 0;
        }

        return 0;
    },
    /** Pauses the target: all running actions and newly added actions will be paused.
     * @param {object} target
     */
    pauseTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            element.paused = true;
        }
    },
    /** Resumes the target. All queued actions will be resumed.
     * @param {object} target
     */
    resumeTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            element.paused = false;
        }
    },
    /** purges the shared action manager. It releases the retained instance. <br/>
     * because it uses this, so it can not be static
     */
    purgeSharedManager:function () {
        cc.Scheduler.sharedScheduler().unscheduleUpdateForTarget(this);
    },

    //protected
    _removeActionAtIndex:function (index, element) {
        var action = element.actions[index];

        if ((action == element.currentAction) && (!element.currentActionSalvaged)) {
            element.currentActionSalvaged = true;
        }

        element.actions[index] = null;

        // update actionIndex in case we are in tick. looping over the actions
        if (element.actionIndex >= index) {
            element.actionIndex--;
        }

        if (element.actions.length == 0) {
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            }
            else {
                this._deleteHashElement(element);
            }
        }
    },

    _deleteHashElement:function (element) {
        cc.ArrayRemoveObject(this._targets, element);
        if (element) {
            element.actions = null;
            element.target = null;
        }
    },

    _actionAllocWithHashElement:function (element) {
        // 4 actions per Node by default
        if (element.actions == null) {
            element.actions = [];
        }
    },

    /**
     * @param {Number} dt delta time in seconds
     */
    update:function (dt) {
        for (var elt = 0; elt < this._targets.length; elt++) {
            this._currentTarget = this._targets[elt];
            this._currentTargetSalvaged = false;
            if (!this._currentTarget.paused) {
                // The 'actions' CCMutableArray may change while inside this loop.
                for (this._currentTarget.actionIndex = 0; this._currentTarget.actionIndex < this._currentTarget.actions.length;
                     this._currentTarget.actionIndex++) {
                    this._currentTarget.currentAction = this._currentTarget.actions[this._currentTarget.actionIndex];
                    if (this._currentTarget.currentAction == null) {
                        continue;
                    }

                    this._currentTarget.currentActionSalvaged = false;

                    this._currentTarget.currentAction.step(dt);

                    if (this._currentTarget.currentActionSalvaged) {
                        // The currentAction told the node to remove it. To prevent the action from
                        // accidentally deallocating itself before finishing its step, we retained
                        // it. Now that step is done, it's safe to release it.
                        this._currentTarget.currentAction = null;//release
                    } else if (this._currentTarget.currentAction.isDone()) {
                        this._currentTarget.currentAction.stop();

                        var action = this._currentTarget.currentAction;
                        // Make currentAction nil to prevent removeAction from salvaging it.
                        this._currentTarget.currentAction = null;
                        this.removeAction(action);
                    }

                    this._currentTarget.currentAction = null;
                }
            }

            // elt, at this moment, is still valid
            // so it is safe to ask this here (issue #490)

            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)
            if (this._currentTargetSalvaged && this._currentTarget.actions.length == 0) {
                this._deleteHashElement(this._currentTarget);
            }
        }
    }
});
/** purges the shared action manager. It releases the retained instance. <br/>
 * because it uses this, so it can not be static
 * @return {cc.ActionManager}
 */
cc.ActionManager.sharedManager = function () {
    if (!cc.sharedManager) {
        cc.sharedManager = new cc.ActionManager();
        if (!cc.sharedManager.init()) {
            //delete CCActionManager if init error
            delete cc.sharedManager;
        }
    }
    return cc.sharedManager;
};

/**
 * @type {cc.ActionManager}
 */
cc.sharedManager = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (C) 2010      Lam Pham

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Progress to percentage
 * @class
 * @extends cc.ActionInterval
 */
cc.ProgressTo = cc.ActionInterval.extend(/** @lends cc.ProgressTo# */{
    _to:0,
    _from:0,

    /** Initializes with a duration and a percent
     * @param {Number} duration duration in seconds
     * @param {Number} percent
     * @return {Boolean}
     */
    initWithDuration:function (duration, percent) {
        if (this._super(duration)) {
            this._to = percent;
            return true;
        }
        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {
        var newZone = null;
        var copy = null;
        if (zone && zone._copyObject) {
            //in case of being called at sub class
            copy = zone._copyObject;
        } else {
            copy = new cc.ProgressTo();
            zone = newZone = new cc.Zone(copy);
        }

        this._super(zone);

        copy.initWithDuration(this._duration, this._to);

        return copy;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._from = target.getPercentage();

        // XXX: Is this correct ?
        // Adding it to support CCRepeat
        if (this._from == 100) {
            this._from = 0;
        }
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target  instanceof cc.ProgressTimer) {
            this._target.setPercentage(this._from + (this._to - this._from) * time);
        }
    }
});

/** Creates and initializes with a duration and a percent
 * @param {Number} duration duration in seconds
 * @param {Number} percent
 * @return {cc.ProgressTo}
 * @example
 * // example
 * var to = cc.ProgressTo.create(2, 100);
 *
 */
cc.ProgressTo.create = function (duration, percent) {
    var progressTo = new cc.ProgressTo();
    progressTo.initWithDuration(duration, percent);

    return progressTo;
};

/**
 * Progress from a percentage to another percentage
 * @class
 * @extends cc.ActionInterval
 */
cc.ProgressFromTo = cc.ActionInterval.extend(/** @lends cc.ProgressFromTo# */{
    _to:0,
    _from:0,
    /** Initializes the action with a duration, a "from" percentage and a "to" percentage
     * @param {Number} duration duration in seconds
     * @param {Number} fromPercentage
     * @param {Number} toPercentage
     * @return {Boolean}
     */
    initWithDuration:function (duration, fromPercentage, toPercentage) {
        if (this._super(duration)) {
            this._to = toPercentage;
            this._from = fromPercentage;
            return true;
        }
        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {
        var newZone = null;
        var copy = null;
        if (zone && zone._copyObject) {
            //in case of being called at sub class
            copy = zone._copyObject;
        } else {
            copy = new cc.ProgressFromTo();
            zone = newZone = new cc.Zone(copy);
        }

        this._super(zone);
        copy.initWithDuration(this._duration, this._from, this._to);
        return copy;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ProgressFromTo.create(this._duration, this._to, this._from);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target  instanceof cc.ProgressTimer) {
            this._target.setPercentage(this._from + (this._to - this._from) * time);
        }
    }
});

/** Creates and initializes the action with a duration, a "from" percentage and a "to" percentage
 * @param {Number} duration duration in seconds
 * @param {Number} fromPercentage
 * @param {Number} toPercentage
 * @return {cc.ProgressFromTo}
 * @example
 * // example
 *  var fromTO = cc.ProgressFromTo.create(2, 100.0, 0.0);
 */
cc.ProgressFromTo.create = function (duration, fromPercentage, toPercentage) {
    var progressFromTo = new cc.ProgressFromTo();
    progressFromTo.initWithDuration(duration, fromPercentage, toPercentage);
    return progressFromTo;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/**
 @brief Base class for cc.Camera actions
 */
cc.ActionCamera = cc.ActionInterval.extend({
    centerXOrig:0,
    centerYOrig:0,
    centerZOrig:0,
    eyeXOrig:0,
    eyeYOrig:0,
    eyeZOrig:0,
    upXOrig:0,
    upYOrig:0,
    upZOrig:0,
    // super methods
    startWithTarget:function (target) {
        this._super(target);

        var camera = target.getCamera();
        camera.getCenterXYZ(this.centerXOrig, this.centerYOrig, this.centerZOrig);
        camera.getEyeXYZ(this.eyeXOrig, this.eyeYOrig, this.eyeZOrig);
        camera.getUpXYZ(this.upXOrig, this.upYOrig, this.upZOrig);
    },
    reverse:function () {
        return cc.ReverseTime.create(this);
    }
});

/**
 @brief cc.OrbitCamera action
 Orbits the camera around the center of the screen using spherical coordinates
 */
cc.OrbitCamera = cc.ActionCamera.extend({
    radius:0.0,
    deltaRadius:0.0,
    angleZ:0.0,
    deltaAngleZ:0.0,
    angleX:0.0,
    deltaAngleX:0.0,
    radZ:0.0,
    radDeltaZ:0.0,
    radX:0.0,
    radDeltaX:0.0,

    /** initializes a cc.OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX */
    initWithDuration:function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
        if (this._super(t)) {
            this.radius = radius;
            this.deltaRadius = deltaRadius;
            this.angleZ = angleZ;
            this.deltaAngleZ = deltaAngleZ;
            this.angleX = angleX;
            this.deltaAngleX = deltaAngleX;

            this.radDeltaZ = cc.DEGREES_TO_RADIANS(deltaAngleZ);
            this.radDeltaX = cc.DEGREES_TO_RADIANS(deltaAngleX);
            return true;
        }
        return false;
    },
    /** positions the camera according to spherical coordinates */
    sphericalRadius:function (newRadius, zenith, azimuth) {
        var ex, ey, ez, cx, cy, cz, x, y, z;
        var r; // radius
        var s;

        var camera = this._target.getCamera();
        camera.getEyeXYZ(ex, ey, ez);
        camera.getCenterXYZ(cx, cy, cz);

        x = ex - cx;
        y = ey - cy;
        z = ez - cz;

        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
        s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if (s == 0.0)
            s = cc.FLT_EPSILON;
        if (r == 0.0)
            r = cc.FLT_EPSILON;

        zenith = Math.acos(z / r);
        if (x < 0)
            azimuth = Math.PI - Math.asin(y / s);
        else
            azimuth = Math.asin(y / s);

        newRadius = r / cc.Camera.getZEye();
    },
    // super methods
    copyWithZone:function (zone) {
        var newZone = null;
        var ret = null;
        if (zone && zone.copyObject) //in case of being called at sub class
            ret = zone.copyObject;
        else {
            ret = new cc.OrbitCamera();
            zone = newZone = new cc.Zone(ret);
        }

        cc.ActionInterval.copyWithZone(zone);

        ret.initWithDuration(this._duration, this.radius, this.deltaRadius, this.angleZ, this.deltaAngleZ, this.angleX, this.deltaAngleX);

        return ret;
    },
    startWithTarget:function (target) {
        this._super(target);
        var r, zenith, azimuth;
        this.sphericalRadius(r, zenith, azimuth);
        if (isNaN(this.radius)) {
            this.radius = r;
        }
        if (isNaN(this.angleZ)) {
            this.angleZ = cc.RADIANS_TO_DEGREES(zenith);
        }
        if (isNaN(this.angleX)) {
            this.angleX = cc.RADIANS_TO_DEGREES(azimuth);
        }

        this.radZ = cc.DEGREES_TO_RADIANS(this.angleZ);
        this.radX = cc.DEGREES_TO_RADIANS(this.angleX);
    },
    update:function (dt) {
        var r = (this.radius + this.deltaRadius * dt) * cc.Camera.getZEye();
        var za = this.radZ + this.radDeltaZ * dt;
        var xa = this.radX + this.radDeltaX * dt;

        var i = Math.sin(za) * Math.cos(xa) * r + this.centerXOrig;
        var j = Math.sin(za) * Math.sin(xa) * r + this.centerYOrig;
        var k = Math.cos(za) * r + this.centerZOrig;

        this._target.getCamera().setEyeXYZ(i, j, k);
    }
});

/** creates a cc.OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX */
cc.OrbitCamera.create = function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    var ret = new cc.OrbitCamera();
    if (ret.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Base class for Easing actions
 * @class
 * @extends cc.ActionInterval
 */

cc.ActionEase = cc.ActionInterval.extend(/** @lends cc.ActionEase# */{

    /** initializes the action
     * @param {cc.ActionInterval} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");

        if (this.initWithDuration(action.getDuration())) {
            this._other = action;
            return true;
        }
        return false;
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._other.startWithTarget(this._target);   //TODO, need to be checked
    },

    /**
     * Stop the action.
     */
    stop:function () {
        this._other.stop();
        this._super();
    },

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ActionEase.create(this._other.reverse());
    },

    _other:null
});

/** creates the action of ActionEase
 * @param {cc.ActionInterval} action
 * @return {cc.ActionEase}
 * @example
 * // example
 * var moveEase = cc.ActionEase.create(action);
 */
cc.ActionEase.create = function (action) {
    var ret = new cc.ActionEase();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};

/**
 * Base class for Easing actions with rate parameters
 * @class
 * @extends cc.ActionEase
 */
cc.EaseRateAction = cc.ActionEase.extend(/** @lends cc.EaseRateAction# */{

    /** set rate value for the actions
     * @param {Number} rate
     */
    setRate:function (rate) {
        this._rate = rate;
    },

    /** get rate value for the actions
     * @return {Number}
     */
    getRate:function () {
        return this._rate;
    },

    /** Initializes the action with the inner action and the rate parameter
     *
     * @param {cc.ActionInterval} action
     * @param {Number} rate
     * @return {Boolean}
     */
    initWithAction:function (action, rate) {
        if (this._super(action)) {
            this._rate = rate;
            return true;
        }

        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseRateAction.create(this._other.reverse(), 1 / this._rate);
    },

    _rate:null
});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseRateAction}
 * @example
 * // example
 * var moveEaseRateAction = cc.EaseRateAction.create(action, 3.0);
 */
cc.EaseRateAction.create = function (action, rate) {
    var ret = new cc.EaseRateAction();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;

};

/**
 * cc.EaseIn action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseIn = cc.EaseRateAction.extend(/** @lends cc.EaseIn# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.pow(time1, this._rate));
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseIn}
 * @example
 * // example
 * var moveEaseIn = cc.EaseIn.create(action, 3.0);
 */
cc.EaseIn.create = function (action, rate) {
    var ret = new cc.EaseIn();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};
/**
 * cc.EaseOut action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseOut = cc.EaseRateAction.extend(/** @lends cc.EaseOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.pow(time1, 1 / this._rate));
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseOut}
 * @example
 * // example
 * var moveEaseOut = cc.EaseOut.create(action, 3.0);
 */
cc.EaseOut.create = function (action, rate) {
    var ret = new cc.EaseOut();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};

/**
 * cc.EaseInOut action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseInOut = cc.EaseRateAction.extend(/** @lends cc.EaseInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {

        var sign = 1;
        var r = this._rate;

        if (r % 2 == 0) {
            sign = -1;
        }

        time1 *= 2;
        if (time1 < 1) {
            this._other.update(0.5 * Math.pow(time1, this._rate));
        } else {
            this._other.update(sign * 0.5 * (Math.pow(time1 - 2, this._rate) + sign * 2));
        }

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseInOut.create(this._other.reverse(), this._rate);

    }


});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseInOut}
 * @example
 * // example
 * var moveEaseInOut = cc.EaseInOut.create(action, 3.0);
 */
cc.EaseInOut.create = function (action, rate) {
    var ret = new cc.EaseInOut();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};
/**
 * cc.Ease Exponential In
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialIn = cc.ActionEase.extend(/** @lends cc.EaseExponentialIn# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1 == 0 ? 0 : Math.pow(2, 10 * (time1 / 1 - 1)) - 1 * 0.001);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseExponentialOut.create(this._other.reverse());
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialIn}
 * @example
 * // example
 * var moveEaseExponentialIn = cc.EaseExponentialIn.create(action);
 */
cc.EaseExponentialIn.create = function (action) {
    var ret = new cc.EaseExponentialIn();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Exponential Out
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialOut = cc.ActionEase.extend(/** @lends cc.EaseExponentialOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1 == 1 ? 1 : (-(Math.pow(2, -10 * time1 / 1)) + 1));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseExponentialIn.create(this._other.reverse());
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }



});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialOut}
 * @example
 * // example
 * var moveEaseExponentialOut = cc.EaseExponentialOut.create(action);
 */
cc.EaseExponentialOut.create = function (action) {
    var ret = new cc.EaseExponentialOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Exponential InOut
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialInOut = cc.ActionEase.extend(/** @lends cc.EaseExponentialInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        time1 /= 0.5;
        if (time1 < 1) {
            time1 = 0.5 * Math.pow(2, 10 * (time1 - 1));
        } else {
            time1 = 0.5 * (-Math.pow(2, 10 * (time1 - 1)) + 2);
        }

        this._other.update(time1);

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialInOut}
 * @example
 * // example
 * var moveEaseExponentialInOut = cc.EaseExponentialInOut.create(action);
 */
cc.EaseExponentialInOut.create = function (action) {
    var ret = new cc.EaseExponentialInOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};


/**
 * Ease Sine In
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineIn = cc.ActionEase.extend(/** @lends cc.EaseSineIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(-1 * Math.cos(time1 * Math.PI / 2) + 1);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseSineOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineIn}
 * @example
 * // example
 * var moveSineIn = cc.EaseSineIn.create(action);
 */
cc.EaseSineIn.create = function (action) {
    var ret = new cc.EaseSineIn();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Sine Out
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineOut = cc.ActionEase.extend(/** @lends cc.EaseSineOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.sin(time1 * Math.PI / 2));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseSineIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineOut}
 * @example
 * // example
 * var moveEaseOut = cc.EaseSineOut.create(action);
 */
cc.EaseSineOut.create = function (action) {
    var ret = new cc.EaseSineOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};


/**
 * Ease Sine InOut
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineInOut = cc.ActionEase.extend(/** @lends cc.EaseSineInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(-0.5 * (Math.cos(Math.PI * time1) - 1));

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineInOut}
 * @example
 * // example
 * var moveEaseSineInOut = cc.EaseSineInOut.create(action);
 */
cc.EaseSineInOut.create = function (action) {
    var ret = new cc.EaseSineInOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};

/**
 * Ease Elastic abstract class
 * @class
 * @extends cc.ActionEase
 */
cc.EaseElastic = cc.ActionEase.extend(/** @lends cc.EaseElastic# */{

    /** get period of the wave in radians. default is 0.3
     * @return {Number}
     */
    getPeriod:function () {
        return this._period;
    },

    /** set period of the wave in radians.
     * @param {Number} period
     */
    setPeriod:function (period) {
        this._period = period;
    },

    /** Initializes the action with the inner action and the period in radians (default is 0.3)
     * @param {cc.ActionInterval} action
     * @param {Number} period
     * @return {Boolean}
     */
    initWithAction:function (action, period) {
        this._super(action);
        this._period = (period == null) ? 3.0 : period;
        return true;
    },

    /**
     * @return {Null}
     */
    reverse:function () {
        cc.Assert(0, "");

        return null;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    _period:null
});

/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElastic}
 * @example
 * // example
 * var moveEaseElastic = cc.EaseElastic.create(action, 3.0);
 */
cc.EaseElastic.create = function (action, period) {
    var ret = new cc.EaseElastic();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};


/**
 * Ease Elastic In action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticIn = cc.EaseElastic.extend(/** @lends cc.EaseElasticIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            var s = this._period / 4;
            time1 = time1 - 1;
            newT = -Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period);
        }

        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseElasticOut.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});


/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticIn}
 * @example
 * // example
 * var moveEaseElasticIn = cc.EaseElasticIn.create(action, 3.0);
 */
cc.EaseElasticIn.create = function (action, period) {
    var ret = new cc.EaseElasticIn();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * Ease Elastic Out action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticOut = cc.EaseElastic.extend(/** @lends cc.EaseElasticOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            var s = this._period / 4;
            newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) + 1;
        }

        this._other.update(newT);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseElasticIn.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});


/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticOut}
 * @example
 * // example
 * var moveEaseElasticOut = cc.EaseElasticOut.create(action, 3.0);
 */
cc.EaseElasticOut.create = function (action, period) {
    var ret = new cc.EaseElasticOut();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * Ease Elastic InOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticInOut = cc.EaseElastic.extend(/** @lends cc.EaseElasticInOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            time1 = time1 * 2;
            if (!this._period) {
                this._period = 0.3 * 1.5;
            }

            var s = this._period / 4;

            time1 = time1 - 1;
            if (time1 < 0) {
                newT = -0.5 * Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period);
            } else {
                newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) * 0.5 + 1;
            }
        }

        this._other.update(newT);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseInOut.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticInOut}
 * @example
 * // example
 * var moveEaseElasticInOut = cc.EaseElasticInOut.create(action, 3.0);
 */
cc.EaseElasticInOut.create = function (action, period) {
    var ret = new cc.EaseElasticInOut();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * cc.EaseBounce abstract class.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBounce = cc.ActionEase.extend(/** @lends cc.EaseBounce# */{
    /**
     * @param {Number} time1
     * @return {Number}
     */
    bounceTime:function (time1) {
        if (time1 < 1 / 2.75) {
            return 7.5625 * time1 * time1;
        } else if (time1 < 2 / 2.75) {
            time1 -= 1.5 / 2.75;
            return 7.5625 * time1 * time1 + 0.75;
        } else if (time1 < 2.5 / 2.75) {
            time1 -= 2.25 / 2.75;
            return 7.5625 * time1 * time1 + 0.9375;
        }

        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + 0.984375;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounce}
 * @example
 * // example
 * var moveEaseBounce = cc.EaseBounce.create(action);
 */
cc.EaseBounce.create = function (action) {
    var ret = new cc.EaseBounce();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBounceIn action.
 * @warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceIn = cc.EaseBounce.extend(/** @lends cc.EaseBounceIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 1 - this.bounceTime(1 - time1);
        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBounceOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceIn}
 * @example
 * // example
 * var moveEaseBounceIn = cc.EaseBounceIn.create(action);
 */
cc.EaseBounceIn.create = function (action) {
    var ret = new cc.EaseBounceIn();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};
/**
 * cc.EaseBounceOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceOut = cc.EaseBounce.extend(/** @lends cc.EaseBounceOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = this.bounceTime(time1);
        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBounceIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceOut}
 * @example
 * // example
 * var moveEaseBounceOut = cc.EaseBounceOut.create(action);
 */
cc.EaseBounceOut.create = function (action) {
    var ret = new cc.EaseBounceOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBounceInOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceInOut = cc.EaseBounce.extend(/** @lends cc.EaseBounceInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 < 0.5) {
            time1 = time1 * 2;
            newT = (1 - this.bounceTime(1 - time1)) * 0.5;
        } else {
            newT = this.bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
        }

        this._other.update(newT);

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceInOut}
 * @example
 * // example
 * var moveEaseBounceInOut = cc.EaseBounceInOut.create(action);
 */
cc.EaseBounceInOut.create = function (action) {
    var ret = new cc.EaseBounceInOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackIn action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackIn = cc.ActionEase.extend(/** @lends cc.EaseBackIn# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158;
        this._other.update(time1 * time1 * ((overshoot + 1) * time1 - overshoot));

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBackOut.create(this._other.reverse());

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackIn}
 * @example
 * // example
 * var moveEaseBackIn = cc.EaseBackIn.create(action);
 */
cc.EaseBackIn.create = function (action) {
    var ret = new cc.EaseBackIn();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackOut = cc.ActionEase.extend(/** @lends cc.EaseBackOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158;

        time1 = time1 - 1;
        this._other.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBackIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackOut}
 * @example
 * // example
 * var moveEaseBackOut = cc.EaseBackOut.create(action);
 */
cc.EaseBackOut.create = function (action) {
    var ret = new cc.EaseBackOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackInOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackInOut = cc.ActionEase.extend(/** @lends cc.EaseBackInOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158 * 1.525;

        time1 = time1 * 2;
        if (time1 < 1) {
            this._other.update((time1 * time1 * ((overshoot + 1) * time1 - overshoot)) / 2);
        } else {
            time1 = time1 - 2;
            this._other.update((time1 * time1 * ((overshoot + 1) * time1 + overshoot)) / 2 + 1);
        }
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackInOut}
 * @example
 * // example
 * var moveEaseBackInOut = cc.EaseBackInOut.create(action);
 */
cc.EaseBackInOut.create = function (action) {
    var ret = new cc.EaseBackInOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** @brief Base class for Grid actions */
cc.GridAction = cc.ActionInterval.extend({
    _gridSize:null,
    startWithTarget:function (target) {
        this._super(target);
        var newgrid = this.getGrid();
        var t = this._target;
        var targetGrid = t.getGrid();
        if (targetGrid && targetGrid.getReuseGrid() > 0) {
            if (targetGrid.isActive() && targetGrid.getGridSize().x == this._gridSize.x && targetGrid.getGridSize().y == this._gridSize.y) {
                targetGrid.reuse();
            }
            else {
                cc.Assert(0, "");
            }
        }
        else {
            if (targetGrid && targetGrid.isActive()) {
                targetGrid.setActive(false);
            }
            t.setGrid(newgrid);
            t.getGrid().setActive(true);
        }
    },

    reverse:function () {
        return cc.ReverseTime.create(this);
    },

    /** initializes the action with size and duration */
    initWithSize:function (gridSize, duration) {
        if (this.initWithDuration(duration)) {
            this._gridSize = gridSize;
            return true;
        }
        return false;
    },

    /** returns the grid */
    getGrid:function () {
        // Abstract class needs implementation
        cc.Assert(0, "");
        return null;
    }
});

/** creates the action with size and duration */
cc.GridAction.create = function (gridSize, duration) {
    var action = new cc.GridAction();
    action.initWithSize(gridSize, duration)
    return action;
},

/**
 @brief Base class for cc.Grid3D actions.
 Grid3D actions can modify a non-tiled grid.
 */
    cc.Grid3DAction = cc.GridAction.extend({
        /** returns the grid */
        getGrid:function () {
            return cc.Grid3D.create(this._gridSize);
        },

        /** returns the vertex than belongs to certain position in the grid */
        vertex:function (pos) {
            var g = this._target.getGrid();
            return g.vertex(pos);
        },

        /** returns the non-transformed vertex than belongs to certain position in the grid */
        originalVertex:function (pos) {
            var g = this._target.getGrid();
            return g.originalVertex(pos);
        },

        /** sets a new vertex to a certain position of the grid */
        setVertex:function (pos, vertex) {
            var g = this._target.getGrid();
            g.setVertex(pos, vertex);
        }
    });
/** creates the action with size and duration */
cc.Grid3DAction.create = function () {

};
/** @brief Base class for cc.TiledGrid3D actions */
cc.TiledGrid3DAction = cc.GridAction.extend({
    /** returns the tile that belongs to a certain position of the grid */
    tile:function (pos) {
        var g = this._target.getGrid();
        return g.tile(pos);
    },

    /** returns the non-transformed tile that belongs to a certain position of the grid */
    originalTile:function (pos) {
        var g = this._target.getGrid();
        return g.originalTile(pos);
    },

    /** sets a new tile to a certain position of the grid */
    setTile:function (pos, coords) {
        var g = this._target.getGrid();
        return g.setTile(pos, coords);
    },

    /** returns the grid */
    getGrid:function () {
        return cc.TiledGrid3D.create(this._gridSize);
    }
});

/** creates the action with size and duration */
cc.TiledGrid3DAction.create = function (gridSize, duration) {

};

/** @brief cc.AccelDeccelAmplitude action */
cc.AccelDeccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;
            return true;
        }
        return false;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {
        var f = time * 2;
        if (f > 1) {
            f -= 1;
            f = 1 - f;
        }
        this._other.setAmplitudeRate(Math.pow(f, this._rate));
    },

    reverse:function () {
        return cc.AccelDeccelAmplitude.create(this._other.reverse(), this._duration);
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.AccelDeccelAmplitude.create = function (action, duration) {
    var ret = new cc.AccelDeccelAmplitude();
    return ret;
};

/** @brief cc.AccelAmplitude action */
cc.AccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;

            return true;
        }
        return false;
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {

        this._other.setAmplitudeRate(Math.pow(time, this._rate));
        this._other.update(time);
    },

    reverse:function () {
        return cc.AccelAmplitude.create(this._other.reverse(), this._duration);
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.AccelAmplitude.create = function (action, duration) {
    var ret = new cc.AccelAmplitude();
    return ret;
};

/** @brief cc.DeccelAmplitude action */
cc.DeccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;
            return true;
        }

        return false;
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {
        this._other.setAmplitudeRate(Math.pow((1 - time), this._rate));
        this._other.update(time);
    },

    reverse:function () {
        return cc.DeccelAmplitude.create(this._other.reverse(), this._duration);
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.DeccelAmplitude.create = function (action, duration) {
    var ret = new cc.DeccelAmplitude();
    return ret;
};

/** @brief cc.StopGrid action.
 @warning Don't call this action if another grid action is active.
 Call if you want to remove the the grid effect. Example:
 cc.Sequence.create(Lens.action(...), cc.StopGrid.create(...), null);
 */
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget:function (target) {
        this._super(target);
        var grid = this._target.getGrid();
        if (grid && grid.isActive()) {
            grid.setActive(false);
        }
    }
});

/** Allocates and initializes the action */
cc.StopGrid.create = function () {
    var action = new cc.StopGrid();
    return action;
};

/** @brief cc.ReuseGrid action */
cc.ReuseGrid = cc.ActionInstant.extend({
    _times:null,
    /** initializes an action with the number of times that the current grid will be reused */
    initWithTimes:function (times) {
        this._times = times;

        return true;
    },

    startWithTarget:function (target) {
        cc.ActionInstant.startWithTarget(target);

        if (this._target.getGrid() && this._target.getGrid().isActive()) {
            this._target.getGrid().setReuseGrid(this._target.getGrid().getReuseGrid() + this._times);
        }
    }

});

/** creates an action with the number of times that the current grid will be reused */
cc.ReuseGrid.create = function (times) {
    var action = new cc.ReuseGrid();
    return action;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** cc.TurnOffTiles action.<br/>
 * Turn off the files in random order
 * @class
 * @extends cc.TiledGrid3DAction
 */
cc.TurnOffTiles = cc.TiledGrid3DAction.extend(/** @lends cc.TurnOffTiles# */{
    _seed:null,
    _tilesCount:0,
    _tilesOrder:[],

    /** initializes the action with a random seed, the grid size and the duration
     * @param {cc.GridSize} gridSize
     * @param {Number} duration
     * @param {Number} seed
     * @return {Boolean}
     */
    initWithSeed:function ( gridSize, duration, seed) {
        if (this.initWithSize(gridSize, duration)) {
            this._seed = seed;
            this._tilesOrder = null;

            return true;
        }

        return false;
    },

    /**
     * @param {Array} array
     * @param {Number} len
     */
    shuffle:function (array, len) {
        var i;
        for (i = len - 1; i >= 0; i--) {
            var j = parseInt(Math.random() * (i + 1));
            var v = array[i];
            array[i] = array[j];
            array[j] = v;
        }
    },

    /**
     * @param {cc.GridSize} pos
     */
    turnOnTile:function (pos) {
        this.setTile(pos, this.originalTile(pos));
    },

    /**
     * @param {cc.GridSize}pos
     */
    turnOffTile:function (pos) {
        var coords = new cc.Quad3();
        this.setTile(pos, coords);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        var i;

        this._super(target);

        if (this._seed != -1) {
            parseInt(Math.random() * this._seed);
        }
        this._tilesCount = this._gridSize.x * this._gridSize.y;
        this._tilesOrder = [];

        for (i = 0; i < this._tilesCount; ++i) {
            this._tilesOrder[i] = i;
        }

        this.shuffle(this._tilesOrder, this._tilesCount);
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        var i, l, t;

        l = time * this._tilesCount;

        for (i = 0; i < this._tilesCount; i++) {
            t = this._tilesOrder[i];
            var tilePos = cc.ccg(t / this._gridSize.y, t % this._gridSize.y);

            if (i < l) {
                this.turnOffTile(tilePos);
            }
            else {
                this.turnOnTile(tilePos);
            }
        }
    }

});

/**
 * @param {cc.GridSize}gridSize
 * @param {Number} duration
 * @param {Number|Null} seed
 * @return {cc.TurnOffTiles}
 * @example
 * // example
 * // turnOffTiles without seed
 * var toff = cc.TurnOffTiles.create(cc.ccg(x, y), this._duration);
 *
 * // turnOffTiles with seed
 * var toff = cc.TurnOffTiles.create(cc.ccg(x, y), this._duration, 0);
 */
cc.TurnOffTiles.create = function (gridSize, duration, seed) {
    var action = new cc.TurnOffTiles();
    if(arguments.length == 2) {
        /** creates the action with the grid size and the duration */
        action.initWithSize(gridSize, duration);
    } else if (arguments.length == 3) {
        /** creates the action with the grid size, the duration and a random seed */
        action.initWithSeed(gridSize, duration, seed);
    }
    return action;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * <p>cc.Scene is a subclass of cc.Node that is used only as an abstract concept.</p>
 *  <p>cc.Scene an cc.Node are almost identical with the difference that cc.Scene has it's
 * anchor point (by default) at the center of the screen.</p>
 *
 * <p>For the moment cc.Scene has no other logic than that, but in future releases it might have
 * additional logic.</p>
 *
 * <p>It is a good practice to use and cc.Scene as the parent of all your nodes.</p>
 * @class
 * @extends cc.Node
 */
cc.Scene = cc.Node.extend(/** @lends cc.Scene# */{
    /**
     * Constructor
     */
    ctor:function () {
        this._isRelativeAnchorPoint = false;
        var director = cc.Director.sharedDirector();
        this.setAnchorPoint(cc.ccp(0.5, 0.5));
        this.setContentSize(director.getWinSize());
    },

    /**
     * Initialize
     * @return {Boolean}
     */
    init:function () {
        var director = cc.Director.sharedDirector();
        this.setContentSize(director.getWinSize());
        return true;
    }
});
/**
 * creates a scene
 * @return {cc.Scene}
 * @example
 * // Example
 * var aScene = cc.Scene.create();
 * //OR
 * var aScene = new cc.Scene();
 */
cc.Scene.create = function () {
    var ret = new cc.Scene();
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** cc.Layer is a subclass of cc.Node that implements the TouchEventsDelegate protocol.<br/>
 * All features from cc.Node are valid, plus the following new features:<br/>
 * It can receive iPhone Touches<br/>
 * It can receive Accelerometer input
 * @class
 * @extends cc.Node
 */
cc.Layer = cc.Node.extend(/** @lends cc.Layer# */{
    _isTouchEnabled:false,
    _isAccelerometerEnabled:false,
    _isKeypadEnabled:false,

    /**
     * Constructor
     * @return {Boolean} return false if director fails
     */
    ctor:function () {
        this._super();
        this.setAnchorPoint(cc.ccp(0.5, 0.5));
        this._isRelativeAnchorPoint = false;
        //this.initLayer();
        var director = cc.Director.sharedDirector();
        if (!director) {
            return false;
        }
        this.setContentSize(director.getWinSize());
        this._isTouchEnabled = false;
        this._isAccelerometerEnabled = false;
    },

    /**
     *
     * @return {Boolean}
     */
    init:function () {
        /*var director = cc.Director.sharedDirector();
         if (!director) {
         return false;
         }
         this.setContentSize(director.getWinSize());
         this._isTouchEnabled = false;*/

        // success
        return true;
    },

    /**
     * If isTouchEnabled, this method is called onEnter. Override it to change the<br/>
     * way CCLayer receives touch events.<br/>
     */
    registerWithTouchDispatcher:function () {
        cc.TouchDispatcher.sharedDispatcher().addStandardDelegate(this, 0);
    },

    /**
     * whether or not it will receive Touch events.<br/>
     * You can enable / disable touch events with this property.<br/>
     * Only the touches of this node will be affected. This "method" is not propagated to it's children.<br/>
     * @return {Boolean}
     */
    getIsTouchEnabled:function () {
        return this._isTouchEnabled;
    },

    /**
     * Enable touch events
     * @param {Boolean} enabled
     */
    setIsTouchEnabled:function (enabled) {
        if (this._isTouchEnabled != enabled) {
            this._isTouchEnabled = enabled;


            if (this._isRunning) {
                if (enabled) {
                    this.registerWithTouchDispatcher();
                } else {
                    // have problems?
                    cc.TouchDispatcher.sharedDispatcher().removeDelegate(this);
                }
            }
        }
    },

    /**
     * whether or not it will receive Accelerometer events<br/>
     * You can enable / disable accelerometer events with this property.
     * @return {Boolean}
     */
    getIsAccelerometerEnabled:function () {
        return this._isAccelerometerEnabled;
    },

    /**
     * isAccelerometerEnabled setter
     * @param enabled
     */
    setIsAccelerometerEnabled:function (enabled) {
        if (enabled != this._isAccelerometerEnabled) {
            this._isAccelerometerEnabled = enabled;

            if (this._isRunning) {
                if (enabled) {
                    cc.Accelerometer.sharedAccelerometer().setDelegate(this);
                }
                else {
                    cc.Accelerometer.sharedAccelerometer().setDelegate(null);
                }
            }
        }
    },

    /**
     * whether or not it will receive keypad events<br/>
     * You can enable / disable accelerometer events with this property.<br/>
     * it's new in cocos2d-x
     * @return {Boolean}
     */
    getIsKeypadEnabled:function () {
        return this._isKeypadEnabled;
    },

    /**
     * Enable Keyboard interaction
     * @param {Boolean} enabled
     */
    setIsKeypadEnabled:function (enabled) {
        if (enabled != this._isKeypadEnabled) {
            this._isKeypadEnabled = enabled;
            if (this._isRunning) {
                if (enabled) {
                    cc.KeypadDispatcher.sharedDispatcher().addDelegate(this);
                } else {
                    cc.KeypadDispatcher.sharedDispatcher().removeDelegate(this);
                }
            }
        }
    },

    /**
     * This is run when ever a layer just become visible
     */
    onEnter:function () {
        // register 'parent' nodes first
        // since events are propagated in reverse order
        if (this._isTouchEnabled) {
            this.registerWithTouchDispatcher();
        }

        // then iterate over all the children
        //cc.Node.onEnter();
        this._super();

        // add this layer to concern the Accelerometer Sensor
        if (this._isAccelerometerEnabled) {
            cc.Accelerometer.sharedAccelerometer().setDelegate(this);
        }

        // add this layer to concern the kaypad msg
        if (this._isKeypadEnabled) {
            cc.KeypadDispatcher.sharedDispatcher().addDelegate(this);
        }
    },

    /**
     * @function
     */
    onExit:function () {
        if (this._isTouchEnabled) {
            cc.TouchDispatcher.sharedDispatcher().removeDelegate(this);
        }

        // remove this layer from the delegates who concern Accelerometer Sensor
        if (this._isAccelerometerEnabled) {
            cc.Accelerometer.sharedAccelerometer().setDelegate(null);
        }

        // remove this layer from the delegates who concern the kaypad msg
        if (this._isKeypadEnabled) {
            cc.KeypadDispatcher.sharedDispatcher().removeDelegate(this);
        }

        this._super();
    },

    /**
     * this is called when ever a layer is a child of a scene that just finished a transition
     */
    onEnterTransitionDidFinish:function () {
        if (this._isAccelerometerEnabled) {
            cc.Accelerometer.sharedAccelerometer().setDelegate(this);
        }
        this._super();
    },

    /**
     * default implements are used to call script callback if exist<br/>
     * you must override these touch functions if you wish to utilize them
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    ccTouchBegan:function (touch, event) {
        cc.Assert(false, "Layer#ccTouchBegan override me");
        return true;
    },

    /**
     * callback when a touch event moved
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchMoved:function (touch, event) {
    },

    /**
     * callback when a touch event finished
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchEnded:function (touch, event) {
    },

    /**
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchCancelled:function (touch, event) {
    },

    /**
     * Touches is the same as Touch, except this one can handle multi-touch
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesBegan:function (touch, event) {
    },

    /**
     * when a touch moved
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesMoved:function (touch, event) {
    },

    /**
     * when a touch finished
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesEnded:function (touch, event) {
    },

    /**
     * @param touch
     * @param event
     */
    ccTouchesCancelled:function (touch, event) {
    },

    didAccelerate:function (pAccelerationValue) {
    },

    /**
     * @param {cc.Layer} layer
     */
    addLayer:function (layer) {
        cc.Assert(this._layers, "cc.Layer addLayer");
        this._layers.addObject(layer);
    }
});

/**
 * creates a layer
 * @example
 * // Example
 * var myLayer = cc.Layer.create();
 * //Yes! it's that simple
 * @return {cc.Layer|Null}
 */
cc.Layer.create = function () {
    var ret = new cc.Layer();
    if (ret && ret.init()) {
        return ret;
    }
    else {
        return null;
    }
};


/**
 * CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol.<br/>
 *  All features from CCLayer are valid, plus the following new features:<br/>
 * <ul><li>opacity</li>
 * <li>RGB colors</li></ul>
 * @class
 * @extends cc.Layer
 */
cc.LayerColor = cc.Layer.extend(/** @lends cc.LayerColor# */{
    _squareVertices:[],
    _squareColors:[],
    _opacity:0,
    _color:new cc.Color3B(255, 255, 255),
    _blendFunc:new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST),

    /**
     * Constructor
     */
    ctor:function () {
        this._squareVertices = [new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0)];
        this._squareColors = [new cc.Color4B(0, 0, 0, 1), new cc.Color4B(0, 0, 0, 1), new cc.Color4B(0, 0, 0, 1), new cc.Color4B(0, 0, 0, 1)];
        this._color = new cc.Color3B(0, 0, 0);
        this._super();
    },

    /**
     * opacity getter
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * opacity setter
     * @param {Number} Var a number between 0 and 255, 0 is totally transparent
     */
    setOpacity:function (Var) {
        this._opacity = Var;
        this._updateColor();

        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * color getter
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * color setter
     * @param {cc.Color3B} Var
     */
    setColor:function (Var) {
        this._color = Var;
        this._updateColor();

        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * blendFunc getter
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * blendFunc setter
     * @param {cc.BlendFunc} Var
     */
    setBlendFunc:function (Var) {
        this._blendFunc = Var;
    },

    /**
     * @param color
     * @return {Boolean}
     */
    initWithColor:function (color) {
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._color = new cc.Color3B(color.r, color.g, color.b);
        this._opacity = color.a;

        for (var i = 0; i < this._squareVertices.length; i++) {
            this._squareVertices[i].x = 0.0;
            this._squareVertices[i].y = 0.0;
        }
        this._updateColor();
        return true;
    },

    /**
     * override contentSize
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        this._squareVertices[1].x = size.width * cc.CONTENT_SCALE_FACTOR();
        this._squareVertices[2].y = size.height * cc.CONTENT_SCALE_FACTOR();
        this._squareVertices[3].x = size.width * cc.CONTENT_SCALE_FACTOR();
        this._squareVertices[3].y = size.height * cc.CONTENT_SCALE_FACTOR();
        this._super(size);
    },

    /**
     * change width and height in Points
     * @param {Number} w width
     * @param {Number} h height
     */
    changeWidthAndHeight:function (w, h) {
        this.setContentSize(cc.SizeMake(w, h));
    },

    /**
     * change width in Points
     * @param {Number} w width
     */
    changeWidth:function (w) {
        this.setContentSize(cc.SizeMake(w, this._contentSize.height));
    },

    /**
     * change height in Points
     * @param {Number} h height
     */
    changeHeight:function (h) {
        this.setContentSize(cc.SizeMake(this._contentSize.width, h));
    },
    _updateColor:function () {
        for (var i = 0; i < 4; i++) {
            this._squareColors[i].r = Math.round(this._color.r);
            this._squareColors[i].g = Math.round(this._color.g);
            this._squareColors[i].b = Math.round(this._color.b);
            this._squareColors[i].a = Math.round(this._opacity);
        }
    },

    setIsOpacityModifyRGB:function (value) {
    },
    getIsOpacityModifyRGB:function () {
        return false;
    },

    /**
     * renders the layer
     * @param {CanvasContext|Null} ctx
     */
    draw:function (ctx) {
        //TODO need to fix child position in relation to parent
        var context = ctx || cc.renderContext;

        if (cc.renderContextType == cc.CANVAS) {
            //context.globalAlpha = this.getOpacity() / 255;
            var tWidth = this.getContentSize().width;
            var tHeight = this.getContentSize().height;
            var tGradient = context.createLinearGradient(-this.getAnchorPointInPixels().x, this.getAnchorPointInPixels().y,
                -this.getAnchorPointInPixels().x + tWidth, -(this.getAnchorPointInPixels().y + tHeight));

            tGradient.addColorStop(0, "rgba(" + this._squareColors[0].r + "," + this._squareColors[0].g + ","
                + this._squareColors[0].b + "," + this._squareColors[0].a / 255 + ")");
            tGradient.addColorStop(1, "rgba(" + this._squareColors[3].r + "," + this._squareColors[3].g + ","
                + this._squareColors[3].b + "," + this._squareColors[3].a / 255 + ")");

            context.fillStyle = tGradient;
            context.fillRect(-this.getAnchorPointInPixels().x, this.getAnchorPointInPixels().y, tWidth, -tHeight);
        }
        this._super();
        return;
        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_VERTEX_ARRAY, GL_COLOR_ARRAY
        // Unneeded states: GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY

        // glDisableClientState(GL_TEXTURE_COORD_ARRAY);

        // glDisable(GL_TEXTURE_2D);

        // glVertexPointer(2, GL_FLOAT, 0, this._squareVertices);

        // glColorPointer(4, GL_UNSIGNED_BYTE, 0, this._squareColors);

        var newBlend = false;
        if (this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST) {
            newBlend = true;
            //glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        }
        else if (this._opacity != 255) {
            newBlend = true;
            // glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        }

        // glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

        if (newBlend) {
            // glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        }
        // restore default GL state
        // glEnableClientState(GL_TEXTURE_COORD_ARRAY);
        // glEnable(GL_TEXTURE_2D);

    }
});

/**
 * creates a cc.Layer with color, width and height in Points
 * @param {cc.Color3B} color
 * @param {Number|Null} width
 * @param {Number|Null} height
 * @return {cc.LayerColor}
 * @example
 * // Example
 * //Create a yellow color layer as background
 * var yellowBackground = cc.LayerColor.create(cc.ccc3(255,255,0));
 * //If you didnt pass in width and height, it defaults to the same size as the canvas
 *
 * //create a yellow box, 200 by 200 in size
 * var yellowBox = cc.LayerColor.create(cc.ccc3(255,255,0), 200, 200);
 */
cc.LayerColor.create = function (color, width, height) {
    var ret = new cc.LayerColor();
    if (color) {
        ret.initWithColor(color);
    } else {
        ret.init();
    }
    // If it has width and height, set it.
    if (width && height) {
        ret.setContentSize(cc.SizeMake(width, height));
    }
    return ret;
};


/**
 * CCLayerGradient is a subclass of cc.LayerColor that draws gradients across<br/>
 * the background.<br/>
 *<br/>
 * All features from cc.LayerColor are valid, plus the following new features:<br/>
 * <ul><li>direction</li>
 * <li>final color</li>
 * <li>interpolation mode</li></ul>
 * <br/>
 * Color is interpolated between the startColor and endColor along the given<br/>
 * vector (starting at the origin, ending at the terminus).  If no vector is<br/>
 * supplied, it defaults to (0, -1) -- a fade from top to bottom.<br/>
 * <br/>
 * If 'compressedInterpolation' is disabled, you will not see either the start or end color for<br/>
 * non-cardinal vectors; a smooth gradient implying both end points will be still<br/>
 * be drawn, however.<br/>
 *<br/>
 * If ' compressedInterpolation' is enabled (default mode) you will see both the start and end colors of the gradient.
 * @class
 * @extends cc.LayerColor
 */
cc.LayerGradient = cc.LayerColor.extend(/** @lends cc.LayerGradient# */{
    _startColor:new cc.Color3B(0, 0, 0),
    _endColor:new cc.Color3B(0, 0, 0),
    _startOpacity:null,
    _endOpacity:null,
    _alongVector:null,
    _compressedInterpolation:false,

    /**
     * Constructor
     * @function
     */
    ctor:function () {
        this._startColor = new cc.Color3B(0, 0, 0);
        this._endColor = new cc.Color3B(0, 0, 0);
        this._super();
    },

    /**
     * get the starting color
     * @return {cc.Color3B}
     */
    getStartColor:function () {
        return this._color;
    },

    /**
     * set the starting color
     * @param {cc.Color3B} color
     * @example
     * // Example
     * myGradientLayer.setStartColor(cc.ccc3(255,0,0));
     * //set the starting gradient to red
     */
    setStartColor:function (color) {
        this.setColor(color);
    },

    /**
     * set the end gradient color
     * @param {cc.Color3B} color
     * @example
     * // Example
     * myGradientLayer.setEndColor(cc.ccc3(255,0,0));
     * //set the ending gradient to red
     */
    setEndColor:function (color) {
        this._endColor = color;
        this._updateColor();
    },

    /**
     * get the end color
     * @return {cc.Color3B}
     */
    getEndColor:function () {
        return this._endColor;
    },

    /**
     * set starting gradient opacity
     * @param {Number} o from 0 to 255, 0 is transparent
     */
    setStartOpacity:function (o) {
        this._startOpacity = o;
        this._updateColor();
    },

    /**
     * get the starting gradient opacity
     * @return {Number}
     */
    getStartOpacity:function () {
        return this._startOpacity;
    },

    /**
     * set the end gradient opacity
     * @param {Number} o
     */
    setEndOpacity:function (o) {
        this._endOpacity = o;
        this._updateColor();
    },

    /**
     * get the end gradient opacity
     * @return {Number}
     */
    getEndOpacity:function () {
        return this._endOpacity;
    },

    /**
     * set vector
     * @param {cc.Point} Var
     */
    setVector:function (Var) {
        this.alongVector = Var;
        this._updateColor();
    },

    /**
     * @return {cc.Point}
     */
    getVector:function () {
        return this.alongVector;
    },

    /**
     * @return {Boolean}
     */
    getIsCompressedInterpolation:function () {
        return this._compressedInterpolation;
    },

    /**
     * @param {Boolean} compress
     */
    setIsCompressedInterpolation:function (compress) {
        this._compressedInterpolation = compress;
        this._updateColor();
    },

    /**
     * @param {cc.Color3B} start starting color
     * @param {cc.Color3B} end
     * @param {cc.Point|Null} v
     * @return {Boolean}
     */
    initWithColor:function (start, end, v) {
        var argnum = arguments.length;
        if (argnum == 2) {
            // Initializes the CCLayer with a gradient between start and end.
            v = cc.ccp(0, -1);
        }

        // Initializes the CCLayer with a gradient between start and end in the direction of v.
        this._startColor.r = start.r;
        this._startColor.g = start.g;
        this._startColor.b = start.b;
        this._startOpacity = start.a;

        this._endColor.r = end.r;
        this._endColor.g = end.g;
        this._endColor.b = end.b;
        this._endOpacity = end.a;

        this.alongVector = v;

        this._compressedInterpolation = true;

        return this._super(cc.ccc4(start.r, start.g, start.b, 255));
    },

    _updateColor:function () {
        //todo need fixed for webGL
        this._super();
        /*
         this._squareColors[0].r = Math.round(this._startColor.r);
         this._squareColors[0].g = Math.round(this._startColor.g);
         this._squareColors[0].b = Math.round(this._startColor.b);
         this._squareColors[0].a = Math.round(this._startColor.a);

         this._squareColors[3].r = Math.round(this._endColor.r);
         this._squareColors[3].g = Math.round(this._endColor.g);
         this._squareColors[3].b = Math.round(this._endColor.b);
         this._squareColors[3].a = Math.round(this._endColor.a);
         return;
         */


        var h = cc.ccpLength(this.alongVector);
        if (h == 0)
            return;

        var c = Math.sqrt(2.0);
        var u = new cc.Point();
        u = cc.ccp(this.alongVector.x / h, this.alongVector.y / h);

        // Compressed Interpolation mode
        if (this._compressedInterpolation) {
            var h2 = 1 / ( Math.abs(u.x) + Math.abs(u.y) );
            u = cc.ccpMult(u, h2 * c);
        }

        var opacityf = this._opacity / 255.0;

        var S = new cc.Color4B(this._startColor.r, this._startColor.g, this._startColor.b, this._startOpacity * opacityf);

        var E = new cc.Color4B(this._endColor.r, this._endColor.g, this._endColor.b, this._endOpacity * opacityf);

        // (-1, -1)
        this._squareColors[0].r = parseInt((E.r + (S.r - E.r) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].g = parseInt((E.g + (S.g - E.g) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].b = parseInt((E.b + (S.b - E.b) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].a = parseInt((E.a + (S.a - E.a) * ((c + u.x + u.y) / (2.0 * c))));
        // (1, -1)
        this._squareColors[1].r = parseInt((E.r + (S.r - E.r) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].g = parseInt((E.g + (S.g - E.g) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].b = parseInt((E.b + (S.b - E.b) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].a = parseInt((E.a + (S.a - E.a) * ((c - u.x + u.y) / (2.0 * c))));
        // (-1, 1)
        this._squareColors[2].r = parseInt((E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].g = parseInt((E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].b = parseInt((E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].a = parseInt((E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0 * c))));
        // (1, 1)
        this._squareColors[3].r = parseInt((E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].g = parseInt((E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].b = parseInt((E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].a = parseInt((E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0 * c))));
    }
});


/**
 * creates a gradient layer
 * @param {cc.Color3B} start starting color
 * @param {cc.Color3B} end ending color
 * @param {cc.Point|Null} v
 * @return {cc.LayerGradient}
 */
cc.LayerGradient.create = function (start, end, v) {
    var argnum = arguments.length;
    var layer = new cc.LayerGradient();
    switch (argnum) {
        case 2:
            /** Creates a full-screen CCLayer with a gradient between start and end. */
            if (layer && layer.initWithColor(start, end)) {
                return layer;
            }
            return null;
            break;
        case 3:
            /** Creates a full-screen CCLayer with a gradient between start and end in the direction of v. */
            if (layer && layer.initWithColor(start, end, v)) {
                return layer;
            }
            return null;
            break;
        case 0:
            layer.init();
            break;
        default:
            throw "Arguments error ";
            break;
    }
};


/**
 * CCMultipleLayer is a CCLayer with the ability to multiplex it's children.<br/>
 * Features:<br/>
 *  <ul><li>- It supports one or more children</li>
 *  <li>- Only one children will be active a time</li></ul>
 *  @class
 *  @extends cc.Layer
 */
cc.LayerMultiplex = cc.Layer.extend(/** @lends cc.LayerMultiplex# */{
    _enabledLayer:0,
    _layers:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._super();
    },

    /**
     * @param {cc.Layer} layer
     * @deprecated merged with initWithLayers
     * @return {Boolean}
     */
    initWithLayer:function (layer) {
        this._layers = [];
        this._layers.push(layer);
        this._enabledLayer = 0;
        this.addChild(layer);
        return true;
    },

    /**
     * @param {Array} args an array of cc.Layer
     * @return {Boolean}
     */
    initWithLayers:function (args) {
        this._layers = args;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return true;
    },

    /**
     * switches to a certain layer indexed by n.<br/>
     * The current (old) layer will be removed from it's parent with 'cleanup:YES'.
     * @param {Number} n the layer index to switch to
     */
    switchTo:function (n) {
        cc.Assert(n < this._layers.length, "Invalid index in MultiplexLayer switchTo message");

        this.removeChild(this._layers[this._enabledLayer], true);

        this._enabledLayer = n;

        this.addChild(this._layers[n]);
    },

    /** release the current layer and switches to another layer indexed by n.<br/>
     * The current (old) layer will be removed from it's parent with 'cleanup:YES'.
     * @param {Number} n the layer index to switch to
     */
    switchToAndReleaseMe:function (n) {
        cc.Assert(n < this._layers.count(), "Invalid index in MultiplexLayer switchTo message");

        this.removeChild(this._layers[this._enabledLayer], true);

        //[layers replaceObjectAtIndex:_enabledLayer withObject:[NSNull null]];
        this._layers[this._enabledLayer] = null;

        this._enabledLayer = n;

        this.addChild(this._layers[n]);
    }
});


/**
 * creates a cc.LayerMultiplex with one or more layers using a variable argument list.
 * @return {cc.LayerMultiplex|Null}
 * @example
 * // Example
 * var multiLayer = cc.LayerMultiple.create(layer1, layer2, layer3);//any number of layers
 */
cc.LayerMultiplex.create = function (/*Multiple Arguments*/) {
    var multiplexLayer = new cc.LayerMultiplex();
    if (multiplexLayer.initWithLayers(arguments)) {
        return multiplexLayer;
    }
    return null;
};


/**
 * a layer that does not get redraw if not needed, and its always gets placed on the button layer
 * @class
 * @extends cc.Node
 * @example
 * // Example
 * var veryLazy = new cc.LazyLayer();
 * veryLazy.addChild(mySprite);
 */
cc.LazyLayer = cc.Node.extend(/** @lends cc.LazyLayer# */{
    _layerCanvas:null,
    _layerContext:null,
    _isNeedUpdate:false,
    _canvasZOrder:-10,

    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        this.setAnchorPoint(new cc.Point(0, 0));
        //setup html
        this._setupHtml();
    },

    /**
     * @param {Number} zOrder
     */
    setLayerZOrder:function (zOrder) {
        if (zOrder >= 0) {
            throw "LazyLayer zOrder must Less than Zero.Because LazyLayer is a background Layer!";
        }
        this._canvasZOrder = zOrder;
        this._layerCanvas.style.zIndex = this._canvasZOrder;
    },

    /**
     *
     * @return {Number}
     */
    getLayerZOrder:function () {
        return this._canvasZOrder;
    },

    _setupHtml:function () {
        var gameContainer = document.getElementById("Cocos2dGameContainer");
        if (!gameContainer) {
            cc.setupHTML();
            gameContainer = document.getElementById("Cocos2dGameContainer");
        }

        this._layerCanvas = document.createElement("canvas");
        this._layerCanvas.width = cc.canvas.width;
        this._layerCanvas.height = cc.canvas.height;
        this._layerCanvas.id = "lazyCanvas" + Date.now();
        this._layerCanvas.style.zIndex = this._canvasZOrder;
        this._layerCanvas.style.position = "absolute";
        this._layerCanvas.style.top = "0";
        this._layerCanvas.style.left = "0";
        this._layerContext = this._layerCanvas.getContext("2d");
        this._layerContext.fillStyle = "rgba(0,0,0,1)";
        this._layerContext.translate(0, this._layerCanvas.height);
        gameContainer.appendChild(this._layerCanvas);
        var selfPointer = this;
        window.addEventListener("resize", function (event) {
            selfPointer.adjustSizeForCanvas();
        });
    },

    /**
     * make it the same size as canvas, in case canvas resized
     */
    adjustSizeForCanvas:function () {
        this._isNeedUpdate = true;
        this._layerCanvas.width = cc.canvas.width;
        this._layerCanvas.height = cc.canvas.height;
        var xScale = cc.canvas.width / cc.originalCanvasSize.width;
        var yScale = cc.canvas.height / cc.originalCanvasSize.height;
        if (xScale > yScale) {
            xScale = yScale;
        }
        this._layerContext.translate(0, this._layerCanvas.height);
        this._layerContext.scale(xScale, xScale);
    },

    /**
     * same as cc.Node
     * @param {cc.Node} child
     * @param {Number|Null} zOrder
     * @param {Number|Null} tag
     */
    addChild:function (child, zOrder, tag) {
        this._isNeedUpdate = true;
        this._super(child, zOrder, tag);
    },

    /**
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        this._isNeedUpdate = true;
        this._super(child, cleanup);
    },

    /**
     * stuff gets drawn in here
     */
    visit:function () {
        // quick return if not visible
        if (!this._isVisible) {
            return;
        }
        if (!this._isNeedUpdate) {
            return;
        }

        this._isNeedUpdate = false;
        var context = this._layerContext;
        context.save();

        context.clearRect(0, 0, this._layerCanvas.width, -this._layerCanvas.height);

        if (this._grid && this._grid.isActive()) {
            this._grid.beforeDraw();
            this.transformAncestors();
        }

        //this.transform(context);
        if (this._children) {
            // draw children zOrder < 0
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && node._zOrder < 0) {
                    node.visit(context);
                }
            }
        }

        // draw children zOrder >= 0
        if (this._children) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && node._zOrder >= 0) {
                    node.visit(context);
                }
            }
        }

        if (this._grid && this._grid.isActive()) {
            this._grid.afterDraw(this);
        }
        context.restore();
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
        this._isNeedUpdate = true;
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/**
 * A tag constant for identifying fade scenes
 * @constant
 * @type Number
 */
cc.SCENE_FADE = 4208917214;

/**
 * cc.TransitionEaseScene can ease the actions of the scene protocol.
 * @class
 * @extends cc.Class
 */
cc.TransitionEaseScene = cc.Class.extend(/** @lends cc.TransitionEaseScene# */{
    /**
     * returns the Ease action that will be performed on a linear action.
     */
    easeActionWithAction:function () {
    }
});

/**
 * horizontal orientation Type where the Left is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_LEFT_OVER = 0;
/**
 * horizontal orientation type where the Right is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_RIGHT_OVER = 1;
/**
 * vertical orientation type where the Up is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_UP_OVER = 0;
/**
 * vertical orientation type where the Bottom is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_DOWN_OVER = 1;

/**
 * @class
 * @extends cc.Scene
 */
cc.TransitionScene = cc.Scene.extend(/** @lends cc.TransitionScene# */{
    _inScene:null,
    _outScene:null,
    _duration:null,
    _isInSceneOnTop:false,
    _isSendCleanupToScene:false,

    //private
    _setNewScene:function (dt) {
        // [self unschedule:_cmd];
        // "_cmd" is a local variable automatically defined in a method
        // that contains the selector for the method
        this.unschedule(this._setNewScene);
        var director = cc.Director.sharedDirector();
        // Before replacing, save the "send cleanup to scene"
        this._isSendCleanupToScene = director.isSendCleanupToScene();
        director.replaceScene(this._inScene);

        // enable events while transitions
        cc.TouchDispatcher.sharedDispatcher().setDispatchEvents(true);
        // issue #267
        this._outScene.setIsVisible(true);
    },

    //protected
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },

    /**
     * stuff gets drawn here
     */
    draw:function () {
        this._super();

        if (this._isInSceneOnTop) {
            this._outScene.visit();
            this._inScene.visit();
        } else {
            this._inScene.visit();
            this._outScene.visit();
        }
    },

    /**
     * custom onEnter
     */
    onEnter:function () {
        this._super();
        this._inScene.onEnter();
    },

    /**
     * custom onExit
     */
    onExit:function () {
        this._super();
        this._outScene.onExit();

        // inScene should not receive the onExit callback
        // only the onEnterTransitionDidFinish
        this._inScene.onEnterTransitionDidFinish();
    },

    /**
     * custom cleanup
     */
    cleanup:function () {
        this._super();

        if (this._isSendCleanupToScene)
            this._outScene.cleanup();
    },

    /**
     * initializes a transition with duration and incoming scene
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene a scene to transit to
     * @return {Boolean} return false if error
     */
    initWithDuration:function (t, scene) {
        cc.Assert(scene != null, "CCTransitionScene.initWithDuration() Argument scene must be non-nil");

        if (this.init()) {
            this._duration = t;
            this.setAnchorPoint(cc.ccp(0, 0));
            this.setPosition(cc.ccp(0, 0));
            // retain
            this._inScene = scene;
            this._outScene = cc.Director.sharedDirector().getRunningScene();

            cc.Assert(this._inScene != this._outScene, "CCTransitionScene.initWithDuration() Incoming scene must be different from the outgoing scene");

            // disable events while transitions
            cc.TouchDispatcher.sharedDispatcher().setDispatchEvents(false);
            this._sceneOrder();

            return true;
        } else {
            return false;
        }
    },

    /**
     * called after the transition finishes
     */
    finish:function () {
        // clean up
        this._inScene.setIsVisible(true);
        this._inScene.setPosition(cc.ccp(0, 0));
        this._inScene.setScale(1.0);
        this._inScene.setRotation(0.0);
        this._inScene.getCamera().restore();

        this._outScene.setIsVisible(false);
        this._outScene.setPosition(cc.ccp(0, 0));
        this._outScene.setScale(1.0);
        this._outScene.setRotation(0.0);
        this._outScene.getCamera().restore();

        //[self schedule:@selector(setNewScene:) interval:0];
        this.schedule(this._setNewScene, 0);
    },

    /**
     * set hide the out scene and show in scene
     */
    hideOutShowIn:function () {
        this._inScene.setIsVisible(true);
        this._outScene.setIsVisible(false);
    }
});
/**
 * creates a base transition with duration and incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene the scene to transit with
 * @return {cc.TransitionScene|Null}
 */
cc.TransitionScene.create = function (t, scene) {
    var tempScene = new cc.TransitionScene();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * A cc.Transition that supports orientation like.<br/>
 * Possible orientation: LeftOver, RightOver, UpOver, DownOver<br/>
 * useful for when you want to make a transition happen between 2 orientations
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSceneOriented = cc.TransitionScene.extend(/** @lends cc.TransitionSceneOriented# */{
    _orientation:0,

    /**
     * initialize the transition
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} orientation
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, orientation) {
        if (this._super(t, scene)) {
            this._orientation = orientation;
        }
        return true;
    }
});

/**
 * creates a base transition with duration and incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} orientation
 * @return {cc.TransitionSceneOriented}
 * @example
 * // Example
 * var goHorizontal = cc.TransitionSceneOriented.create(0.5, thisScene, cc.ORIENTATION_LEFT_OVER)
 */
cc.TransitionSceneOriented.create = function (t, scene, orientation) {
    var tempScene = new cc.TransitionSceneOriented();
    tempScene.initWithDuration(t, scene, orientation);

    return tempScene;
};

/**
 *  Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionRotoZoom = cc.TransitionScene.extend(/** @lends cc.TransitionRotoZoom# */{
    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * Custom On Enter callback
     */
    onEnter:function () {
        this._super();

        this._inScene.setScale(0.001);
        this._outScene.setScale(1.0);

        this._inScene.setAnchorPoint(cc.ccp(0.5, 0.5));
        this._outScene.setAnchorPoint(cc.ccp(0.5, 0.5));

        var rotozoom = cc.Sequence.create(
            cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.001),
                cc.RotateBy.create(this._duration / 2, 360 * 2), null),
            cc.DelayTime.create(this._duration / 2), null);

        this._outScene.runAction(rotozoom);
        this._inScene.runAction(
            cc.Sequence.create(rotozoom.reverse(),
                cc.CallFunc.create(this, this.finish), null));
    }
});

/**
 * Creates a Transtion rotation and zoom
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene the scene to work with
 * @return {cc.TransitionRotoZoom}
 * @example
 * // Example
 * var RotoZoomTrans = cc.TransitionRotoZoom.create(2, nextScene);
 */
cc.TransitionRotoZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionRotoZoom();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Zoom out and jump the outgoing scene, and then jump and zoom in the incoming
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionJumpZoom = cc.TransitionScene.extend(/** @lends cc.TransitionJumpZoom# */{
    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        var s = cc.Director.sharedDirector().getWinSize();

        this._inScene.setScale(0.5);
        this._inScene.setPosition(cc.ccp(s.width, 0));
        this._inScene.setAnchorPoint(cc.ccp(0.5, 0.5));
        this._outScene.setAnchorPoint(cc.ccp(0.5, 0.5));

        //TODO
        var jump = cc.JumpBy.create(this._duration / 4, cc.ccp(-s.width, 0), s.width / 4, 2);
        var scaleIn = cc.ScaleTo.create(this._duration / 4, 1.0);
        var scaleOut = cc.ScaleTo.create(this._duration / 4, 0.5);

        var jumpZoomOut = cc.Sequence.create(scaleOut, jump, null);
        var jumpZoomIn = cc.Sequence.create(jump, scaleIn, null);

        var delay = cc.DelayTime.create(this._duration / 2);
        this._outScene.runAction(jumpZoomOut);
        this._inScene.runAction(cc.Sequence.create(delay, jumpZoomIn,
            cc.CallFunc.create(this, this.finish),
            null));
    }
});

/**
 * creates a scene transition that zooms then jump across the screen, the same for the incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionJumpZoom}
 */
cc.TransitionJumpZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionJumpZoom();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the left the incoming scene.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionMoveInL = cc.TransitionScene.extend(/** @lends cc.TransitionMoveInL# */{

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();
        this.initScenes();

        var a = this.action();

        this._inScene.runAction(
            cc.Sequence.create
                (
                    this.easeActionWithAction(a),
                    cc.CallFunc.create(this, this.finish),
                    null
                )
        );
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        this._inScene.setPosition(cc.ccp(-cc.Director.sharedDirector().getWinSize().width, 0));
    },

    /**
     * returns the action that will be performed
     */
    action:function () {
        return cc.MoveTo.create(this._duration, cc.ccp(0, 0));
    },

    /**
     * creates an ease action from action
     * @param {cc.ActionInterval} action
     * @return {cc.EaseOut}
     */
    easeActionWithAction:function (action) {
        //TODO need implement
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * creates an action that  Move in from to the left the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInL}
 * @example
 * // Example
 * var MoveInLeft = cc.TransitionMoveInL.create(1, nextScene)
 */
cc.TransitionMoveInL.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the right the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInR = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInR# */{

    /**
     * Init
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(s.width, 0));
    }
});

/**
 * create a scene transition that Move in from to the right the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInR}
 * @example
 * // Example
 * var MoveInRight = cc.TransitionMoveInR.create(1, nextScene)
 */
cc.TransitionMoveInR.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the top the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInT = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInT# */{

    /**
     * init
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(s.height, 0));
    }
});

/**
 * Move in from to the top the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInT}
 * @example
 * // Example
 * var MoveInTop = cc.TransitionMoveInT.create(1, nextScene)
 */
cc.TransitionMoveInT.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInT();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Move in from to the bottom the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInB = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInB# */{

    /**
     * init
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(0, -s.height));
    }
});

/**
 * create a scene transition that Move in from to the bottom the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInB}
 * @example
 * // Example
 * var MoveinB = cc.TransitionMoveInB.create(1, nextScene)
 */
cc.TransitionMoveInB.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInB();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * The adjust factor is needed to prevent issue #442<br/>
 * One solution is to use DONT_RENDER_IN_SUBPIXELS images, but NO<br/>
 * The other issue is that in some transitions (and I don't know why)<br/>
 * the order should be reversed (In in top of Out or vice-versa).
 * @constant
 * @type Number
 */
cc.ADJUST_FACTOR = 0.5;

/**
 * a transition that a new scene is slided from left
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSlideInL = cc.TransitionScene.extend(/** @lends cc.TransitionSlideInL# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        this.initScenes();

        var inA = this.action();
        var outA = this.action();

        var inAction = this.easeActionWithAction(inA);
        var outAction = cc.Sequence.create
            (
                this.easeActionWithAction(outA),
                cc.CallFunc.create(this, this.finish),
                null
            );
        this._inScene.runAction(inAction);
        this._outScene.runAction(outAction);
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(-(s.width - cc.ADJUST_FACTOR), 0));
    },
    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        return cc.MoveBy.create(this._duration, cc.ccp(s.width - cc.ADJUST_FACTOR, 0));
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {*}
     */
    easeActionWithAction:function (action) {
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * create a transition that a new scene is slided from left
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInL}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInL.create(1.5, nextScene)
 */
cc.TransitionSlideInL.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Slide in the incoming scene from the right border.
 * @class
 * @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInR = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInR# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },
    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(s.width - cc.ADJUST_FACTOR, 0));
    },
    /**
     *  returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        return cc.MoveBy.create(this._duration, cc.ccp(-(s.width - cc.ADJUST_FACTOR), 0));
    }
});

/**
 * create Slide in the incoming scene from the right border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInR}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInR.create(1.5, nextScene)
 */
cc.TransitionSlideInR.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Slide in the incoming scene from the bottom border.
 * @class
 * @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInB = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInB# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(0, s.height - cc.ADJUST_FACTOR));
    },

    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        return cc.MoveBy.create(this._duration, cc.ccp(0, -(s.height - cc.ADJUST_FACTOR)));
    }
});

/**
 * create a Slide in the incoming scene from the bottom border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInB}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInB.create(1.5, nextScene)
 */
cc.TransitionSlideInB.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInB();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Slide in the incoming scene from the top border.
 *  @class
 *  @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInT = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInT# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        this._inScene.setPosition(cc.ccp(0, -(s.height - cc.ADJUST_FACTOR)));
    },

    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.sharedDirector().getWinSize();
        return cc.MoveBy.create(this._duration, cc.ccp(0, s.height - cc.ADJUST_FACTOR));
    }
});

/**
 * create a Slide in the incoming scene from the top border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInT}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInT.create(1.5, nextScene)
 */
cc.TransitionSlideInT.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInT();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Shrink the outgoing scene while grow the incoming scene
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionShrinkGrow = cc.TransitionScene.extend(/** @lends cc.TransitionShrinkGrow# */{

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        this._inScene.setScale(0.001);
        this._outScene.setScale(1.0);

        this._inScene.setAnchorPoint(cc.ccp(2 / 3.0, 0.5));
        this._outScene.setAnchorPoint(cc.ccp(1 / 3.0, 0.5));

        var scaleOut = cc.ScaleTo.create(this._duration, 0.01);
        var scaleIn = cc.ScaleTo.create(this._duration, 1.0);

        this._inScene.runAction(this.easeActionWithAction(scaleIn));
        this._outScene.runAction(
            cc.Sequence.create(
                this.easeActionWithAction(scaleOut),
                cc.CallFunc.create(this, this.finish),
                null
            )
        );
    },

    /**
     * @param action
     * @return {cc.EaseOut}
     */
    easeActionWithAction:function (action) {
        //TODO
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * Shrink the outgoing scene while grow the incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionShrinkGrow}
 * @example
 * // Example
 * var myTransition = cc.TransitionShrinkGrow.create(1.5, nextScene)
 */
cc.TransitionShrinkGrow.create = function (t, scene) {
    var tempScene = new cc.TransitionShrinkGrow();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Flips the screen horizontally.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipX = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipX# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                //TODO
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
                cc.CallFunc.create(this, this.finish),
                null
            );

        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen horizontally.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipX}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipX.create(1.5, nextScene) //default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionFlipX.create(1.5, nextScene, cc.ORIENTATION_UP_OVER)
 */
cc.TransitionFlipX.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionFlipX();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipY = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipY# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_UP_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
                cc.CallFunc.create(this, this.finish),
                null
            );
        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipY}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipY.create(1.5, nextScene)//default is cc.ORIENTATION_UP_OVER
 *
 * //OR
 * var myTransition = cc.TransitionFlipY.create(1.5, nextScene, cc.ORIENTATION_RIGHT_OVER)
 */
cc.TransitionFlipY.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_UP_OVER;

    var tempScene = new cc.TransitionFlipY();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen half horizontally and half vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipAngular# */{
    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
                cc.CallFunc.create(this, this.finish),
                null
            );
        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen half horizontally and half vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipAngular}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipAngular.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //or
 * var myTransition = cc.TransitionFlipAngular.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionFlipAngular.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionFlipAngular();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 *  Flips the screen horizontally doing a zoom out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipX# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }
        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
                        cc.ScaleTo.create(this._duration / 2, 1),
                        cc.Show.create(),
                        null
                    ),
                cc.CallFunc.create(this, this.finish),
                null
            );
        outA = cc.Sequence.create
            (
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
                        cc.ScaleTo.create(this._duration / 2, 0.5),
                        null
                    ),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen horizontally doing a zoom out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipX}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipX.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipX.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipX.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionZoomFlipX();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen vertically doing a little zooming out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipY# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_UP_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
                        cc.ScaleTo.create(this._duration / 2, 1),
                        cc.Show.create(),
                        null
                    ),
                cc.CallFunc.create(this, this.finish),
                null
            );

        outA = cc.Sequence.create
            (
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
                        cc.ScaleTo.create(this._duration / 2, 0.5),
                        null
                    ),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen vertically doing a little zooming out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipY}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipY.create(1.5, nextScene)//default is cc.ORIENTATION_UP_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipY.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipY.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_UP_OVER;

    var tempScene = new cc.TransitionZoomFlipY();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 *  Flips the screen half horizontally and half vertically doing a little zooming out/in.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipAngular# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setIsVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
                        cc.ScaleTo.create(this._duration / 2, 1),
                        cc.Show.create(),
                        null
                    ),
                cc.Show.create(),
                cc.CallFunc.create(this, this.finish),
                null
            );
        outA = cc.Sequence.create
            (
                cc.Spawn.create
                    (
                        cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0),
                        cc.ScaleTo.create(this._duration / 2, 0.5),
                        null
                    ),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2),
                null
            );

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 *  Flips the screen half horizontally and half vertically doing a little zooming out/in.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipAngular}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipAngular.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipAngular.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipAngular.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionZoomFlipAngular();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Fade out the outgoing scene and then fade in the incoming scene.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionFade = cc.TransitionScene.extend(/** @lends cc.TransitionFade# */{
    _color:new cc.Color3B(),

    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var l = cc.LayerColor.create(this._color);
        this._inScene.setIsVisible(false);

        this.addChild(l, 2, cc.SCENE_FADE);
        var f = this.getChildByTag(cc.SCENE_FADE);

        //TODO
        var a = cc.Sequence.create
            (
                cc.FadeIn.create(this._duration / 2),
                cc.CallFunc.create(this, this.hideOutShowIn), //CCCallFunc.actionWithTarget:self selector:@selector(hideOutShowIn)],
                cc.FadeOut.create(this._duration / 2),
                cc.CallFunc.create(this, this.finish), //:self selector:@selector(finish)],
                null
            );
        f.runAction(a);
    },

    /**
     * custom on exit
     */
    onExit:function () {
        this._super();
        this.removeChildByTag(cc.SCENE_FADE, false);
    },

    /**
     * initializes the transition with a duration and with an RGB color
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {cc.Color3B} color
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, color) {
        if ((color == 'undefined') || (color == null)) {
            color = cc.BLACK();
        }

        if (this._super(t, scene)) {
            this._color.r = color.r;
            this._color.g = color.g;
            this._color.b = color.b;
            this._color.a = 0;
        }
        return true;
    }
});


/**
 * Fade out the outgoing scene and then fade in the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.Color3B} color
 * @return {cc.TransitionFade}
 * @example
 * // Example
 * var myTransition = cc.TransitionFade.create(1.5, nextScene, cc.ccc3(255,0,0))//fade to red
 */
cc.TransitionFade.create = function (t, scene, color) {
    var transition = new cc.TransitionFade();
    transition.initWithDuration(t, scene, color);

    return transition;
};

/**
 * Cross fades two scenes using the cc.RenderTexture object.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionCrossFade = cc.TransitionScene.extend(/** @lends cc.TransitionCrossFade# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        // create a transparent color layer
        // in which we are going to add our rendertextures
        var color = new cc.Color4B(0, 0, 0, 0);
        var size = cc.Director.sharedDirector().getWinSize();
        var layer = cc.LayerColor.create(color);

        // create the first render texture for inScene
        var inTexture = cc.RenderTexture.create(size.width, size.height);

        if (null == inTexture) {
            return;
        }

        inTexture.getSprite().setAnchorPoint(cc.ccp(0.5, 0.5));
        inTexture.setPosition(cc.ccp(size.width / 2, size.height / 2));
        inTexture.setAnchorPoint(cc.ccp(0.5, 0.5));

        // render inScene to its texturebuffer
        inTexture.begin();
        this._inScene.visit();
        inTexture.end();

        // create the second render texture for outScene
        var outTexture = cc.RenderTexture.create(size.width, size.height);
        outTexture.getSprite().setAnchorPoint(cc.ccp(0.5, 0.5));
        outTexture.setPosition(cc.ccp(size.width / 2, size.height / 2));
        outTexture.setAnchorPoint(cc.ccp(0.5, 0.5));

        // render outScene to its texturebuffer
        outTexture.begin();
        this._outScene.visit();
        outTexture.end();

        // create blend functions

        var blend1 = new cc.BlendFunc(cc.GL_ONE, cc.GL_ONE); // inScene will lay on background and will not be used with alpha
        var blend2 = cc.BlendFunc(cc.GL_SRC_ALPHA, cc.GL_ONE_MINUS_SRC_ALPHA); // we are going to blend outScene via alpha

        // set blendfunctions
        inTexture.getSprite().setBlendFunc(blend1);
        outTexture.getSprite().setBlendFunc(blend2);

        // add render textures to the layer
        layer.addChild(inTexture);
        layer.addChild(outTexture);

        // initial opacity:
        inTexture.getSprite().setOpacity(255);
        outTexture.getSprite().setOpacity(255);

        // create the blend action
        //TODO
        var layerAction = cc.Sequence.create
            (
                cc.FadeTo.create(this._duration, 0),
                cc.CallFunc.create(this, this.hideOutShowIn),
                cc.CallFunc.create(this, this.finish),
                null
            );

        // run the blend action
        outTexture.getSprite().runAction(layerAction);

        // add the layer (which contains our two rendertextures) to the scene
        this.addChild(layer, 2, cc.SCENE_FADE);
    },

    /**
     * custom on exit
     */
    onExit:function () {
        this.removeChildByTag(cc.SCENE_FADE, false);
        this._super();
    },

    /**
     * overide draw
     */
    draw:function () {
        // override draw since both scenes (textures) are rendered in 1 scene
    }
});

/**
 * Cross fades two scenes using the cc.RenderTexture object.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionCrossFade}
 * @example
 * // Example
 * var myTransition = cc.TransitionCrossFade.create(1.5, nextScene)
 */
cc.TransitionCrossFade.create = function (t, scene) {
    var Transition = new cc.TransitionCrossFade();
    Transition.initWithDuration(t, scene);
    return Transition;
};

/**
 *  Turn off the tiles of the outgoing scene in random order
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionTurnOffTiles = cc.TransitionScene.extend(/** @lends cc.TransitionTurnOffTiles# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        var s = cc.Director.sharedDirector().getWinSize();
        var aspect = s.width / s.height;
        var x = 12 * aspect;
        var y = 12;
        var toff = cc.TurnOffTiles.create(cc.ccg(x, y), this._duration);
        var action = this.easeActionWithAction(toff);
        //TODO
        this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this, this.finish), cc.StopGrid.create(), null));
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.ActionInterval}
     */
    easeActionWithAction:function (action) {
        return action;
    }
});

/**
 *  Turn off the tiles of the outgoing scene in random order
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionTurnOffTiles}
 * @example
 * // Example
 * var myTransition = cc.TransitionTurnOffTiles.create(1.5, nextScene)
 */
cc.TransitionTurnOffTiles.create = function (t, scene) {
    var tempScene = new cc.TransitionTurnOffTiles();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  The odd columns goes upwards while the even columns goes downwards.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSplitCols = cc.TransitionScene.extend(/** @lends cc.TransitionSplitCols# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        this._inScene.setIsVisible(false);

        var split = this.action();
        //TODO
        var seq = cc.Sequence.create
            (
                split,
                cc.CallFunc.create(this, this.hideOutShowIn),
                split.reverse(),
                null
            );

        this.runAction
            (
                cc.Sequence.create
                    (
                        this.easeActionWithAction(seq),
                        cc.CallFunc.create(this, this.finish),
                        cc.StopGrid.create(),
                        null
                    )
            );
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.EaseInOut}
     */
    easeActionWithAction:function (action) {
        //TODO
        return cc.EaseInOut.create(action, 3.0);
    },

    /**
     * @return {*}
     */
    action:function () {
        //TODO
        return cc.SplitCols.actionWithCols(3, this._duration / 2.0);
    }
});

/**
 * The odd columns goes upwards while the even columns goes downwards.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSplitCols}
 * @example
 * // Example
 * var myTransition = cc.TransitionSplitCols.create(1.5, nextScene)
 */
cc.TransitionSplitCols.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitCols();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  The odd rows goes to the left while the even rows goes to the right.
 * @class
 * @extends cc.TransitionSplitCols
 */
cc.TransitionSplitRows = cc.TransitionSplitCols.extend(/** @lends cc.TransitionSplitRows# */{

    /**
     * @return {*}
     */
    action:function () {
        return cc.SplitRows.actionWithRows(3, this._duration / 2.0);
    }
});

/**
 * The odd rows goes to the left while the even rows goes to the right.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSplitRows}
 * @example
 * // Example
 * var myTransition = cc.TransitionSplitRows.create(1.5, nextScene)
 */
cc.TransitionSplitRows.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitRows();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionFadeTR = cc.TransitionScene.extend(/** @lends cc.TransitionFadeTR# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        var s = cc.Director.sharedDirector().getWinSize();
        var aspect = s.width / s.height;
        var x = (12 * aspect);
        var y = 12;

        var action = this.actionWithSize(cc.ccg(x, y));

        this._outScene.runAction
            (
                cc.Sequence.create
                    (
                        this.easeActionWithAction(action),
                        cc.CallFunc.create(this, this.finish),
                        cc.StopGrid.create(),
                        null
                    )
            );
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.ActionInterval}
     */
    easeActionWithAction:function (action) {
        return action;
    },

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutTRTiles.create(size, this._duration);
    }
});

/**
 *  Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeTR}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeTR.create(1.5, nextScene)
 */
cc.TransitionFadeTR.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeTR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeBL = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeBL# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutBLTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeBL}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeBL.create(1.5, nextScene)
 */
cc.TransitionFadeBL.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeBL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeUp = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeUp# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutUpTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeUp}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeUp.create(1.5, nextScene)
 */
cc.TransitionFadeUp.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeUp();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Fade the tiles of the outgoing scene from the top to the bottom.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeDown = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeDown# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutDownTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top to the bottom.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeDown}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeDown.create(1.5, nextScene)
 */
cc.TransitionFadeDown.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeDown();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * tag for scene redial
 * @constant
 * @type Number
 */
cc.SCENE_RADIAL = 0xc001;

/**
 * A counter colock-wise radial transition to the next scene
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionRadialCCW = cc.TransitionScene.extend(/** @lends cc.TransitionRadialCCW# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        // create a transparent color layer
        // in which we are going to add our rendertextures
        var size = cc.Director.sharedDirector().getWinSize();

        // create the second render texture for outScene
        var outTexture = cc.RenderTexture.create(size.width, size.height);

        if (null == outTexture) {
            return;
        }

        outTexture.getSprite().setAnchorPoint(cc.ccp(0.5, 0.5));
        outTexture.setPosition(cc.ccp(size.width / 2, size.height / 2));
        outTexture.setAnchorPoint(cc.ccp(0.5, 0.5));

        // render outScene to its texturebuffer
        outTexture.clear(0, 0, 0, 1);
        outTexture.begin();
        this._outScene.visit();
        outTexture.end();

        //	Since we've passed the outScene to the texture we don't need it.
        this.hideOutShowIn();

        //	We need the texture in RenderTexture.
        var outNode = cc.ProgressTimer.createWithTexture(outTexture.getSprite().getTexture());
        // but it's flipped upside down so we flip the sprite
        outNode.getSprite().setFlipY(true);
        //	Return the radial type that we want to use
        outNode.setType(_radialType());
        outNode.setPercentage(100);
        outNode.setPosition(cc.ccp(size.width / 2, size.height / 2));
        outNode.setAnchorPoint(cc.ccp(0.5, 0.5));

        // create the blend action
        var layerAction = cc.Sequence.create
            (
                cc.ProgressFromTo.create(this._duration, 100.0, 0.0),
                cc.CallFunc.create(this, cc.TransitionScene.finish),
                null
            );
        // run the blend action
        outNode.runAction(layerAction);

        // add the layer (which contains our two rendertextures) to the scene
        this.addChild(outNode, 2, cc.SCENE_RADIAL);
    },

    /**
     * custom on exit
     */
    onExit:function () {
// remove our layer and release all containing objects
        this.removeChildByTag(cc.SCENE_RADIAL, false);
        this._super();
    },
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },
    _radialType:function () {
        return cc.CCPROGRESS_TIMER_RADIAL_CCW;
    }
});

/**
 * A counter colock-wise radial transition to the next scene
 * @class
 * @extends cc.TransitionRadialCCW
 */
cc.TransitionRadialCW = cc.TransitionRadialCCW.extend(/** @lends cc.TransitionRadialCW# */{
    _radialType:function () {
        return cc.CCPROGRESS_TIMER_TYPE_RADIAL_CW;
    }
});

/**
 * create a counter colock-wise radial transition to the next scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionRadialCCW}
 * @example
 * // Example
 * var myTransition = cc.TransitionRadialCCW.create(1.5, nextScene)//Redial that turns counter clock wise (left)
 */
cc.TransitionRadialCCW.create = function (t, scene) {
    var tmpScene = new cc.TransitionRadialCCW();
    tmpScene.initWithDuration(t, scene);
    return tmpScene;
};

/**
 * create a colock-wise radial transition to the next scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionRadialCW}
 * @example
 * // Example
 * var myTransition = cc.TransitionRadialCW.create(1.5, nextScene)//Redial that turns clock wise (right)
 */
cc.TransitionRadialCW.create = function (t, scene) {
    var tmpScene = new cc.TransitionRadialCW();
    tmpScene.initWithDuration(t, scene);
    return tmpScene;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 *<p> A transition which peels back the bottom right hand corner of a scene<br/>
 * to transition to the scene beneath it simulating a page turn.<br/></p>
 *
 * <p>This uses a 3DAction so it's strongly recommended that depth buffering<br/>
 * is turned on in cc.Director using:</p>
 *
 * <p>cc.Director.sharedDirector().setDepthBufferFormat(kDepthBuffer16);</p>
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionPageTurn = cc.TransitionScene.extend(/** @lends cc.TransitionPageTurn# */{
    /**
     * @type Boolean
     */
    _back:true,

    /**
     * Creates a base transition with duration and incoming scene.<br/>
     * If back is true then the effect is reversed to appear as if the incoming<br/>
     * scene is being turned from left over the outgoing scene.
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {Boolean} backwards
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, backwards) {
        // XXX: needed before [super init]
        this._back = backwards;

        if (this._super(t, scene)) {
            // do something
        }
        return true;
    },

    /**
     * @param {cc.GridSiz} vector
     * @return {cc.ReverseTime|cc.TransitionScene}
     */
    actionWithSize:function (vector) {
        if (this._back) {
            // Get hold of the PageTurn3DAction
            return cc.ReverseTime.create(this._super(vector, this._duration));
        } else {
            // Get hold of the PageTurn3DAction
            return this._super(vector, this._duration);
        }
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        var s = cc.Director.sharedDirector().getWinSize();
        var x, y;
        if (s.width > s.height) {
            x = 16;
            y = 12;
        } else {
            x = 12;
            y = 16;
        }

        var action = this.actionWithSize(cc.ccg(x, y));

        if (!this._back) {
            this._outScene.runAction(cc.Sequence.create(action,
                cc.CallFunc.create(this, cc.TransitionScene.finish),
                cc.StopGrid.create(),
                null));
        } else {
            // to prevent initial flicker
            this._inScene.setIsVisible(false);
            this._inScene.runAction(cc.Sequence.create(cc.Show.create(),
                action,
                cc.CallFunc.create(this, cc.TransitionScene.finish),
                cc.StopGrid.create(),
                null));
        }
    },
    _sceneOrder:function () {
        this.isInSceneOnTop = this._back;
    }
});

/**
 * Creates a base transition with duration and incoming scene.<br/>
 * If back is true then the effect is reversed to appear as if the incoming<br/>
 * scene is being turned from left over the outgoing scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {Boolean} backwards
 * @return {cc.TransitionPageTurn}
 * @example
 * // Example
 * var myTransition = cc.TransitionPageTurn.create(1.5, nextScene, true)//true means backwards
 */
cc.TransitionPageTurn.create = function (t, scene, backwards) {
    var transition = new cc.TransitionPageTurn();
    transition.initWithDuration(t, scene, backwards);
    return transition;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.Sprite invalid index on the cc.SpriteBatchode
 * @constant
 * @type Number
 */
cc.SPRITE_INDEX_NOT_INITIALIZED = "0xffffffff";

/**
 * generate texture's cache for texture tint
 * @function
 * @param {HTMLImageElement} texture
 * @return {Array}
 */
cc.generateTextureCacheForColor = function (texture) {
    var w = texture.width;
    var h = texture.height;
    var textureCache = [];

    var canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;

    var ctx = canvas.getContext("2d");
    ctx.drawImage(texture, 0, 0);

    var tempCanvas = document.createElement("canvas");
    tempCanvas.width = w;
    tempCanvas.height = h;
    var tempCtx = tempCanvas.getContext('2d');

    var pixels = ctx.getImageData(0, 0, w, h).data;

    for (var rgbI = 0; rgbI < 4; rgbI++) {
        var cacheCanvas = document.createElement("canvas");
        cacheCanvas.width = w;
        cacheCanvas.height = h;
        var cacheCtx = cacheCanvas.getContext('2d');

        tempCtx.drawImage(texture, 0, 0);
        var to = tempCtx.getImageData(0, 0, w, h);
        var toData = to.data;

        for (var i = 0; i < pixels.length; i += 4) {
            toData[i  ] = (rgbI === 0) ? pixels[i  ] : 0;
            toData[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
            toData[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
            toData[i + 3] = pixels[i + 3];
        }
        cacheCtx.putImageData(to, 0, 0);
        textureCache.push(cacheCanvas);
    }
    return textureCache;
};

/**
 * generate tinted texture
 * @function
 * @param {HTMLImageElement} texture
 * @param {Array} tintedImgCache
 * @param {cc.Color3B|cc.Color4F} color
 * @param {cc.Rect} rect
 * @return {HTMLCanvasElement}
 */
cc.generateTintImage = function (texture, tintedImgCache, color, rect) {
    if (!rect) {
        rect = new cc.Rect();
        rect.size = new cc.Size(texture.width, texture.height);
    }
    var selColor;
    if (color instanceof cc.Color4F) {
        selColor = cc.ccc3(color.r * 255, color.g * 255, color.b * 255);
    } else {
        selColor = color;
    }
    var buff = document.createElement("canvas");
    buff.width = rect.size.width;
    buff.height = rect.size.height;
    var ctx = buff.getContext("2d");
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'copy';
    ctx.drawImage(tintedImgCache[3], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);

    ctx.globalCompositeOperation = 'lighter';
    if (selColor.r > 0) {
        ctx.globalAlpha = selColor.r / 255.0;
        ctx.drawImage(tintedImgCache[0], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    if (selColor.g > 0) {
        ctx.globalAlpha = selColor.g / 255.0;
        ctx.drawImage(tintedImgCache[1], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    if (selColor.b > 0) {
        ctx.globalAlpha = selColor.b / 255.0;
        ctx.drawImage(tintedImgCache[2], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    return buff;
};

/**
 * <p>Whether or not an cc.Sprite will rotate, scale or translate with it's parent.  <br/>
 * Useful in health bars, when you want that the health bar translates with it's parent but you don't <br/>
 * want it to rotate with its parent.</p>
 */

/**
 * Translate with it's parent
 * @constant
 * @type Number
 */
cc.HONOR_PARENT_TRANSFORM_TRANSLATE = 1 << 0;

/**
 * Rotate with it's parent
 * @constant
 * @type Number
 */
cc.HONOR_PARENT_TRANSFORM_ROTATE = 1 << 1;

/**
 * Scale with it's parent
 * @constant
 * @type Number
 */
cc.HONOR_PARENT_TRANSFORM_SCALE = 1 << 2;

/**
 * Skew with it's parent
 * @constant
 * @type Number
 */
cc.HONOR_PARENT_TRANSFORM_SKEW = 1 << 3;

/**
 * All possible transformation enabled. Default value.
 * @constant
 * @type Number
 */
cc.HONOR_PARENT_TRANSFORM_ALL = cc.HONOR_PARENT_TRANSFORM_TRANSLATE | cc.HONOR_PARENT_TRANSFORM_ROTATE | cc.HONOR_PARENT_TRANSFORM_SCALE | cc.HONOR_PARENT_TRANSFORM_SKEW;

/**
 * a Values object for transform
 * @Class
 * @Construct
 * @param {cc.Point} pos position x and y
 * @param {cc.Point} scale scale x and y
 * @param {Number} rotation
 * @param {cc.Point} skew skew x and y
 * @param {cc.Point} ap anchor point in pixels
 * @param {Boolean} visible
 */
cc.TransformValues = function(pos, scale, rotation, skew, ap, visible) {
    this.pos = pos;		// position x and y
    this.scale = scale;		// scale x and y
    this.rotation = rotation;
    this.skew = skew;		// skew x and y
    this.ap = ap;			// anchor point in pixels
    this.visible = visible;
}

cc.RENDER_IN_SUBPIXEL = function (A) {
    if (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL) {
        return A;
    } else {
        return parseInt(A);
    }
};

/**
 * <p>cc.Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ) <br/>
 *
 * cc.Sprite can be created with an image, or with a sub-rectangle of an image.  <br/>
 *
 * If the parent or any of its ancestors is a cc.SpriteBatchNode then the following features/limitations are valid   <br/>
 *    - Features when the parent is a cc.BatchNode: <br/>
 *        - MUCH faster rendering, specially if the cc.SpriteBatchNode has many children. All the children will be drawn in a single batch.  <br/>
 *
 *    - Limitations   <br/>
 *        - Camera is not supported yet (eg: CCOrbitCamera action doesn't work)  <br/>
 *        - GridBase actions are not supported (eg: CCLens, CCRipple, CCTwirl) <br/>
 *        - The Alias/Antialias property belongs to CCSpriteBatchNode, so you can't individually set the aliased property.  <br/>
 *        - The Blending function property belongs to CCSpriteBatchNode, so you can't individually set the blending function property. <br/>
 *        - Parallax scroller is not supported, but can be simulated with a "proxy" sprite.        <br/>
 *
 *  If the parent is an standard cc.Node, then cc.Sprite behaves like any other cc.Node:      <br/>
 *    - It supports blending functions    <br/>
 *    - It supports aliasing / antialiasing    <br/>
 *    - But the rendering will be slower: 1 draw per children.   <br/>
 *
 * The default anchorPoint in cc.Sprite is (0.5, 0.5). </p>
 * @class
 * @extends cc.Node
 *
 * @example
 * var aSprite = new cc.Sprite();
 * aSprite.initWithFile("HelloWorld.png",new cc.Rect(0,0,480,320));
 */
cc.Sprite = cc.Node.extend(/** @lends cc.Sprite# */{
    //
    // Data used when the sprite is rendered using a CCSpriteSheet
    //
    _textureAtlas:null,
    _atlasIndex:0,
    _batchNode:null,
    _honorParentTransform:null,
    _dirty:null,
    _recursiveDirty:null,
    _hasChildren:null,
    //
    // Data used when the sprite is self-rendered
    //
    _blendFunc:new cc.BlendFunc(),
    _texture:new cc.Texture2D(),
    _originalTexture:null,
    //
    // Shared data
    //
    // whether or not it's parent is a cc.SpriteBatchNode
    _usesBatchNode:null,
    // texture
    _rect:new cc.Rect(),
    _rectInPixels:cc.RectZero(),
    _rectRotated:null,

    // Offset Position (used by Zwoptex)
    _offsetPositionInPixels:cc.PointZero(), // absolute
    _unflippedOffsetPositionFromCenter:cc.PointZero(),

    // vertex coords, texture coords and color info
    _quad:cc.V3F_C4B_T2F_QuadZero(),

    // opacity and RGB protocol
    colorUnmodified:null,
    _opacityModifyRGB:null,

    // image is flipped
    _flipX:null,
    _flipY:null,

    _opacity:255,

    /**
     * Constructor
     * @param {String|cc.SpriteFrame|cc.SpriteBatchNode|HTMLImageElement|cc.Texture2D} fileName sprite construct parameter
     */
    ctor:function (fileName) {
        this._super();
        if (fileName) {
            if (typeof(fileName) == "string") {
                var frame = cc.SpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName(fileName);
                this.initWithSpriteFrame(frame);
            } else if (typeof(fileName) == "object") {
                if (fileName instanceof cc.SpriteFrame) {
                    this.initWithSpriteFrame(fileName);
                } else if (fileName instanceof cc.SpriteBatchNode) {
                    if (arguments.length > 1) {
                        var rect = arguments[1];
                        if (rect instanceof cc.Rect) {
                            this.initWithBatchNode(fileName, rect);
                        }
                    }
                } else if ((fileName instanceof HTMLImageElement) || (fileName instanceof HTMLCanvasElement)) {
                    this.initWithTexture(fileName)
                } else if (fileName instanceof cc.Texture2D) {
                    this.initWithTexture(fileName)
                }
            }
        }
    },

    /**
     * whether or not the Sprite needs to be updated in the Atlas
     * @return {Boolean}
     */
    isDirty:function () {
        return this._dirty;
    },

    /**
     * make the Sprite to be updated in the Atlas.
     * @param {Boolean} bDirty
     */
    setDirty:function (bDirty) {
        this._dirty = bDirty;
    },

    /**
     * get the quad (tex coords, vertex coords and color) information
     * @return {cc.V3F_C4B_T2F_Quad}
     */
    getQuad:function () {
        return this._quad;
    },

    /**
     * returns whether or not the texture rectangle is rotated
     * @return {Boolean}
     */
    isTextureRectRotated:function () {
        return this._rectRotated;
    },

    /**
     * Set the index used on the TextureAtlas.
     * @return {Number}
     */
    getAtlasIndex:function () {
        return this._atlasIndex;
    },

    /**
     * Set the index used on the TextureAtlas.
     * @warning Don't modify this value unless you know what you are doing
     * @param {Number} atlasIndex
     */
    setAtlasIndex:function (atlasIndex) {
        this._atlasIndex = atlasIndex;
    },

    /**
     * returns the rect of the cc.Sprite in points
     * @return {cc.Rect}
     */
    getTextureRect:function () {
        return new cc.Rect(this._rect);
    },

    /**
     * whether or not the Sprite is rendered using a cc.SpriteBatchNode
     * @return {Boolean}
     */
    isUsesBatchNode:function () {
        return this._usesBatchNode;
    },

    /**
     * make the Sprite been rendered using a cc.SpriteBatchNode
     * @param {Boolean} usesSpriteBatchNode
     */
    setUsesSpriteBatchNode:function (usesSpriteBatchNode) {
        this._usesBatchNode = usesSpriteBatchNode;
    },

    /**
     * return the TextureAtlas of the cc.Sprite
     * @param {Boolean} pobTextureAtlas
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function (pobTextureAtlas) {
        return this._textureAtlas;
    },

    /**
     * set the TextureAtlas of the cc.Sprite
     * @param {cc.TextureAtlas} textureAtlas
     */
    setTextureAtlas:function (textureAtlas) {
        this._textureAtlas = textureAtlas;
    },

    /**
     * return the SpriteBatchNode of the cc.Sprite
     * @return {cc.SpriteBatchNode}
     */
    getSpriteBatchNode:function () {
        return this._batchNode;
    },

    /**
     * set the SpriteBatchNode of the cc.Sprite
     * @param {cc.SpriteBatchNode} spriteBatchNode
     */
    setSpriteBatchNode:function (spriteBatchNode) {
        this._batchNode = spriteBatchNode;
    },

    /**
     * <p>Return whether or not to transform according to its parent transformations. <br/>
     * Useful for health bars. eg: Don't rotate the health bar, even if the parent rotates.  <br/>
     * IMPORTANT: Only valid if it is rendered using an cc.SpriteSheet.    <p/>
     * @return {Number}
     */
    getHonorParentTransform:function () {
        return this._honorParentTransform;
    },

    /**
     * <p>Set whether or not to transform according to its parent transformations.  <br/>
     * Useful for health bars. eg: Don't rotate the health bar, even if the parent rotates.  <br/>
     * IMPORTANT: Only valid if it is rendered using an cc.SpriteSheet.     <p/>
     * @param {Number} honorParentTransform
     */
    setHonorParentTransform:function (honorParentTransform) {
        this._honorParentTransform = honorParentTransform;
    },

    /**
     * Get offset position of the sprite. Calculated automatically by editors like Zwoptex.
     * @return {cc.Point}
     */
    getOffsetPositionInPixels:function () {
        return new cc.Point(this._offsetPositionInPixels.x, this._offsetPositionInPixels.y);
    },

    /**
     * conforms to cc.TextureProtocol protocol
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * conforms to cc.TextureProtocol protocol
     * @param {cc.BlendFunc} blendFunc
     */
    setBlendFunc:function (blendFunc) {
        this._blendFunc = blendFunc;
    },

    /**
     * Initializes a sprite with an cc.SpriteBatchNode and a rect in points
     * @param {cc.SpriteBatchNode} batchNode
     * @param {cc.Rect} rect
     * @return {Boolean}
     */
    initWithBatchNode:function (batchNode, rect) {
        if (this.initWithTexture(batchNode.getTexture(), rect)) {
            this.useBatchNode(batchNode);
            return true;
        }
        return false;
    },

    /**
     * Initializes a sprite with an cc.SpriteBatchNode and a rect in pixels
     * @param {cc.SpriteBatchNode} batchNode
     * @param {cc.Rect} rect
     * @return {Boolean}
     */
    initWithBatchNodeRectInPixels:function (batchNode, rect) {
        if (this.initWithTexture(batchNode.getTexture())) {
            this.setTextureRectInPixels(rect, false, rect.size);
            this.useBatchNode(batchNode);
            return true;
        }
        return false;
    },

    /**
     * Initializes a sprite
     * @return {Boolean}
     */
    init:function () {
        this._dirty = this._recursiveDirty = false;
        // by default use "Self Render".
        // if the sprite is added to an batchnode, then it will automatically switch to "SpriteSheet Render"
        this.useSelfRender();

        this._opacityModifyRGB = true;
        this._opacity = 255;
        this._color = cc.WHITE();
        this._colorUnmodified = cc.WHITE();

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        // update texture (calls _updateBlendFunc)
        this.setTexture(null);

        this._flipX = this._flipY = false;

        // default transform anchor: center
        this.setAnchorPoint(cc.ccp(0.5, 0.5));

        // zwoptex default values
        this._offsetPositionInPixels = cc.PointZero();

        this._honorParentTransform = cc.HONOR_PARENT_TRANSFORM_ALL;
        this._hasChildren = false;

        // Atlas: Color
        var tmpColor = new cc.Color4B(255, 255, 255, 255);
        this._quad.bl.colors = tmpColor;
        this._quad.br.colors = tmpColor;
        this._quad.tl.colors = tmpColor;
        this._quad.tr.colors = tmpColor;

        // Atlas: Vertex
        // updated in "useSelfRender"
        // Atlas: TexCoords
        this.setTextureRectInPixels(cc.RectZero(), false, cc.SizeZero());

        return true;
    },

    /**
     * Initializes a sprite with a texture and a rect in texture
     * @param {cc.Texture2D|HTMLImageElement|HTMLCanvasElement} texture
     * @param {cc.Rect} rect
     * @return {Boolean}
     * @example
     * var img =cc.TextureCache.sharedTextureCache().addImage("HelloWorld.png");
     * var mySprite = new cc.Sprite();
     * mySprite.initWithTexture(img,new cc.Rect(0,0,480,320));
     */
    initWithTexture:function (texture, rect) {
        var argnum = arguments.length;
        if (argnum == 0)
            throw "Sprite.initWithTexture(): Argument must be non-nil ";

        cc.Assert(texture != null, "");

        if (argnum == 1) {
            rect = new cc.Rect();
            if (texture instanceof cc.Texture2D)
                rect.size = texture.getContentSize();
            else if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement))
                rect.size = new cc.Size(texture.width, texture.height);
        }

        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = texture;
        }
        // IMPORTANT: [self init] and not [super init];
        this.init();
        this.setTexture(texture);
        this.setTextureRect(rect);
        return true;
    },

    /**
     * Initializes a sprite with a texture's filename and a rect in texture
     * @param {String} filename
     * @param {cc.Rect} rect
     * @return {Boolean}
     * @example
     * var mySprite = new cc.Sprite();
     * mySprite.initWithFile("HelloWorld.png",new cc.Rect(0,0,480,320));
     */
    initWithFile:function (filename, rect) {
        var argnum = arguments.length;
        cc.Assert(filename != null, "");
        var texture = cc.TextureCache.sharedTextureCache().textureForKey(filename);
        if (!texture) {
            texture = cc.TextureCache.sharedTextureCache().addImage(filename);
        }
        switch (argnum) {
            case 1:
                /** Initializes an sprite with an image filename.
                 The rect used will be the size of the image.
                 The offset will be (0,0).
                 */
                if (texture) {
                    rect = cc.RectZero();
                    if (cc.renderContextType == cc.CANVAS)
                        rect.size = new cc.Size(texture.width, texture.height);
                    else
                        rect.size = texture.getContentSize();
                    return this.initWithTexture(texture, rect);
                }
                // when load texture failed, it's better to get a "transparent" sprite then a crashed program
                return false;
                break;
            case 2:
                /** Initializes an sprite with an image filename, and a rect.
                 The offset will be (0,0).
                 */
                if (texture) {
                    return this.initWithTexture(texture, rect);
                }
                // when load texture failed, it's better to get a "transparent" sprite then a crashed program
                return false;
                break;
            default:
                throw "initWithFile():Argument must be non-nil ";
                break;
        }
    },

    /**
     * Initializes a sprite with a sprite frame.
     * @param {cc.SpriteFrame} spriteFrame
     * @return {Boolean}
     * @example
     * var spriteFrame = cc.SpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("grossini_dance_01.png");
     * var sprite = new cc.Sprite();
     * sprite.initWithSpriteFrame(spriteFrame);
     */
    initWithSpriteFrame:function (spriteFrame) {
        cc.Assert(spriteFrame != null, "");
        var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect());
        this.setDisplayFrame(spriteFrame);

        return ret;
    },

    /**
     * Initializes a sprite with a sprite frame name. <br/>
     * A cc.SpriteFrame will be fetched from the cc.SpriteFrameCache by name.  <br/>
     * If the cc.SpriteFrame doesn't exist it will raise an exception. <br/>
     * @param {String} spriteFrameName
     * @return {Boolean}
     * @example
     * var sprite = new cc.Sprite();
     * sprite.initWithSpriteFrameName("grossini_dance_01.png");
     */
    initWithSpriteFrameName:function (spriteFrameName) {
        cc.Assert(spriteFrameName != null, "");
        var frame = cc.SpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName(spriteFrameName);
        return this.initWithSpriteFrame(frame);
    },

    /**
     * tell the sprite to use self-render.
     */
    useSelfRender:function () {
        this._atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
        this._usesBatchNode = false;
        this._textureAtlas = null;
        this._batchNode = null;
        this._dirty = this._recursiveDirty = false;

        var x1 = 0 + this._offsetPositionInPixels.x;
        var y1 = 0 + this._offsetPositionInPixels.y;
        var x2 = x1 + this._rectInPixels.size.width;
        var y2 = y1 + this._rectInPixels.size.height;
        this._quad.bl.vertices = cc.vertex3(x1, y1, 0);
        this._quad.br.vertices = cc.vertex3(x2, y1, 0);
        this._quad.tl.vertices = cc.vertex3(x1, y2, 0);
        this._quad.tr.vertices = cc.vertex3(x2, y2, 0);
    },

    /**
     * tell the sprite to use batch node render.
     * @param {cc.SpriteBatchNode} batchNode
     */
    useBatchNode:function (batchNode) {
        this._usesBatchNode = true;
        this._textureAtlas = batchNode.getTextureAtlas(); // weak ref
        this._batchNode = batchNode;
    },

    /**
     * updates the texture rect of the CCSprite in points.
     * @param {cc.Rect} rect a rect of texture
     */
    setTextureRect:function (rect) {
        var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
        this.setTextureRectInPixels(rectInPixels, false, rectInPixels.size);
    },

    /**
     * updates the texture rect, rectRotated and untrimmed size of the CCSprite in pixels
     * @param {cc.Rect} rect    rect of texture
     * @param {Boolean} rotated    whether or not rotated of texture
     * @param {cc.Size} size    size of texture
     */
    setTextureRectInPixels:function (rect, rotated, size) {
        this._rectInPixels = rect;
        this._rect = cc.RECT_PIXELS_TO_POINTS(rect);
        this._rectRotated = rotated;

        this.setContentSizeInPixels(size);
        this._updateTextureCoords(this._rectInPixels);

        var relativeOffsetInPixels = this._unflippedOffsetPositionFromCenter;

        /* WEBGL Code
         if (this._flipX) {
         //relativeOffsetInPixels.x = -relativeOffsetInPixels.x;
         }
         if (this._flipY) {
         //relativeOffsetInPixels.y = -relativeOffsetInPixels.y;
         }
         */

        this._offsetPositionInPixels.x = relativeOffsetInPixels.x + (this._contentSizeInPixels.width - this._rectInPixels.size.width) / 2;
        this._offsetPositionInPixels.y = relativeOffsetInPixels.y + (this._contentSizeInPixels.height - this._rectInPixels.size.height) / 2;

        // rendering using batch node
        if (this._usesBatchNode) {
            // update dirty_, don't update recursiveDirty_
            this._dirty = true;
        } else {
            // self rendering

            // Atlas: Vertex
            var x1 = 0 + this._offsetPositionInPixels.x;
            var y1 = 0 + this._offsetPositionInPixels.y;
            var x2 = x1 + this._rectInPixels.size.width;
            var y2 = y1 + this._rectInPixels.size.height;

            // Don't update Z.
            this._quad.bl.vertices = cc.vertex3(x1, y1, 0);
            this._quad.br.vertices = cc.vertex3(x2, y1, 0);
            this._quad.tl.vertices = cc.vertex3(x1, y2, 0);
            this._quad.tr.vertices = cc.vertex3(x2, y2, 0);
        }
    },

    _updateTextureCoords:function (rect) {
        if (cc.renderContextType == cc.WEBGL) {
            var tex = this._usesBatchNode ? this._textureAtlas.getTexture() : this._texture;
            if (!tex) {
                return;
            }

            var atlasWidth = tex.getPixelsWide();
            var atlasHeight = tex.getPixelsHigh();

            var left, right, top, bottom;

            if (this._rectRotated) {
                if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
                    right = left + (rect.size.height * 2 - 2) / (2 * atlasWidth);
                    top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
                    bottom = top + (rect.size.width * 2 - 2) / (2 * atlasHeight);
                } else {
                    left = rect.origin.x / atlasWidth;
                    right = left + (rect.size.height / atlasWidth);
                    top = rect.origin.y / atlasHeight;
                    bottom = top + (rect.size.width / atlasHeight);
                }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL


                if (this._flipX) {
                    cc.SWAP(top, bottom);
                }

                if (this._flipY) {
                    cc.SWAP(left, right);
                }

                this._quad.bl.texCoords.u = left;
                this._quad.bl.texCoords.v = top;
                this._quad.br.texCoords.u = left;
                this._quad.br.texCoords.v = bottom;
                this._quad.tl.texCoords.u = right;
                this._quad.tl.texCoords.v = top;
                this._quad.tr.texCoords.u = right;
                this._quad.tr.texCoords.v = bottom;
            } else {
                if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
                    right = left + (rect.size.width * 2 - 2) / (2 * atlasWidth);
                    top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
                    bottom = top + (rect.size.height * 2 - 2) / (2 * atlasHeight);
                }
                else {
                    left = rect.origin.x / atlasWidth;
                    right = left + rect.size.width / atlasWidth;
                    top = rect.origin.y / atlasHeight;
                    bottom = top + rect.size.height / atlasHeight;
                } // ! CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL

                if (this._flipX) {
                    cc.SWAP(left, right);
                }

                if (this._flipY) {
                    cc.SWAP(top, bottom);
                }

                this._quad.bl.texCoords.u = left;
                this._quad.bl.texCoords.v = bottom;
                this._quad.br.texCoords.u = right;
                this._quad.br.texCoords.v = bottom;
                this._quad.tl.texCoords.u = left;
                this._quad.tl.texCoords.v = top;
                this._quad.tr.texCoords.u = right;
                this._quad.tr.texCoords.v = top;
            }
        }
    },

    // BatchNode methods
    /**
     * updates the quad according the the rotation, position, scale values.
     */
    updateTransform:function () {
        cc.Assert(this._usesBatchNode, "");

        // optimization. Quick return if not dirty
        if (!this._dirty) {
            return;
        }

        var matrix = new cc.AffineTransform();

        // Optimization: if it is not visible, then do nothing
        if (!this._isVisible) {
            this._quad.br.vertices = this._quad.tl.vertices = this._quad.tr.vertices = this._quad.bl.vertices = cc.vertex3(0, 0, 0);
            this._textureAtlas.updateQuad(this._quad, this._atlasIndex)
            this._dirty = this._recursiveDirty = false;
            return;
        }

        // Optimization: If parent is batchnode, or parent is nil
        // build Affine transform manually
        if (!this._parent || this._parent == this._batchNode) {
            var radians = -cc.DEGREES_TO_RADIANS(this._rotation);
            var c = Math.cos(radians);
            var s = Math.sin(radians);

            matrix = cc.AffineTransformMake(c * this._scaleX, s * this._scaleX, -s * this._scaleY, c * this._scaleY,
                this._positionInPixels.x, this._positionInPixels.y);
            if (this._skewX || this._skewY) {
                var skewMatrix = cc.AffineTransformMake(1.0, Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)), Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)), 1.0, 0.0, 0.0);
                matrix = cc.AffineTransformConcat(skewMatrix, matrix);
            }
            matrix = cc.AffineTransformTranslate(matrix, -this._anchorPointInPixels.x, -this._anchorPointInPixels.y);
        } else // parent_ != batchNode_
        {
            // else do affine transformation according to the HonorParentTransform
            matrix = cc.AffineTransformIdentity();
            var prevHonor = cc.HONOR_PARENT_TRANSFORM_ALL;

            for (var p = this; p && p != this._batchNode; p = p.getParent()) {
                // Might happen. Issue #1053
                // how to implement, we can not use dynamic
                // cc.Assert( [p isKindOfClass:[CCSprite class]], @"CCSprite should be a CCSprite subclass. Probably you initialized an sprite with a batchnode, but you didn't add it to the batch node." );

                var tv = new cc.TransformValues();
                p._getTransformValues(tv);

                // If any of the parents are not visible, then don't draw this node
                if (!tv.visible) {
                    this._quad.br.vertices = this._quad.tl.vertices = this._quad.tr.vertices = this._quad.bl.vertices = cc.vertex3(0, 0, 0);
                    this._textureAtlas.updateQuad(this._quad, this._atlasIndex);
                    this._dirty = this._recursiveDirty = false;
                    return;
                }

                var newMatrix = cc.AffineTransformIdentity();

                // 2nd: Translate, Skew, Rotate, Scale
                if (prevHonor & cc.HONOR_PARENT_TRANSFORM_TRANSLATE) {
                    newMatrix = cc.AffineTransformTranslate(newMatrix, tv.pos.x, tv.pos.y);
                }

                if (prevHonor & cc.HONOR_PARENT_TRANSFORM_ROTATE) {
                    newMatrix = cc.AffineTransformRotate(newMatrix, -cc.DEGREES_TO_RADIANS(tv.rotation));
                }

                if (prevHonor & cc.HONOR_PARENT_TRANSFORM_SKEW) {
                    var skew = new cc.AffineTransform();
                    skew = cc.AffineTransformMake(1.0, Math.tan(cc.DEGREES_TO_RADIANS(tv.skew.y)), Math.tan(cc.DEGREES_TO_RADIANS(tv.skew.x)), 1.0, 0.0, 0.0);
                    // apply the skew to the transform
                    newMatrix = cc.AffineTransformConcat(skew, newMatrix);
                }

                if (prevHonor & cc.HONOR_PARENT_TRANSFORM_SCALE) {
                    newMatrix = cc.AffineTransformScale(newMatrix, tv.scale.x, tv.scale.y);
                }

                // 3rd: Translate anchor point
                newMatrix = cc.AffineTransformTranslate(newMatrix, -tv.ap.x, -tv.ap.y);

                // 4th: Matrix multiplication
                matrix = cc.AffineTransformConcat(matrix, newMatrix);

                prevHonor = p;
                this.getHonorParentTransform();
            }
        }

        //
        // calculate the Quad based on the Affine Matrix
        //
        var size = new cc.Size();
        size = this._rectInPixels.size;

        var x1 = this._offsetPositionInPixels.x;
        var y1 = this._offsetPositionInPixels.y;

        var x2 = x1 + size.width;
        var y2 = y1 + size.height;
        var x = matrix.tx;
        var y = matrix.ty;

        var cr = matrix.a;
        var sr = matrix.b;
        var cr2 = matrix.d;
        var sr2 = -matrix.c;
        var ax = x1 * cr - y1 * sr2 + x;
        var ay = x1 * sr + y1 * cr2 + y;

        var bx = x2 * cr - y1 * sr2 + x;
        var by = x2 * sr + y1 * cr2 + y;

        var cx = x2 * cr - y2 * sr2 + x;
        var cy = x2 * sr + y2 * cr2 + y;

        var dx = x1 * cr - y2 * sr2 + x;
        var dy = x1 * sr + y2 * cr2 + y;

        this._quad.bl.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(ax), cc.RENDER_IN_SUBPIXEL(ay), this._vertexZ);
        this._quad.br.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(bx), cc.RENDER_IN_SUBPIXEL(by), this._vertexZ);
        this._quad.tl.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(dx), cc.RENDER_IN_SUBPIXEL(dy), this._vertexZ);
        this._quad.tr.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(cx), cc.RENDER_IN_SUBPIXEL(cy), this._vertexZ);

        this._textureAtlas.updateQuad(this._quad, this._atlasIndex);
        this._dirty = this._recursiveDirty = false;
    },

    /**
     * <p>Optimization: instead of calling 5 times the parent sprite to obtain: position, scale.x, scale.y, anchorpoint and rotation,<br/>
     * this fuction return the 5 values in 1 single call <p/>
     * @param {cc.TransformValues} tv
     * @return {cc.TransformValues}
     * @private
     */
    _getTransformValues:function (tv) {
        tv.pos = this._positionInPixels;
        tv.scale.x = this._scaleX;
        tv.scale.y = this._scaleY;
        tv.rotation = this._rotation;
        tv.skew.x = this._skewX;
        tv.skew.y = this._skewY;
        tv.ap = this._anchorPointInPixels;
        tv.visible = this._isVisible;
        return tv
    },

    /**
     * draw sprite to canvas
     * @param {CanvasContext} ctx 2d context of canvas
     */
    draw:function (ctx) {
        this._super();

        var context = ctx || cc.renderContext;
        if (cc.renderContextType == cc.CANVAS) {
            context.globalAlpha = this._opacity / 255;
            if (this._flipX) {
                context.scale(-1, 1);
            }
            if (this._flipY) {
                context.scale(1, -1);
            }
            var offsetPixels = this._offsetPositionInPixels;
            var pos = new cc.Point(0 | ( -this._anchorPointInPixels.x + offsetPixels.x), 0 | ( -this._anchorPointInPixels.y + offsetPixels.y));
            if (this._texture) {
                //direct draw image by canvas drawImage
                if (this._texture instanceof HTMLImageElement) {
                    if ((this._contentSize.width == 0) && (this._contentSize.height == 0)) {
                        this.setContentSize(new cc.Size(this._texture.width, this._texture.height));
                        this._rect.size.width = this._texture.width;
                        this._rect.size.height = this._texture.height;
                        context.drawImage(this._texture, pos.x, -(pos.y + this._texture.height));
                    } else {
                        context.drawImage(this._texture,
                            this._rect.origin.x, this._rect.origin.y,
                            this._rect.size.width, this._rect.size.height,
                            pos.x, -(pos.y + this._rect.size.height),
                            this._rect.size.width, this._rect.size.height);
                    }
                } else {
                    if ((this._contentSize.width == 0) && (this._contentSize.height == 0)) {
                        this.setContentSize(new cc.Size(this._texture.width, this._texture.height));
                        this._rect.size.width = this._texture.width;
                        this._rect.size.height = this._texture.height;
                        context.drawImage(this._texture, pos.x, -(pos.y + this._texture.height));
                    } else {
                        context.drawImage(this._texture,
                            0, 0,
                            this._rect.size.width, this._rect.size.height,
                            pos.x, -(pos.y + this._rect.size.height),
                            this._rect.size.width, this._rect.size.height);
                    }
                }
            } else {
                context.fillStyle = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ",1)";
                context.fillRect(pos.x, pos.y, this._contentSize.width, this._contentSize.height);
            }

            //TODO need to fixed
            if (cc.SPRITE_DEBUG_DRAW == 1) {
                // draw bounding box
                var s = this._contentSize;
                var vertices = [cc.ccp(0, 0), cc.ccp(s.width, 0), cc.ccp(s.width, s.height), cc.ccp(0, s.height)];
                cc.drawingUtil.drawPoly(vertices, 4, true);
            } else if (cc.SPRITE_DEBUG_DRAW == 2) {
                // draw texture box
                var s = this._rect.size;
                var offsetPix = this.getOffsetPositionInPixels();
                var vertices = [cc.ccp(offsetPix.x, offsetPix.y), cc.ccp(offsetPix.x + s.width, offsetPix.y),
                    cc.ccp(offsetPix.x + s.width, offsetPix.y + s.height), cc.ccp(offsetPix.x, offsetPix.y + s.height)];
                cc.drawingUtil.drawPoly(vertices, 4, true);
            }
        } else {
            cc.Assert(!this._usesBatchNode, "");

            // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Unneeded states: -
            var newBlend = this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST;
            if (newBlend) {
                //TODO
                //glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
            }

            //#define kQuadSize  sizeof(this._quad.bl)
            if (this._texture) {
                //TODO
                //glBindTexture(GL_TEXTURE_2D, this._texture.getName());
            }
            else {
                //TODO
                //glBindTexture(GL_TEXTURE_2D, 0);
            }

            var offset = this._quad;

            // vertex
            var diff = cc.offsetof(cc.V3F_C4B_T2F, cc.vertices);
            //TODO
            // glVertexPointer(3, GL_FLOAT, kQuadSize, (offset + diff));

            // color
            diff = cc.offsetof(cc.V3F_C4B_T2F, cc.colors);
            //TODO
            // glColorPointer(4, GL_UNSIGNED_BYTE, kQuadSize, (offset + diff));

            // tex coords
            diff = cc.offsetof(cc.V3F_C4B_T2F, cc.texCoords);
            //TODO
            //glTexCoordPointer(2, GL_FLOAT, kQuadSize, (offset + diff));

            //glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

            if (newBlend) {
                //glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
            }

            if (cc.SPRITE_DEBUG_DRAW == 1) {
                // draw bounding box
                var s = this._contentSize;
                var vertices = [cc.ccp(0, 0), cc.ccp(s.width, 0), cc.ccp(s.width, s.height), cc.ccp(0, s.height)];
                cc.drawingUtil.drawPoly(vertices, 4, true);
            }
            else if (cc.SPRITE_DEBUG_DRAW == 2) {
                // draw texture box
                var s = this._rect.size;
                var offsetPix = new cc.Point();
                offsetPix = this.getOffsetPositionInPixels();
                var vertices = [cc.ccp(offsetPix.x, offsetPix.y), cc.ccp(offsetPix.x + s.width, offsetPix.y),
                    cc.ccp(offsetPix.x + s.width, offsetPix.y + s.height), cc.ccp(offsetPix.x, offsetPix.y + s.height)];
                cc.drawingUtil.drawPoly(vertices, 4, true);
            } // CC_SPRITE_DEBUG_DRAW
        }
    },

    /**
     * Add child to sprite (override cc.Node )
     * @param {cc.Node} child
     * @param {Number} zOrder  child's zOrder
     * @param {String} tag child's tag
     * @override
     */
    addChild:function (child, zOrder, tag) {
        var argnum = arguments.length;
        switch (argnum) {
            case 1:
                this._super(child);
                break;
            case 2:
                this._super(child, zOrder);
                break;
            case 3:
                cc.Assert(child != null, "");
                this._super(child, zOrder, tag);

                if (cc.renderContextType == cc.WEBGL) {
                    if (this._usesBatchNode) {
                        cc.Assert(child.getTexture().getName() == this._textureAtlas.getTexture().getName(), "");
                        var index = this._batchNode.atlasIndexForChild(child, zOrder);
                        this._batchNode._insertChild(child, index);
                    }
                    this._hasChildren = true;
                }
                break;
            default:
                throw "Sprite.addChild():Argument must be non-nil ";
                break;
        }
    },

    /**
     * Reorders a child according to a new z value.  (override cc.Node )
     * @param {cc.Node} child
     * @param {Number} zOrder
     * @override
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "child is null");
        cc.Assert(this._children.indexOf(child) > -1, "");

        if (zOrder == child.getZOrder()) {
            return;
        }

        if (this._usesBatchNode) {
            // XXX: Instead of removing/adding, it is more efficient to reorder manually
            this.removeChild(child, false);
            this.addChild(child, zOrder);
        }
        else {
            this._super(child, zOrder);
        }
    },

    /**
     * Removes a child from the sprite. (override cc.Node )
     * @param child
     * @param cleanup  whether or not cleanup all running actions
     * @override
     */
    removeChild:function (child, cleanup) {
        if (this._usesBatchNode) {
            this._batchNode.removeSpriteFromAtlas(child);
        }
        this._super(child, cleanup);
    },

    /**
     * Removes all children from the container  (override cc.Node )
     * @param cleanup whether or not cleanup all running actions
     * @override
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        if (this._usesBatchNode) {
            if (this._children != null) {
                for (var i = 0; i < this._children.length; i++) {
                    if (this._children[i] instanceof cc.Sprite) {
                        this._batchNode.removeSpriteFromAtlas(this._children[i]);
                    }
                }
            }
        }

        this._super(cleanup);
        this._hasChildren = false;
    },
//
// CCNode property overloads
//

    /**
     * set Recursively is or isn't Dirty
     * used only when parent is CCSpriteBatchNode
     * @param {Boolean} value
     */
    setDirtyRecursively:function (value) {
        this._dirty = this._recursiveDirty = value;
        // recursively set dirty
        if (this._children != null) {
            for (var i in this._children) {
                if (this._children[i] instanceof cc.Sprite) {
                    this._children[i].setDirtyRecursively(true);
                }
            }
        }
    },

    /**
     * HACK: optimization
     */
    SET_DIRTY_RECURSIVELY:function () {
        if (this._usesBatchNode && !this._recursiveDirty) {
            this._dirty = this._recursiveDirty = true;
            if (this._hasChildren)
                this.setDirtyRecursively(true);
        }
    },

    /**
     * position setter (override cc.Node )
     * @param {cc.Point} pos
     * @override
     */
    setPosition:function (pos) {
        this._super(pos);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * PositionInPixels setter (override cc.Node )
     * @param {cc.Point} pos
     * @override
     */
    setPositionInPixels:function (pos) {
        this._super(pos);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * Rotation setter (override cc.Node )
     * @param {Number} fRotation
     * @override
     */
    setRotation:function (fRotation) {
        this._super(fRotation);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * SkewX setter (override cc.Node )
     * @param {Number} sx SkewX value
     * @override
     */
    setSkewX:function (sx) {
        this._super(sx);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * SkewY setter (override cc.Node )
     * @param {Number} sy SkewY value
     * @override
     */
    setSkewY:function (sy) {
        this._super(sy);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * ScaleX setter (override cc.Node )
     * @param {Number} scaleX
     * @override
     */
    setScaleX:function (scaleX) {
        this._super(scaleX);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * ScaleY setter (override cc.Node )
     * @param {Number} scaleY
     * @override
     */
    setScaleY:function (scaleY) {
        this._super(scaleY);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * <p>The scale factor of the node. 1.0 is the default scale factor. <br/>
     * It modifies the X and Y scale at the same time. (override cc.Node ) <p/>
     * @param {Number} scale
     * @override
     */
    setScale:function (scale) {
        this._super(scale);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * VertexZ setter (override cc.Node )
     * @param {Number} vertexZ
     * @override
     */
    setVertexZ:function (vertexZ) {
        this._super(vertexZ);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * AnchorPoint setter  (override cc.Node )
     * @param {cc.Point} anchor
     * @override
     */
    setAnchorPoint:function (anchor) {
        this._super(anchor);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * IsRelativeAnchorPoint setter  (override cc.Node )
     * @param {Boolean} relative
     * @override
     */
    setIsRelativeAnchorPoint:function (relative) {
        cc.Assert(!this._usesBatchNode, "");
        this._super(relative);
    },

    /**
     * visible setter  (override cc.Node )
     * @param {Boolean} visible
     * @override
     */
    setIsVisible:function (visible) {
        this._super(visible);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * FlipX value setter  (override cc.Node )
     * @param {Boolean} flipX
     */
    setFlipX:function (flipX) {
        if (this._flipX != flipX) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

            this._flipX = flipX;
            this.setTextureRectInPixels(this._rectInPixels, this._rectRotated, this._contentSizeInPixels);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * FlipY value setter  (override cc.Node )
     * @param {Boolean} flipY
     */
    setFlipY:function (flipY) {
        if (this._flipY != flipY) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

            this._flipY = flipY;
            //this.setTextureRectInPixels(this._rectInPixels, this._rectRotated, this._contentSizeInPixels);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * <p>whether or not the sprite is flipped horizontally.<br/>
     * It only flips the texture of the sprite, and not the texture of the sprite's children. <br/>
     * Also, flipping the texture doesn't alter the anchorPoint.<br/>
     * If you want to flip the anchorPoint too, and/or to flip the children too use:<br/>
     *      sprite->setScaleX(sprite->getScaleX() * -1);  <p/>
     * @return {Boolean}
     */
    isFlipX:function () {
        return this._flipX;
    },

    /**
     * <p>whether or not the sprite is flipped vertically.<br/>
     * It only flips the texture of the sprite, and not the texture of the sprite's children.<br/>
     * Also, flipping the texture doesn't alter the anchorPoint.<br/>
     * If you want to flip the anchorPoint too, and/or to flip the children too use:<br/>
     *         sprite->setScaleY(sprite->getScaleY() * -1); <p/>
     * @return {Boolean}
     */
    isFlipY:function () {
        return this._flipY;
    },

    //
    // RGBA protocol
    //

    /**
     * Update sprite's color
     */
    updateColor:function () {
        var color4 = new cc.Color4B(this._color.r, this._color.g, this._color.b, this._opacity);

        this._quad.bl.colors = color4;
        this._quad.br.colors = color4;
        this._quad.tl.colors = color4;
        this._quad.tr.colors = color4;

        // renders using Sprite Manager
        if (this._usesBatchNode) {
            if (this._atlasIndex != cc.SPRITE_INDEX_NOT_INITIALIZED) {
                this._textureAtlas.updateQuad(this._quad, this._atlasIndex)
            } else {
                // no need to set it recursively
                // update dirty_, don't update recursiveDirty_
                this._dirty = true;
            }
        }
        // self render
        // do nothing
    },

    /**
     * Return opacity of sprite
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * opacity setter
     * @param {Number} opacity
     */
    setOpacity:function (opacity) {
        this._opacity = opacity;

        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
        //TODO in canvas
        return;
        // special opacity for premultiplied textures
        if (this._opacityModifyRGB) {
            this.setColor(this._colorUnmodified);
        }

        this.updateColor();
    },

    /**
     * Return color of sprite
     * @return {cc.Color3B}
     */
    getColor:function () {
        if (this._opacityModifyRGB) {
            return new cc.Color3B(this._colorUnmodified);
        }
        return new cc.Color3B(this._color);
    },

    /**
     * color setter
     * @param {cc.Color3B} color3
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r)&&(this._color.g == color3.g)&&(this._color.b == color3.b)) {
            return;
        }

        this._color = this._colorUnmodified = new cc.Color3B(color3.r, color3.g, color3.b);
        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.sharedTextureCache().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    //generate color texture cache
                    var colorTexture = cc.generateTintImage(this.getTexture(), cacheTextureForColor, this._color, this.getTextureRect());
                    this.setTexture(colorTexture);
                }
            }
        }

        /*
         if (this._opacityModifyRGB) {
         this._color.r = Math.round(color3.r * this._opacity / 255);
         this._color.g = Math.round(color3.g * this._opacity / 255);
         this._color.b = Math.round(color3.b * this._opacity / 255);
         }
         */
        this.updateColor();
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        this.setNodeDirty();
    },

    // RGBAProtocol

    /**
     * opacity: conforms to CCRGBAProtocol protocol
     * @param {Boolean} value
     */
    setIsOpacityModifyRGB:function (value) {
        var oldColor = this._color;
        this._opacityModifyRGB = value;
        this._color = oldColor;
    },

    /**
     * return IsOpacityModifyRGB value
     * @return {Boolean}
     */
    getIsOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },

    // Frames
    /**
     * Sets a new display frame to the cc.Sprite.
     * @param {cc.SpriteFrame} newFrame
     */
    setDisplayFrame:function (newFrame) {
        this.setNodeDirty();
        this._unflippedOffsetPositionFromCenter = newFrame.getOffsetInPixels();
        var pNewTexture = newFrame.getTexture();
        // update texture before updating texture rect
        if (pNewTexture != this._texture) {
            this.setTexture(pNewTexture);
        }
        // update rect
        this._rectRotated = newFrame.isRotated();
        if (this._rectRotated)
            this.setRotation(-90);
        this.setTextureRectInPixels(newFrame.getRectInPixels(), newFrame.isRotated(), newFrame.getOriginalSizeInPixels());
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
    },

    // Animation

    /**
     * changes the display frame with animation name and index.<br/>
     * The animation name will be get from the CCAnimationCache
     * @param animationName
     * @param frameIndex
     */
    setDisplayFrameWithAnimationName:function (animationName, frameIndex) {
        cc.Assert(animationName, "");
        var a = cc.AnimationCache.sharedAnimationCache().animationByName(animationName);
        cc.Assert(a, "");
        var frame = a.getFrames()[frameIndex];
        cc.Assert(frame, "");
        this.setDisplayFrame(frame);
    },

    /**
     * Returns whether or not a cc.SpriteFrame is being displayed
     * @param {cc.SpriteFrame} frame
     * @return {Boolean}
     */
    isFrameDisplayed:function (frame) {
        if (cc.renderContextType == cc.CANVAS) {
            if (frame.getTexture() != this._texture)
                return false;
            return cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect);
        } else {
            return (cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect) && frame.getTexture().getName() == this._texture.getName());
        }
    },

    /**
     * Returns the current displayed frame.
     * @return {cc.SpriteFrame}
     */
    displayedFrame:function () {
        if (cc.renderContextType == cc.CANVAS) {
            return cc.SpriteFrame._frameWithTextureForCanvas(this._texture,
                this._rectInPixels,
                this._rectRotated,
                this._unflippedOffsetPositionFromCenter,
                this._contentSizeInPixels);
        } else {
            return cc.SpriteFrame.create(this._texture,
                this._rectInPixels,
                this._rectRotated,
                this._unflippedOffsetPositionFromCenter,
                this._contentSizeInPixels);
        }
    },

    // Texture protocol
    _updateBlendFunc:function () {
        if (cc.renderContextType == cc.WEBGL) {
            cc.Assert(!this._usesBatchNode, "CCSprite: _updateBlendFunc doesn't work when the sprite is rendered using a CCSpriteSheet");
            // it's possible to have an untextured sprite
            if (!this._texture || !this._texture.getHasPremultipliedAlpha()) {
                this._blendFunc.src = cc.GL_SRC_ALPHA;
                this._blendFunc.dst = cc.GL_ONE_MINUS_SRC_ALPHA;
                this.setIsOpacityModifyRGB(false);
            } else {
                this._blendFunc.src = cc.BLEND_SRC;
                this._blendFunc.dst = cc.BLEND_DST;
                this.setIsOpacityModifyRGB(true);
            }
        }
    },

    // CCTextureProtocol
    /**
     * Texture of sprite setter
     * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
     */
    setTexture:function (texture) {
        // CCSprite: setTexture doesn't work when the sprite is rendered using a CCSpriteSheet
        if (cc.renderContextType != cc.CANVAS) {
            cc.Assert(!this._usesBatchNode, "setTexture doesn't work when the sprite is rendered using a CCSpriteSheet");
        }

        // we can not use RTTI, so we do not known the type of object
        // accept texture==nil as argument
        /*cc.Assert((! texture) || dynamic_cast<CCTexture2D*>(texture));*/

        this._texture = texture;
        this._updateBlendFunc();
    },
    getTexture:function () {
        return this._texture;
    }
});

/**
 * Create a sprite with texture
 * @constructs
 * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
 * @param {cc.Rect} rect rect of the texture
 * @param {cc.Point} offset offset of the texture
 * @return {cc.Sprite}
 * @example
 * //get an image
 * var img = cc.TextureCache.sharedTextureCache().addImage("HelloWorld.png");
 *
 * //create a sprite with texture
 * var sprite1 = cc.Sprite.createWithTexture(img);
 *
 * //create a sprite with texture and rect
 * var sprite2 = cc.Sprite.createWithTexture(img, new cc.Rect(0,0,480,320));
 *
 * //create a sprite with texture and rect and offset
 * var sprite3 = cc.Sprite.createWithTexture(img, new cc.Rect(0,0,480,320),new cc.Point(0,0));
 */
cc.Sprite.createWithTexture = function (texture, rect, offset) {
    var argnum = arguments.length;
    var sprite = new cc.Sprite();
    switch (argnum) {
        case 1:
            /** Creates an sprite with a texture.
             The rect used will be the size of the texture.
             The offset will be (0,0).
             */
            if (sprite && sprite.initWithTexture(texture)) {
                return sprite;
            }
            return null;
            break;

        case 2:
            /** Creates an sprite with a texture and a rect.
             The offset will be (0,0).
             */
            if (sprite && sprite.initWithTexture(texture, rect)) {
                return sprite;
            }
            return null;
            break;

        case 3:
            /** Creates an sprite with a texture, a rect and offset. */
                // not implement
            cc.Assert(0, "");
            return null;
            break;

        default:
            throw "Sprite.spriteWithTexture(): Argument must be non-nil ";
            break;
    }
};

/**
 * Create a sprite with filename and rect
 * @constructs
 * @param {String} fileName
 * @param {cc.Rect} rect
 * @return {cc.Sprite}
 * @example
 * //create a sprite with filename
 * var sprite1 = cc.Sprite.create("HelloWorld.png");
 *
 * //create a sprite with filename and rect
 * var sprite2 = cc.Sprite.create("HelloWorld.png",new cc.Rect(0,0,480,320));
 */
cc.Sprite.create = function (fileName, rect) {
    var argnum = arguments.length;
    var sprite = new cc.Sprite();
    if (argnum < 2) {
        /** Creates an sprite with an image filename.
         The rect used will be the size of the image.
         The offset will be (0,0).
         */
        if (sprite && sprite.initWithFile(fileName)) {
            return sprite;
        }
        return null;
    }
    else {
        /** Creates an sprite with an CCBatchNode and a rect
         */
        if (sprite && sprite.initWithFile(fileName, rect)) {
            return sprite;
        }
        return null;
    }
};

/**
 * Creates a sprite with a sprite frame.
 * @param {cc.SpriteFrame} spriteFrame
 * @return {cc.Sprite}
 * @example
 * //get a sprite frame
 * var spriteFrame = cc.SpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("grossini_dance_01.png");
 *
 * //create a sprite with a sprite frame
 * var sprite = cc.Sprite.createWithSpriteFrame(spriteFrame);
 */
cc.Sprite.createWithSpriteFrame = function (spriteFrame) {
    var sprite = new cc.Sprite();
    if (sprite && sprite.initWithSpriteFrame(spriteFrame)) {
        return sprite;
    }
    return null;
};

/**
 * Create a sprite with a sprite batch node
 * @param {cc.SpriteBatchNode} batchNode
 * @param {cc.Rect} rect
 * @return {cc.Sprite}
 * @example
 * //create a sprite batch node
 * var asmtest = cc.SpriteBatchNode.create(s_ghosts);
 *
 * //create a sprite with a sprite batch node
 * var sprite1 = cc.Sprite.createWithBatchNode(asmtest, cc.RectMake(0, 0, 50, 50));
 */
cc.Sprite.createWithBatchNode = function (batchNode, rect) {
    var sprite = new cc.Sprite();
    if (sprite && sprite.initWithBatchNode(batchNode, rect)) {
        return sprite;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *     A cc.Animation object is used to perform animations on the cc.Sprite objects.<br/>
 *     <br/>
 *      The cc.Animation object contains cc.SpriteFrame objects, and a possible delay between the frames. <br/>
 *      You can animate a cc.Animation object by using the cc.Animate action. Example:  <br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * //create an animation object
 * var animation = cc.Animation.create();
 *
 * //add a sprite frame to this animation
 * animation.addFrameWithFileName("grossini_dance_01.png");
 *
 * //create an animate with this animation
 * var action = cc.Animate.create(3, animation, false);
 *
 * //run animate
 * this._grossini.runAction(action);
 */
cc.Animation = cc.Class.extend(/** @lends cc.Animation# */{
    _name:"",
    _delay:0,
    _frames:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._frames = [];
    },

    // attributes
    /**
     * get name of the animation
     * @return {String}
     */
    getName:function () {
        return this._name;
    },

    /**
     * set name of the animation
     * @param {String} name
     */
    setName:function (name) {
        this._name = name;
    },

    /**
     * get delay between frames in seconds
     * @return {Number}
     */
    getDelay:function () {
        return this._delay;
    },

    /**
     * set delay between frames in seconds
     * @param {Number} delay
     */
    setDelay:function (delay) {
        this._delay = delay;
    },

    /**
     * get array of frames
     * @return {Array}
     */
    getFrames:function () {
        return this._frames;
    },

    /**
     * set array of frames, the Frames is retained
     * @param {Array} frames
     */
    setFrames:function (frames) {
        this._frames = frames;
    },

    /**
     * Initializes a cc.Animation with frames and a delay between frames
     * @param {Array} frames
     * @param {Number} delay
     * @return {Boolean}
     */
    initWithFrames:function (frames, delay) {
        this._delay = delay;
        if (frames)
            this._frames = frames;
        else
            this._frames = [];

        return true;
    },

    /**
     * adds a frame to a cc.Animation
     * @param {cc.SpriteFrame} frame
     */
    addFrame:function (frame) {
        this._frames.push(frame);
    },

    /**
     * Adds a frame with an image filename. Internally it will create a cc.SpriteFrame and it will add it.
     * @param {String} fileName
     */
    addFrameWithFileName:function (fileName) {
        var texture = cc.TextureCache.sharedTextureCache().addImage(fileName);
        var rect = cc.RectZero();
        if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {
            rect.size = cc.SizeMake(texture.width, texture.height);
        } else {
            rect.size = texture.getContentSize();
        }

        var frame = cc.SpriteFrame.create(texture, rect);

        this._frames.push(frame);
    },

    /**
     * Adds a frame with a texture and a rect. Internally it will create a CCSpriteFrame and it will add it.
     * @param {cc.Texture2D} texture
     * @param {cc.Rect} rect
     */
    addFrameWithTexture:function (texture, rect) {
        var pFrame = cc.SpriteFrame.create(texture, rect);
        this._frames.push(pFrame);
    },

    init:function () {
        return this.initWithFrames(null, 0);
    }
});

/**
 * Creates an animation.
 * @param {Array} frames
 * @param {Number} delay
 * @return {cc.Animation}
 * @example
 * //Creates an animation
 * var animation1 = cc.Animation.create();
 *
 * //Create an animation with sprite frames
 * var animFrames = [];
 * var frame = cache.spriteFrameByName("grossini_dance_01.png");
 * animFrames.push(frame);
 * var animation2 = cc.Animation.create(animFrames);
 *
 * //Create an animation with sprite frames and delay
 * var animation3 = cc.Animation.create(animFrames, 0.2);
 */
cc.Animation.create = function (frames, delay) {
    var animation = new cc.Animation();
    if (frames == null) {
        animation.init();
    } else {
        /** with frames and a delay between frames */
        if (!delay) {
            delay = 0;
        }
        animation.initWithFrames(frames, delay);
    }
    return animation;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *     Singleton that manages the Animations.<br/>
 *     It saves in a cache the animations. You should use this class if you want to save your animations in a cache.<br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * cc.AnimationCache.sharedAnimationCache().addAnimation(animation,"animation1");
 */
cc.AnimationCache = cc.Class.extend(/** @lends cc.AnimationCache# */{

    /**
     * Adds a cc.Animation with a name.
     * @param {cc.Animation} animation
     * @param {String} name
     */
    addAnimation:function (animation, name) {
        this._animations[name] = animation;
    },

    /**
     *  Deletes a cc.Animation from the cache.
      * @param  {String} name
     */
    removeAnimationByName:function (name) {
        if (!name) {
            return;
        }
        delete this._animations[name];
    },

    /**
     * <p>
     *     Returns a cc.Animation that was previously added.<br/>
     *      If the name is not found it will return nil.<br/>
     *      You should retain the returned copy if you are going to use it.</br>
     * </p>
     * @param {String} name
     * @return {cc.Animation}
     */
    animationByName:function (name) {
        return this._animations[name];
    },

    /**
     * initialize cc.AnimationCache
     * @return {Boolean}
     */
    init:function () {
        this._animations = {};
        return true;
    },

    _animations:null
});

/**
 * Purges the cache. It releases all the cc.Animation objects and the shared instance.
 */
cc.AnimationCache.purgeSharedAnimationCache = function () {
    cc.sharedAnimationCache = null;
};

/**
 * Retruns ths shared instance of the Animation cache
 * @return {cc.AnimationCache}
 */
cc.AnimationCache.sharedAnimationCache = function () {
    if (cc.sharedAnimationCache == null) {
        cc.sharedAnimationCache = new cc.AnimationCache();
        cc.sharedAnimationCache.init();
    }
    return cc.sharedAnimationCache;
};

cc.sharedAnimationCache = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *    A cc.SpriteFrame has:<br/>
 *      - texture: A cc.Texture2D that will be used by the cc.Sprite<br/>
 *      - rectangle: A rectangle of the texture<br/>
 *    <br/>
 *    You can modify the frame of a cc.Sprite by doing:<br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * var texture = cc.TextureCache.sharedTextureCache().addImage(s_dragon_animation);
 * var frame0 = cc.SpriteFrame.create(texture, cc.RectMake(132 * 0, 132 * 0, 132, 132));
 */
cc.SpriteFrame = cc.Class.extend(/** @lends cc.SpriteFrame# */{
    _rectInPixels:new cc.Rect(),
    _rotated:null,
    _rect:new cc.Rect(),
    _offsetInPixels:new cc.Point(),
    _originalSizeInPixels:new cc.Size(),
    _texture:null,

    // attributes
    /**
     * @return {cc.Rect}
     */
    getRectInPixels:function () {
        return this._rectInPixels;
    },

    /**
     * @param {cc.Rect} rectInPixels
     */
    setRectInPixels:function (rectInPixels) {
        this._rectInPixels = rectInPixels;
        this._rect = cc.RECT_PIXELS_TO_POINTS(rectInPixels);
    },

    /**
     * <p>
     *     return is rotated of SpriteFrame. <br/>
     * </p>
     * @return {Boolean}
     */
    isRotated:function () {
        return this._rotated;
    },

    /**
     * set SpriteFrame is rotated
     * @param {Boolean} bRotated
     */
    setRotated:function (bRotated) {
        this._rotated = bRotated;
    },

    /**
     * get rect of the frame
     * @return {cc.Rect}
     */
    getRect:function () {
        return this._rect;
    },

    /**
     * set rect of the frame
     * @param {cc.Rect} rect
     */
    setRect:function (rect) {
        this._rect = rect;
        this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect);
    },

    /**
     * get offset of the frame
     * @return {cc.Point}
     */
    getOffsetInPixels:function () {
        return this._offsetInPixels;
    },

    /**
     * set offset of the frame
     * @param {cc.Point} offsetInPixels
     */
    setOffsetInPixels:function (offsetInPixels) {
        this._offsetInPixels = offsetInPixels;
    },

    /**
     * get original size of the trimmed image
     * @return {cc.Size}
     */
    getOriginalSizeInPixels:function () {
        return this._originalSizeInPixels;
    },

    /**
     * set original size of the trimmed image
     * @param {cc.Size} sizeInPixels
     */
    setOriginalSizeInPixels:function (sizeInPixels) {
        this._originalSizeInPixels = sizeInPixels;
    },

    /**
     * get texture of the frame
     * @return {cc.Texture2D|HTMLImageElement}
     */
    getTexture:function () {
        return this._texture;
    },

    /**
     * set texture of the frame, the texture is retained
     * @param {cc.Texture2D|HTMLImageElement} texture
     */
    setTexture:function (texture) {
        this._texture = texture;
    },

    /**
     * copy a new SpriteFrame
     * @return {cc.SpriteFrame}
     */
    copyWithZone:function () {
        var copy = new cc.SpriteFrame();
        copy.initWithTexture(this._texture, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        return copy;
    },

    /**
     * Initializes SpriteFrame with Texture, rect, rotated, offset and originalSize in pixels.
     * @param {cc.Texture2D|HTMLImageElement} texture
     * @param {cc.Rect} rect
     * @param {Boolean} rotated
     * @param {cc.Point} offset
     * @param {cc.Size} originalSize
     * @return {Boolean}
     */
    initWithTexture:function (texture, rect, rotated, offset, originalSize) {
        var argnum = arguments.length;
        switch (argnum) {
        /** Initializes a cc.SpriteFrame with a texture, rect in points.
         It is assumed that the frame was not trimmed.
         */
            case 2:
                var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
                return this.initWithTexture(texture, rectInPixels, false, cc.PointZero(), rectInPixels.size);
                break;

        /** Initializes a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
         The originalSize is the size in points of the frame before being trimmed.
         */
            case 5:
                this._texture = texture;
                this._rectInPixels = rect;

                this._rect = cc.RECT_PIXELS_TO_POINTS(rect);
                this._rotated = rotated;
                this._offsetInPixels = offset;
                this._originalSizeInPixels = originalSize;
                return true;
                break;

            default:
                throw "Argument must be non-nil ";
                break;
        }
    }
});

/**
 * Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
 * @param {cc.Texture2D|HTMLImageElement} texture
 * @param {cc.Rect} rect
 * @param {Boolean} rotated
 * @param {cc.Point} offset
 * @param {cc.Size} originalSize
 * @return {cc.SpriteFrame}
 * @example
 * //Create a cc.SpriteFrame with a texture, rect in texture.
 * var frame1 = cc.SpriteFrame.create("grossini_dance.png",new cc.Rect(0,0,90,128));
 *
 * //Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
 * var frame2 = cc.SpriteFrame.create(texture, frameRect, rotated, offset, sourceSize);
 */
cc.SpriteFrame.create = function (texture, rect, rotated, offset, originalSize) {
    var argnum = arguments.length;
    var spriteFrame = new cc.SpriteFrame();
    switch (argnum) {
    /** Create a cc.SpriteFrame with a texture, rect in points.
     It is assumed that the frame was not trimmed.
     */
        case 2:
            spriteFrame.initWithTexture(texture, rect);
            break;
    /** Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
     The originalSize is the size in points of the frame before being trimmed.
     */
        case 5:
            spriteFrame.initWithTexture(texture, rect, rotated, offset, originalSize);
            break;
        default:
            throw "Argument must be non-nil ";
            break;
    }
    return spriteFrame;
};

cc.SpriteFrame._frameWithTextureForCanvas = function (texture, rect, rotated, offset, originalSize) {
    var spriteFrame = new cc.SpriteFrame();
    spriteFrame._texture = texture;
    spriteFrame._rectInPixels = rect;
    spriteFrame._rect = cc.RECT_PIXELS_TO_POINTS(rect);
    spriteFrame._rotated = rotated;
    spriteFrame._offsetInPixels = offset;
    spriteFrame._originalSizeInPixels = originalSize;
    return spriteFrame;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Singleton that handles the loading of the sprite frames. It saves in a cache the sprite frames.
 * @class
 * @extends cc.Class
 * @example
 * // add SpriteFrames to SpriteFrameCache With File
 * cc.SpriteFrameCache.sharedSpriteFrameCache().addSpriteFramesWithFile(s_grossiniPlist);
 */
cc.SpriteFrameCache = cc.Class.extend(/** @lends cc.SpriteFrameCache# */{
    _spriteFrames:null,
    _spriteFramesAliases:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
    },

    /**
     * Adds multiple Sprite Frames with a dictionary. The texture will be associated with the created sprite frames.
     * @param {object} dictionary
     * @param {HTMLImageElement|cc.Texture2D} texture
     */
    addSpriteFramesWithDictionary:function (dictionary, texture) {
        var metadataDict = dictionary["metadata"];
        var framesDict = dictionary["frames"];
        var format = 0;
        // get the format
        if (metadataDict != null) {
            format = parseInt(this._valueForKey("format", metadataDict));
        }

        // check the format
        cc.Assert(format >= 0 && format <= 3, "");

        var frameDict = null;
        for (var key in framesDict) {
            frameDict = framesDict[key];
            if (frameDict) {
                var spriteFrame = this._spriteFrames[key];
                if (spriteFrame) {
                    continue;
                }

                if (format == 0) {
                    var x = parseFloat(this._valueForKey("x", frameDict));
                    var y = parseFloat(this._valueForKey("y", frameDict));
                    var w = parseFloat(this._valueForKey("width", frameDict));
                    var h = parseFloat(this._valueForKey("height", frameDict));
                    var ox = parseFloat(this._valueForKey("offsetX", frameDict));
                    var oy = parseFloat(this._valueForKey("offsetY", frameDict));
                    var ow = parseInt(this._valueForKey("originalWidth", frameDict));
                    var oh = parseInt(this._valueForKey("originalHeight", frameDict));
                    // check ow/oh
                    if (!ow || !oh) {
                        cc.Log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    }
                    // Math.abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);
                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    spriteFrame.initWithTexture(texture, cc.RectMake(x, y, w, h), false, cc.PointMake(ox, oy), cc.SizeMake(ow, oh));
                }
                else if (format == 1 || format == 2) {
                    var frame = cc.RectFromString(this._valueForKey("frame", frameDict));
                    var rotated = false;

                    // rotation
                    if (format == 2) {
                        rotated = this._valueForKey("rotated", frameDict) == "true";
                    }
                    var offset = cc.PointFromString(this._valueForKey("offset", frameDict));
                    var sourceSize = cc.SizeFromString(this._valueForKey("sourceSize", frameDict));
                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    spriteFrame.initWithTexture(texture, frame, rotated, offset, sourceSize);
                }
                else if (format == 3) {
                    // get values
                    var spriteSize = new cc.Size(), spriteOffset = new cc.Point(), spriteSourceSize = new cc.Size(), textureRect = new cc.Rect();
                    spriteSize = cc.SizeFromString(this._valueForKey("spriteSize", frameDict));
                    spriteOffset = cc.PointFromString(this._valueForKey("spriteOffset", frameDict));
                    spriteSourceSize = cc.SizeFromString(this._valueForKey("spriteSourceSize", frameDict));
                    textureRect = cc.RectFromString(this._valueForKey("textureRect", frameDict));
                    var textureRotated = this._valueForKey("textureRotated", frameDict) == "true";

                    // get aliases
                    var aliases = frameDict["aliases"];
                    var frameKey = key.toString();
                    for (var i in aliases) {
                        if (this._spriteFramesAliases.hasOwnProperty(aliases[i])) {
                            cc.Log("cocos2d: WARNING: an alias with name " + i + " already exists");
                        }
                        this._spriteFramesAliases[aliases[i]] = frameKey;
                    }
                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    spriteFrame.initWithTexture(texture,
                        cc.RectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                        textureRotated,
                        spriteOffset,
                        spriteSourceSize);
                }

                if (spriteFrame.isRotated()) {
                    var rect = spriteFrame.getRect();
                    spriteFrame.setRect(new cc.Rect(rect.origin.x, rect.origin.y, rect.size.height, rect.size.width));
                }

                // add sprite frame
                this._spriteFrames[key] = spriteFrame;
            }
        }
    },

    /**
     * Adds multiple Sprite Frames from a json file. A texture will be loaded automatically.
     * @param {object} jsonData
     */
    addSpriteFramesWithJson:function (jsonData) {
        var dict = jsonData;
        var texturePath = "";

        var metadataDict = dict["metadata"];
        if (metadataDict) {
            // try to read  texture file name from meta data
            texturePath = this._valueForKey("textureFileName", metadataDict);
            texturePath = texturePath.toString();
        }

        var texture = cc.TextureCache.sharedTextureCache().addImage(texturePath);
        if (texture) {
            this.addSpriteFramesWithDictionary(dict, texture);
        }
        else {
            cc.Log("cocos2d: cc.SpriteFrameCache: Couldn't load texture");
        }
    },

    /**
     * <p>
     *   Adds multiple Sprite Frames from a plist file.<br/>
     *   A texture will be loaded automatically. The texture name will composed by replacing the .plist suffix with .png<br/>
     *   If you want to use another texture, you should use the addSpriteFramesWithFile:texture method.<br/>
     * </p>
     * @param {String} plist plist filename
     * @param {HTMLImageElement|cc.Texture2D} texture
     * @example
     * // add SpriteFrames to SpriteFrameCache With File
     * cc.SpriteFrameCache.sharedSpriteFrameCache().addSpriteFramesWithFile(s_grossiniPlist);
     */
    addSpriteFramesWithFile:function (plist, texture) {
        var argnum = arguments.length;
        var dict = cc.FileUtils.dictionaryWithContentsOfFileThreadSafe(plist);

        switch (argnum) {
            case 1:
                var texturePath = "";
                var metadataDict = dict["metadata"];
                if (metadataDict) {
                    // try to read  texture file name from meta data
                    texturePath = this._valueForKey("textureFileName", metadataDict).toString();
                }
                if (texturePath != "") {
                    // build texture path relative to plist file
                    var getIndex = plist.lastIndexOf('/'), pszPath;
                    pszPath = getIndex ? plist.substring(0, getIndex + 1) : "";
                    texturePath = pszPath + texturePath;
                } else {
                    // build texture path by replacing file extension
                    texturePath = plist;

                    // remove .xxx
                    var startPos = texturePath.lastIndexOf(".", texturePath.length);
                    texturePath = texturePath.substr(0, startPos);

                    // append .png
                    texturePath = texturePath + ".png";
                    cc.Log("cocos2d: cc.SpriteFrameCache: Trying to use file " + texturePath.toString() + " as texture");
                }

                var texture = cc.TextureCache.sharedTextureCache().addImage(texturePath);
                if (texture) {
                    this.addSpriteFramesWithDictionary(dict, texture);
                }
                else {
                    cc.Log("cocos2d: cc.SpriteFrameCache: Couldn't load texture");
                }

                break;
            case 2:
                if (arguments[1] instanceof cc.Texture2D) {
                    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames. */
                    this.addSpriteFramesWithDictionary(dict, texture);
                } else {
                    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.
                     @since v0.99.5
                     */
                    var plist = arguments[0];
                    var textureFileName = arguments[1];
                    cc.Assert(textureFileName, "texture name should not be null");
                    var texture = cc.TextureCache.sharedTextureCache().addImage(textureFileName);

                    if (texture) {
                        this.addSpriteFramesWithDictionary(dict, texture);
                    }
                    else {
                        cc.Log("cocos2d: cc.SpriteFrameCache: couldn't load texture file. File not found " + textureFileName);
                    }
                }
                break;
            default:
                throw "Argument must be non-nil ";
        }
    },

    /**
     * <p>
     *  Adds an sprite frame with a given name.<br/>
     *  If the name already exists, then the contents of the old name will be replaced with the new one.
     * </p>
     * @param {cc.SpriteFrame} frame
     * @param {String} frameName
     */
    addSpriteFrame:function (frame, frameName) {
        this._spriteFrames[frameName] = frame;
    },

    /**
     * <p>
     *   Purges the dictionary of loaded sprite frames.<br/>
     *   Call this method if you receive the "Memory Warning".<br/>
     *   In the short term: it will free some resources preventing your app from being killed.<br/>
     *   In the medium term: it will allocate more resources.<br/>
     *   In the long term: it will be the same.<br/>
     * </p>
     */
    removeSpriteFrames:function () {
        this._spriteFrames = [];
        this._spriteFramesAliases = [];
    },

    /**
     * Deletes an sprite frame from the sprite frame cache.
     * @param {String} name
     */
    removeSpriteFrameByName:function (name) {
        // explicit nil handling
        if (!name) {
            return;
        }

        // Is this an alias ?
        if(this._spriteFramesAliases.hasOwnProperty(name)){
            delete(this._spriteFramesAliases[name]);
        }

        if(this._spriteFrames.hasOwnProperty(name)){
            delete(this._spriteFrames[name]);
        }
    },

    /**
     * <p>
     *     Removes multiple Sprite Frames from a plist file.<br/>
     *     Sprite Frames stored in this file will be removed.<br/>
     *     It is convinient to call this method when a specific texture needs to be removed.<br/>
     * </p>
     * @param {String} plist plist filename
     */
    removeSpriteFramesFromFile:function (plist) {
        var path = cc.FileUtils.fullPathFromRelativePath(plist);
        var dict = cc.FileUtils.dictionaryWithContentsOfFileThreadSafe(path);

        this.removeSpriteFramesFromDictionary(dict);
    },

    /**
     * Removes multiple Sprite Frames from Dictionary.
     * @param {object} dictionary SpriteFrame of Dictionary
     */
    removeSpriteFramesFromDictionary:function (dictionary) {
        var framesDict = dictionary["frames"];

        for (var key in framesDict) {
            if (this._spriteFrames.hasOwnProperty(key)) {
                delete(this._spriteFrames[key]);
            }
        }
    },

    /**
     * <p>
     *    Removes all Sprite Frames associated with the specified textures.<br/>
     *    It is convinient to call this method when a specific texture needs to be removed.
     * </p>
     * @param {HTMLImageElement|cc.Texture2D} texture
     */
    removeSpriteFramesFromTexture:function (texture) {
        var frameDict = null;
        for (var key in this._spriteFrames) {
            var frame = this._spriteFrames[key];
            if (frame && (frame.getTexture() == texture)) {
                delete(this._spriteFrames[key]);
            }
        }
    },

    /**
     * <p>
     *   Returns an Sprite Frame that was previously added.<br/>
     *   If the name is not found it will return nil.<br/>
     *   You should retain the returned copy if you are going to use it.<br/>
     * </p>
     * @param {String} name name of SpriteFrame
     * @return {cc.SpriteFrame}
     * @example
     * //get a SpriteFrame by name
     * var frame = cc.SpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("grossini_dance_01.png");
     */
    spriteFrameByName:function (name) {
        var frame;
        if (this._spriteFrames.hasOwnProperty(name)) {
            frame = this._spriteFrames[name];
        }

        if (!frame) {
            // try alias dictionary
            var key;
            if (this._spriteFramesAliases.hasOwnProperty(name)) {
                key = this._spriteFramesAliases[name];
            }
            if (key) {
                if (this._spriteFrames.hasOwnProperty(key.toString())) {
                    frame = this._spriteFrames[key.toString()];
                }
                if (!frame) {
                    cc.Log("cocos2d: cc.SpriteFrameCahce: Frame " + name + " not found");
                }
            }
        }
        return frame;
    },

    _valueForKey:function (key, dict) {
        if (dict) {
            if (dict.hasOwnProperty(key)) {
                return dict[key].toString();
            }
        }
        return "";
    }
});

cc.sharedSpriteFrameCache = null;

/**
 * Returns the shared instance of the Sprite Frame cache
 * @return {cc.SpriteFrameCache}
 */
cc.SpriteFrameCache.sharedSpriteFrameCache = function () {
    if (!cc.sharedSpriteFrameCache) {
        cc.sharedSpriteFrameCache = new cc.SpriteFrameCache();
    }
    return cc.sharedSpriteFrameCache;
};

/**
 * Purges the cache. It releases all the Sprite Frames and the retained instance.
 */
cc.SpriteFrameCache.purgeSharedSpriteFrameCache = function () {
    cc.sharedSpriteFrameCache = null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.DEFAULT_CAPACITY = 29;

/**
 * maximum unsigned int value
 * @constant
 * @type Number
 */
cc.UINT_MAX = 0xffffffff;

/**
 * @constant
 * @type Number
 */
cc.GL_SRC_ALPHA = 0x0302;

/**
 * @constant
 * @type Number
 */
cc.GL_ONE_MINUS_SRC_ALPHA = 0x0303;

/**
 * <p>
 *     In WebGL render mode ,cc.SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call<br/>
 *     (often known as "batch draw").<br/>
 *     <br/>
 *     A cc.SpriteBatchNode can reference one and only one texture (one image file, one texture atlas).<br/>
 *     Only the cc.Sprites that are contained in that texture can be added to the cc.SpriteBatchNode.<br/>
 *     All cc.Sprites added to a cc.SpriteBatchNode are drawn in one OpenGL ES draw call. <br/>
 *     If the CCSprites are not added to a CCSpriteBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient. <br/>
 *     <br/>
 *     Limitations:<br/>
 *       - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is CCSprite or any subclass of CCSprite. <br/>
 *          eg: particles, labels and layer can't be added to a CCSpriteBatchNode. <br/>
 *       - Either all its children are Aliased or Antialiased. It can't be a mix. <br/>
 *          This is because "alias" is a property of the texture, and all the sprites share the same texture. </br>
 * </p>
 * @class
 * @extends cc.Node
 * @example
 * //create a SpriteBatchNode
 * var parent2 = cc.SpriteBatchNode.create("Resources/animations/grossini.png", 50);
 */
cc.SpriteBatchNode = cc.Node.extend(/** @lends cc.SpriteBatchNode# */{
    _textureAtlas:new cc.TextureAtlas(),
    _blendFunc:new cc.BlendFunc(0, 0),
    // all descendants: chlidren, gran children, etc...
    _descendants:[],
    _renderTexture:null,
    _isUseCache:false,
    _originalTexture:null,
    /**
     * Constructor
     * @param {String} fileImage
     */
    ctor:function (fileImage) {
        this._super();
        if (fileImage) {
            this.initWithFile(fileImage, cc.DEFAULT_CAPACITY);
        }
        this.setContentSize(new cc.Size(cc.canvas.width, cc.canvas.height));
        this._renderTexture = cc.RenderTexture.create(cc.canvas.width, cc.canvas.height);
    },

    _updateBlendFunc:function () {
        if (!this._textureAtlas.getTexture().getHasPremultipliedAlpha()) {
            this._blendFunc.src = cc.GL_SRC_ALPHA;
            this._blendFunc.dst = cc.GL_ONE_MINUS_SRC_ALPHA;
        }
    },

    // IMPORTANT XXX IMPORTNAT:
    // These 2 methods can't be part of cc.TMXLayer since they call [super add...], and cc.SpriteSheet#add SHALL not be called

    /**
     * <p>
     *   Adds a quad into the texture atlas but it won't be added into the children array.<br/>
     *   This method should be called only when you are dealing with very big AtlasSrite and when most of the cc.Sprite won't be updated.<br/>
     *   For example: a tile map (cc.TMXMap) or a label with lots of characters (BitmapFontAtlas)<br/>
     * </p>
     * @param {cc.Sprite} sprite
     * @param {Number} index
     */
    addQuadFromSprite:function (sprite, index) {
        cc.Assert(sprite != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
        /// @todo CCAssert( [sprite isKindOfClass:[CCSprite class]], @"CCSpriteSheet only supports CCSprites as children");

        /*while(index >= this._textureAtlas.getCapacity() || this._textureAtlas.getCapacity() == this._textureAtlas.getTotalQuads()){
         this.increaseAtlasCapacity();
         }*/
        //todo fixed
        //
        // update the quad directly. Don't add the sprite to the scene graph
        //
        sprite.useBatchNode(this);
        sprite.setAtlasIndex(index);
        var quad = sprite.getQuad();

        this._textureAtlas.insertQuad(quad, index);
        // XXX: updateTransform will update the textureAtlas too using updateQuad.
        // XXX: so, it should be AFTER the insertQuad
        sprite.setDirty(true);
        sprite.updateTransform();
        this._children = cc.ArrayAppendObjectToIndex(this._children, sprite, index);
    },

    /**
     * <p>
     *    This is the opposite of "addQuadFromSprite.<br/>
     *    It add the sprite to the children and descendants array, but it doesn't update add it to the texture atlas<br/>
     * </p>
     * @param {cc.Node} child
     * @param {Number} z zOrder
     * @param {Number} aTag
     * @return {cc.SpriteBatchNode}
     */
    addSpriteWithoutQuad:function (child, z, aTag) {
        cc.Assert(child != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
        /// @todo CCAssert( [child isKindOfClass:[CCSprite class]], @"CCSpriteSheet only supports CCSprites as children");

        // quad index is Z
        child.setAtlasIndex(z);

        // XXX: optimize with a binary search
        var i = 0;
        if (this._descendants && this._descendants.length > 0) {
            var obj = null;
            for (var index = 0; index < this._descendants.length; index++) {
                obj = this._descendants[index];
                if (obj && (obj.getAtlasIndex() >= z)) {
                    ++i;
                }
            }
        }
        this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, child, i);

        // IMPORTANT: Call super, and not self. Avoid adding it to the texture atlas array
        this.addChild(child, z, aTag, true);
        //CCNode::addChild(child, z, aTag);
        return this;
    },

    // property
    /**
     * Return TextureAtlas of cc.SpriteBatchNode
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function () {
        return this._textureAtlas;
    },

    /**
     * TextureAtlas of cc.SpriteBatchNode setter
     * @param {cc.TextureAtlas} textureAtlas
     */
    setTextureAtlas:function (textureAtlas) {
        if (textureAtlas != this._textureAtlas) {
            this._textureAtlas = textureAtlas;
        }
    },

    /**
     * Return Descendants of cc.SpriteBatchNode
     * @return {Array}
     */
    getDescendants:function () {
        return  this._descendants;
    },

    /**
     * <p>
     *    initializes a CCSpriteBatchNode with a texture2d and capacity of children.<br/>
     *    The capacity will be increased in 33% in runtime if it run out of space.
     * </p>
     * @param {cc.Texture2D} tex
     * @param {Number} capacity
     * @return {Boolean}
     */
    initWithTexture:function (tex, capacity) {
        this._children = [];
        this._descendants = [];

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._textureAtlas = new cc.TextureAtlas();
        this._textureAtlas.initWithTexture(tex, capacity);
        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = tex;
        }
        if (cc.renderContextType == cc.WEBGL) {
            this._updateBlendFunc();
        }
        // no lazy alloc in this node
        return true;
    },

    /**
     * set this node is dirty ,need redraw
     */
    setNodeDirty:function () {
        this._setNodeDirtyForCache();
        this._isTransformDirty = this._isInverseDirty = true;
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
        }
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
    },

    /**
     * set Content Size of cc.SpriteBatchNode
     * @param {cc.Size} size
     */
    setContentSizeInPixels:function (size) {
        if (!size) {
            return;
        }

        //if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
        this._super(size);
        this._renderTexture.setContentSize(size);
        //}
    },

    /**
     * <p>
     *    initializes a cc.SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.<br/>
     *    The capacity will be increased in 33% in runtime if it run out of space.<br/>
     *    The file will be loaded using the TextureMgr.
     * </p>
     * @param {String} fileImage
     * @param {Number} capacity
     * @return {Boolean}
     */
    initWithFile:function (fileImage, capacity) {
        var texture2D = cc.TextureCache.sharedTextureCache().textureForKey(fileImage);
        if (!texture2D)
            texture2D = cc.TextureCache.sharedTextureCache().addImage(fileImage);
        return this.initWithTexture(texture2D, capacity);
    },

    /**
     * increase Atlas Capacity
     */
    increaseAtlasCapacity:function () {
        // if we're going beyond the current TextureAtlas's capacity,
        // all the previously initialized sprites will need to redo their texture coords
        // this is likely computationally expensive
        var quantity = (this._textureAtlas.getCapacity() + 1) * 4 / 3;

        cc.Log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + this._textureAtlas.getCapacity() + " to [" + quantity + "].");

        if (!this._textureAtlas.resizeCapacity(quantity)) {
            // serious problems
            cc.Log("cocos2d: WARNING: Not enough memory to resize the atlas");
            cc.Assert(false, "Not enough memory to resize the atla");
        }
    },

    /**
     * removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.
     * @warning Removing a child from a CCSpriteBatchNode is very slow
     * @param {Number} index
     * @param {Boolean} doCleanup
     */
    removeChildAtIndex:function (index, doCleanup) {
        //TODO index
        this.removeChild(this._children[index], doCleanup);
    },

    /**
     * add child helper
     * @param {cc.Sprite} sprite
     * @param {Number} index
     */
    insertChild:function (sprite, index) {
        sprite.useBatchNode(this);
        sprite.setAtlasIndex(index);
        sprite.setDirty(true);

        if (this._textureAtlas.getTotalQuads() == this._textureAtlas.getCapacity()) {
            this.increaseAtlasCapacity();
        }

        var quad = sprite.getQuad();
        this._textureAtlas.insertQuad(quad, index);

        this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, sprite, index);
        //this._descendants.insertObject(sprite, index);

        // update indices
        var i = 0;
        if (this._descendants && this._descendants.length > 0) {
            for (var index = 0; index < this._descendants.length; index++) {
                var obj = this._descendants[index];
                if (obj) {
                    if (i > index) {
                        obj.setAtlasIndex(obj.getAtlasIndex() + 1);
                    }
                    ++i;
                }
            }
        }

        // add children recursively
        var children = sprite.getChildren();
        if (children && children.length > 0) {
            for (index = 0; index < this._descendants.length; index++) {
                obj = this._descendants[index];
                if (obj) {
                    var getIndex = this.atlasIndexForChild(obj, obj.getZOrder());
                    this.insertChild(obj, getIndex);
                }
            }
        }
    },

    /**
     * remove sprite from TextureAtlas
     * @param {cc.Sprite} sprite
     */
    removeSpriteFromAtlas:function (sprite) {
        // remove from TextureAtlas
        this._textureAtlas.removeQuadAtIndex(sprite.getAtlasIndex());

        // Cleanup sprite. It might be reused (issue #569)
        sprite.useSelfRender();

        var index = cc.ArrayGetIndexOfObject(this._descendants, sprite);
        if (index != -1) {
            cc.ArrayRemoveObjectAtIndex(this._descendants, index);

            // update all sprites beyond this one
            var len = this._descendants.length;
            for (; index < len; ++index) {
                var s = this._descendants[index];
                s.setAtlasIndex(s.getAtlasIndex() - 1);
            }
        }

        // remove children recursively
        var children = sprite.getChildren();
        if (children && children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                if (children[i]) {
                    this.removeSpriteFromAtlas(children[i]);
                }
            }
        }
    },

    /**
     * rebuild index in order for child
     * @param {cc.Sprite} pobParent
     * @param {Number} index
     * @return {Number}
     */
    rebuildIndexInOrder:function (pobParent, index) {
        var children = pobParent.getChildren();

        if (children && children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                var obj = children[i];
                if (obj && (obj.getZOrder() < 0)) {
                    index = this.rebuildIndexInOrder(obj, index);
                }
            }
        }

        // ignore self (batch node)
        if (!pobParent.isEqual(this)) {
            pobParent.setAtlasIndex(index);
            index++;
        }

        if (children && children.length > 0) {
            for (i = 0; i < children.length; i++) {
                obj = children[i];
                if (obj && (obj.getZOrder() >= 0)) {
                    index = this.rebuildIndexInOrder(obj, index);
                }
            }
        }

        return index;
    },

    /**
     * get highest atlas index in child
     * @param {cc.Sprite} sprite
     * @return {Number}
     */
    highestAtlasIndexInChild:function (sprite) {
        var children = sprite.getChildren();

        if (!children || children.length == 0) {
            return sprite.getAtlasIndex();
        } else {
            return this.highestAtlasIndexInChild(children.pop());
        }
    },

    /**
     * get lowest atlas index in child
     * @param {cc.Sprite} sprite
     * @return {Number}
     */
    lowestAtlasIndexInChild:function (sprite) {
        var children = sprite.getChildren();

        if (!children || children.length == 0) {
            return sprite.getAtlasIndex();
        } else {
            return this.lowestAtlasIndexInChild(children.pop());
        }
    },

    /**
     * get atlas index for child
     * @param {cc.Sprite} sprite
     * @param {Number} nZ
     * @return {Number}
     */
    atlasIndexForChild:function (sprite, nZ) {
        var brothers = sprite.getParent().getChildren();
        var childIndex = cc.ArrayGetIndexOfObject(brothers, sprite);

        // ignore parent Z if parent is spriteSheet
        var ignoreParent = sprite.getParent() == this;
        var previous = null;
        if (childIndex > 0 && childIndex < cc.UINT_MAX) {
            previous = brothers[childIndex - 1];
        }

        // first child of the sprite sheet
        if (ignoreParent) {
            if (childIndex == 0) {
                return 0;
            }
            return this.highestAtlasIndexInChild(previous) + 1;
        }

        // parent is a CCSprite, so, it must be taken into account
        // first child of an CCSprite ?
        if (childIndex == 0) {
            var p = sprite.getParent();

            // less than parent and brothers
            if (nZ < 0) {
                return p.getAtlasIndex();
            } else {
                return p.getAtlasIndex() + 1;
            }
        } else {
            // previous & sprite belong to the same branch
            if ((previous.getZOrder() < 0 && nZ < 0) || (previous.getZOrder() >= 0 && nZ >= 0)) {
                return this.highestAtlasIndexInChild(previous) + 1;
            }

            // else (previous < 0 and sprite >= 0 )
            var p = sprite.getParent();
            return p.getAtlasIndex() + 1;
        }

        // Should not happen. Error calculating Z on SpriteSheet
        cc.Assert(0, "CCSpriteBatchNode.atlasIndexForChild():should not run here");
        return 0;
    },

    // CCTextureProtocol
    /**
     * Return texture of cc.SpriteBatchNode
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._textureAtlas.getTexture();
    },

    /**
     * texture of cc.SpriteBatchNode setter
     * @param {cc.Texture2D} texture
     */
    setTexture:function (texture) {
        this._textureAtlas.setTexture(texture);
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].setTexture(texture);
        }
        //this._updateBlendFunc();
    },

    /**
     * set the source blending function for the texture
     * @param {cc.BlendFunc} blendFunc
     */
    setBlendFunc:function (blendFunc) {
        this._blendFunc = blendFunc;
    },

    /**
     * returns the blending function used for the texture
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * don't call visit on it's children ( override visit of cc.Node )
     * @override
     * @param {CanvasContext} ctx
     */
    visit:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            // quick return if not visible
            if (!this._isVisible) {
                return;
            }
            context.save();
            if (this._grid && this._grid.isActive()) {
                this._grid.beforeDraw();
                this.transformAncestors();
            }
            this.transform();

            if (this._isUseCache) {
                if (this._isCacheDirty) {
                    //add dirty region
                    this._renderTexture.clear();
                    this._renderTexture.context.translate(this._anchorPointInPixels.x, -this._anchorPointInPixels.y);

                    if (this._children) {
                        for (var i = 0; i < this._children.length; i++) {
                            if (this._children[i]) {
                                this._children[i].visit(this._renderTexture.context);
                            }
                        }
                    }
                    this._isCacheDirty = false;
                }
                // draw RenderTexture
                this.draw();
            } else {
                if (this._children) {
                    for (var i = 0; i < this._children.length; i++) {
                        if (this._children[i]) {
                            this._children[i].visit(context);
                        }
                    }
                }
            }


            if (this._grid && this._grid.isActive()) {
                this._grid.afterDraw(this);
            }
            context.restore();
        }
    },

    /**
     * add child to cc.SpriteBatchNode (override addChild of cc.Node)
     * @override
     * @param {cc.Sprite} child
     * @param {Number} zOrder
     * @param {Number} tag
     */
    addChild:function (child, zOrder, tag) {
        switch (arguments.length) {
            case 1:
                this._super(child);
                break;
            case 2:
                this._super(child, zOrder);
                break;
            case 3:
                cc.Assert(child != null, "SpriteBatchNode.addChild():child should not be null");

                var sprite = child;
                // check CCSprite is using the same texture id
                if (cc.renderContextType != cc.CANVAS) {
                    cc.Assert(sprite.getTexture().getName() == this._textureAtlas.getTexture().getName(),
                        "SpriteBatchNode.addChild():check CCSprite is using the same texture id");
                }

                this._super(child, zOrder, tag);

                var index = this.atlasIndexForChild(sprite, zOrder);
                this.insertChild(sprite, index);
                break;
            case 4:
                if (arguments[3]) {
                    this._super(child, zOrder, tag);
                }
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }

        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     *  (override reorderChild of cc.Node)
     * @override
     * @param {cc.Sprite} child
     * @param {Number} zOrder
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "SpriteBatchNode.addChild():the child should not be null");
        cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():sprite batch node should contain the child");

        if (zOrder == child.getZOrder()) {
            return;
        }

        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        // xxx: instead of removing/adding, it is more efficient ot reorder manually
        this.removeChild(child, false);
        this.addChild(child, zOrder);

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * remove child from cc.SpriteBatchNode (override removeChild of cc.Node)
     * @param {cc.Sprite} child
     * @param cleanup
     */
    removeChild:function (child, cleanup) {
        // explicit null handling
        if (child == null) {
            return;
        }
        cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():sprite batch node should contain the child");

        // cleanup before removing
        this.removeSpriteFromAtlas(child);

        this._super(child, cleanup);
    },

    /**
     * <p>Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter. <br/>
     * (override removeAllChildrenWithCleanup of cc.Node)</p>
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        // Invalidate atlas index. issue #569
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var obj = this._children[i];
                if (obj) {
                    this.removeSpriteFromAtlas(obj);
                }
            }
        }

        this._super(cleanup);
        this._descendants = [];
        this._textureAtlas.removeAllQuads();
    },

    /**
     * draw cc.SpriteBatchNode (override draw of cc.Node)
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        this._super();

        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            //context.globalAlpha = this._opacity / 255;
            var pos = new cc.Point(0 | ( -this._anchorPointInPixels.x), 0 | ( -this._anchorPointInPixels.y));
            if (this._renderTexture) {
                //direct draw image by canvas drawImage
                context.drawImage(this._renderTexture.getCanvas(), pos.x, -(pos.y + this._renderTexture.getCanvas().height));
            }

            /*
             var pAp = cc.PointZero();
             if (this.getParent()) {
             pAp = this.getParent().getAnchorPointInPixels();
             }
             for (var index = 0; index < this._children.length; index++) {
             var sp = this._children[index];
             if (sp.getIsVisible()) {
             cc.saveContext();
             cc.renderContext.translate(sp.getPositionX() - pAp.x, -(sp.getPositionY() - pAp.y ));

             cc.renderContext.scale(sp.getScaleX(), sp.getScaleY());
             cc.renderContext.transform(1.0, -Math.tan(cc.DEGREES_TO_RADIANS(sp.getSkewY())), -Math.tan(cc.DEGREES_TO_RADIANS(sp.getSkewX())), 1.0, 0, 0);

             cc.renderContext.rotate(cc.DEGREES_TO_RADIANS(sp.getRotation()));
             cc.renderContext.globalAlpha = sp.getOpacity() / 255;
             if (sp._flipX) {
             cc.renderContext.scale(-1, 1);
             }
             if (sp._flipY) {
             cc.renderContext.scale(1, -1);
             }

             if ((sp.getContentSize().width == 0) && (sp.getContentSize().height == 0)) {
             cc.drawingUtil.drawImage(sp.getTexture(), cc.ccp(0 - sp.getAnchorPointInPixels().x, 0 - sp.getAnchorPointInPixels().y));
             } else {
             cc.drawingUtil.drawImage(sp.getTexture(), sp.getTextureRect().origin, sp.getTextureRect().size
             , cc.ccp(0 - sp.getAnchorPointInPixels().x, 0 - sp.getAnchorPointInPixels().y), sp.getContentSize());
             }
             cc.restoreContext();
             }
             }
             */
        } else {
            // Optimization: Fast Dispatch
            if (this._textureAtlas.getTotalQuads() == 0) {
                return;
            }

            if (this._descendants && this._descendants.length > 0) {
                var obj = null;
                for (var i = 0; i < this._descendants.length; i++) {
                    obj = this._descendants[i];
                    if (obj) {
                        obj.updateTransform();

                        // issue #528
                        var rect = obj.boundingBox();
                        var vertices = [
                            cc.ccp(rect.origin.x, rect.origin.y),
                            cc.ccp(rect.origin.x + rect.size.width, rect.origin.y),
                            cc.ccp(rect.origin.x + rect.size.width, rect.origin.y + rect.size.height),
                            cc.ccp(rect.origin.x, rect.origin.y + rect.size.height)
                        ];
                        cc.drawingUtil.drawPoly(vertices, 4, true);
                    }
                }
            }

            // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Unneeded states: -
            //TODO OpenGL Method
            var newBlend = this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST;
            if (newBlend) {
                //glBlendFunc(m_blendFunc.src, m_blendFunc.dst);
            }

            this._textureAtlas.drawQuads();
            if (newBlend) {
                //glBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);
            }
        }
    }
});

/**
 * <p>
 *    creates a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) with a default capacity of 29 children.<br/>
 *    The capacity will be increased in 33% in runtime if it run out of space.<br/>
 *    The file will be loaded using the TextureMgr.<br/>
 * </p>
 * @param {String} fileImage
 * @param {Number} capacity
 * @return {cc.SpriteBatchNode}
 * @example
 * //create a SpriteBatchNode
 * var parent2 = cc.SpriteBatchNode.create("Resources/animations/grossini.png", 50);
 */
cc.SpriteBatchNode.create = function (fileImage, capacity) {
    if (!capacity) {
        capacity = cc.DEFAULT_CAPACITY;
    }

    var batchNode = new cc.SpriteBatchNode();
    batchNode.initWithFile(fileImage, capacity);

    return batchNode;
};

/**
 * <p>
 *   creates a CCSpriteBatchNode with a texture2d and a default capacity of 29 children.<br/>
 *   The capacity will be increased in 33% in runtime if it run out of space.<br/>
 * </p>
 * @param {cc.Texture2D} texture
 * @param {Number} capacity
 * @return {cc.SpriteBatchNode}
 */
cc.SpriteBatchNode.createWithTexture = function (texture, capacity) {
    if (!capacity) {
        capacity = cc.DEFAULT_CAPACITY;
    }

    var batchNode = new cc.SpriteBatchNode();
    batchNode.initWithTexture(texture, capacity);

    return batchNode;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * using image file to print text label on the screen, might be a bit slower than cc.Label, similar to cc.LabelBMFont
 * @class
 * @extends cc.AtlasNode
 */
cc.LabelAtlas = cc.AtlasNode.extend(/** @lends cc.LabelAtlas# */{
    /**
     * initializes the cc.LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas
     * @param {String} label
     * @param {String} charMapFile
     * @param {Number} itemWidth
     * @param {Number} itemHeight
     * @param {String} startCharMap
     * @return {Boolean} returns true on success
     */
    initWithString:function (label, charMapFile, itemWidth, itemHeight, startCharMap) {
        cc.Assert(label != null, "");
        if (this.initWithTileFile(charMapFile, itemWidth, itemHeight, label.length)) {
            this._mapStartChar = startCharMap;
            this.setString(label);
            return true;
        }
        return false;
    },

    /**
     *  Atlas generation
     */
    updateAtlasValues:function () {
        var texture = this.getTexture();

        for (var i = 0; i < this._string.length; i++) {
            var a = this._string.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
            var row = parseInt(a % this._itemsPerRow);
            var col = parseInt(a / this._itemsPerRow);

            var rect = cc.RectMake(row * this._itemWidth, col * this._itemHeight, this._itemWidth, this._itemHeight);
            var c = this._string.charCodeAt(i);
            var fontChar = this.getChildByTag(i);
            if (!fontChar) {
                fontChar = new cc.Sprite();
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.RectMake(0, 0, 0, 0));
                }
                else {
                    fontChar.initWithTexture(texture, rect);
                }
                this.addChild(fontChar, 0, i);
            }
            else {
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.RectMake(0, 0, 0, 0));
                }
                else {
                    // reusing fonts
                    fontChar.initWithTexture(texture, rect);
                    // restore to default in case they were modified
                    fontChar.setIsVisible(true);
                    fontChar.setOpacity(this._opacity);
                }
            }
            fontChar.setPosition(new cc.Point(i * this._itemWidth + this._itemWidth / 2, this._itemHeight / 2));
        }
    },

    /**
     * set the display string
     * @param {String} label
     */
    setString:function (label) {
        this._string = label;
        var len = label.length;
        this._textureAtlas.resizeCapacity(len);

        var s = new cc.Size();
        s.width = len * this._itemWidth;
        s.height = this._itemHeight;
        this.setContentSizeInPixels(s);

        if (this._children) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    node.setIsVisible(false);
                }
            }
        }
        this.updateAtlasValues();
    },
    /**
     * @param {cc.Color3B} color3
     */
    setColor:function(color3){
        this._super(color3);
        this.updateAtlasValues();
    },
    /**
     * return the text of this label
     * @return {String}
     */
    getString:function () {
        return this._string;
    },

    /**
     * draw the label
     */
    draw:function () {
        this._super();
        if (cc.LABELATLAS_DEBUG_DRAW) {
            var s = this.getContentSize();
            var vertices = [cc.ccp(0, 0), cc.ccp(s.width, 0),
                cc.ccp(s.width, s.height), cc.ccp(0, s.height)];
            cc.drawingUtil.drawPoly(vertices, 4, true);
        }
    },

    convertToLabelProtocol:function () {
        return this;
    },

    // string to render
    _string:null,
    // the first char in the charmap
    _mapStartChar:null
});

/**
 * creates the cc.LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the
 * starting char of the atlas
 * @param {String} label Text to display
 * @param {String} charMapFile the character map file
 * @param {Number} itemWidth the width of individual letter
 * @param {Number} itemHeight the height of individual letter
 * @param {String} startCharMap starting character on the character map file
 * @return {cc.LabelAtlas|Null} returns the LabelAtlas object on success
 * @example
 * //Example
 * var myLabel = cc.LabelAtlas.create('Text to display', 'CharMapfile.png', 12, 20, ' ')
 */
cc.LabelAtlas.create = function (label, charMapFile, itemWidth, itemHeight, startCharMap) {
    var ret = new cc.LabelAtlas();
    if (ret && ret.initWithString(label, charMapFile, itemWidth, itemHeight, startCharMap)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.LabelTTF is a subclass of cc.TextureNode that knows how to render text labels<br/>
 * All features from cc.TextureNode are valid in cc.LabelTTF<br/>
 * cc.LabelTTF objects are slow for js-binding on mobile devices.<br/>
 * Consider using cc.LabelAtlas or cc.LabelBMFont instead.<br/>
 * @class
 * @extends cc.Sprite
 */
cc.LabelTTF = cc.Sprite.extend(/** @lends cc.LabelTTF# */{
    _dimensions:null,
    _alignment:cc.TEXT_ALIGNMENT_CENTER,
    _fontName:"Arial",
    _fontSize:0.0,
    _string:null,
    _fontStyleStr:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        this._string = "";
        this._color = cc.WHITE();
        this._opacityModifyRGB = false;
        this._fontStyleStr = "";
    },

    /**
     * Prints out a description of this class
     * @return {String}
     */
    description:function () {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">";
    },

    /**
     * initializes the cc.LabelTTF with a font name, alignment, dimension and font size
      * @param {String} label
     * @param {cc.Size} dimensions
     * @param {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} alignment
     * @param {String} fontName
     * @param {Number} fontSize
     * @return {Boolean} return false on error
     */
    initWithString:function (label, dimensions, alignment, fontName, fontSize) {
        cc.Assert(label != null, "cc.LabelTTF.initWithString() label is null");
        if (arguments.length > 3) {
            if (this.init()) {
                this._dimensions = cc.SizeMake(dimensions.width * cc.CONTENT_SCALE_FACTOR(), dimensions.height * cc.CONTENT_SCALE_FACTOR());
                this._alignment = alignment;
                this._fontName = fontName;
                this._fontSize = fontSize * cc.CONTENT_SCALE_FACTOR();
                this.setString(label);
                this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
                return true;
            }
            return false;
        } else {
            fontName = arguments[1];
            fontSize = arguments[2];

            if (this.init()) {
                this._dimensions = cc.SizeZero();
                this._fontName = fontName;
                this._fontSize = fontSize * cc.CONTENT_SCALE_FACTOR();
                this.setString(label);
                this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
                return true;
            }
            return false;
        }
    },

    /**
     * changes the string to render
     * @warning Changing the string is as expensive as creating a new cc.LabelTTF. To obtain better performance use cc.LabelAtlas
     * @param {String} label text for the label
     */
    setString:function (label) {
        this._string = label;
        cc.renderContext.save();
        cc.renderContext.font = this._fontSize + "px '" + this._fontName + "'";
        var dim = cc.renderContext.measureText(this._string);
        this.setContentSize(new cc.Size(dim.width, this._fontSize));
        cc.renderContext.restore();
        this.setNodeDirty();
        return;

        var texture = new cc.Texture2D();
        if (cc.Size.CCSizeEqualToSize(this._dimensions, cc.SizeZero())) {
            texture.initWithString(label, this._fontName, this._fontSize);
        } else {
            texture = new cc.Texture2D();
            texture.initWithString(label, this._dimensions, this._alignment, this._fontName, this._fontSize);
        }
        this.setTexture(texture);

        var rect = cc.RectZero();
        rect.size = this._texture.getContentSize();
        this.setTextureRect(rect);
    },

    /**
     * renders the label
     * @param {CanvasContext|Null} ctx
     */
    draw:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            if (this._flipX) {
                context.scale(-1, 1);
            }
            if (this._flipY) {
                context.scale(1, -1);
            }
            //this is fillText for canvas
            var color = this._color;
            context.fillStyle = "rgba(" + color.r + "," + color.g + "," + color.b + ", " + this._opacity / 255 + ")";

            if (context.font != this._fontStyleStr)
                context.font = this._fontStyleStr;

            var offset = 0;
            switch (this._alignment) {
                case cc.TEXT_ALIGNMENT_LEFT:
                    offset = -(this._dimensions.width - this._contentSize.width) / 2;
                    break;
                case cc.TEXT_ALIGNMENT_RIGHT:
                    offset = (this._dimensions.width - this._contentSize.width) / 2;
                    break;
                default:
                    break;
            }

            if (this._contentSize.width > this._dimensions.width && this._dimensions.width !== 0) {
                this._wrapText(context, this._string,
                    -this._dimensions.width * this._anchorPoint.x,
                    -this._dimensions.height * this._anchorPoint.y,
                    this._dimensions.width,
                    this._fontSize * 1.2,
                    this._alignment);
            }
            else {
                context.fillText(this._string,
                    -this._contentSize.width * this._anchorPoint.x + offset,
                    this._contentSize.height * this._anchorPoint.y);
            }
        }
    },
    _wrapText:function (context, text, x, y, maxWidth, lineHeight, texAlign) {
        var words = text.split(" ");
        var line = "";
        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + " ";
            var testWidth = context.measureText(testLine).width - context.measureText(" ").width;
            if (testWidth >= maxWidth) {
                var temWidth = testWidth - context.measureText(words[n]).width - 2 * context.measureText(" ").width;
                var offset;
                switch (texAlign) {
                    case cc.TEXT_ALIGNMENT_LEFT:
                        offset = 0
                        break;
                    case cc.TEXT_ALIGNMENT_RIGHT:
                        offset = maxWidth - temWidth;
                        break;
                    default:
                        offset = (maxWidth - temWidth) / 2;
                        break;
                }
                context.fillText(line, x + offset, y);
                y += lineHeight;
                line = words[n] + " ";
            }
            else {
                line = testLine;
                if (n == words.length - 1) {
                    context.fillText(line, x + offset, y);
                }
            }

        }
    },

    /**
     * returns the text of the label
     * @return {String}
     */
    getString:function () {
        return this._string;
    },

    /**
     *
     * @return {cc.LabelTTF}
     */
    convertToLabelProtocol:function () {
        return this;
    }
});

/**
 * creates a cc.LabelTTF from a fontname, alignment, dimension and font size
 * @param {String} label
 * @param {cc.Size} dimensions
 * @param {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} alignment
 * @param {String} fontName
 * @param {Number} fontSize
 * @return {cc.LabelTTF|Null}
 * @example
 * // Example
 * var myLabel = cc.LabelTTF.create('label text', cc.SizeMake(32,16), cc.TEXT_ALIGNMENT_LEFT, 'Times New Roman', 32);
 */
cc.LabelTTF.create = function (label, dimensions, alignment, fontName, fontSize) {
    var ret = new cc.LabelTTF();
    if (arguments.length > 3) {
        if ((ret != null) && (ret.initWithString(label, dimensions, alignment, fontName, fontSize))) {
            return ret;
        }
        return null;
    } else {
        fontName = arguments[1];
        fontSize = arguments[2];
        if ((ret != null) && (ret.initWithString(label, fontName, fontSize))) {
            return ret;
        }

        return null;
    }
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 Use any of these editors to generate BMFonts:
 http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)
 http://www.n4te.com/hiero/hiero.jnlp (Free, Java)
 http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)
 http://www.angelcode.com/products/bmfont/ (Free, Windows only)
 ****************************************************************************/

cc._KerningHashElement = function(key, amount) {
    this.key = key;	// key for the hash. 16-bit for 1st element, 16-bit for 2nd element
    this.amount = amount;
};


cc._BMFontDef = function(charID, rect, xOffset, yOffset, xAdvance) {
    //! ID of the character
    this.charID = charID || 0;
    //! origin and size of the font
    this.rect = rect || new cc.RectMake(0, 0, 10, 10);
    //! The X amount the image should be offset when drawing the image (in pixels)
    this.xOffset = xOffset || 0;
    //! The Y amount the image should be offset when drawing the image (in pixels)
    this.yOffset = yOffset || 0;
    //! The amount to move the current position after drawing the character (in pixels)
    this.xAdvance = xAdvance || 0;
};

cc._BMFontPadding = function(left, top, right, bottom) {
    /// padding left
    this.left = left || 0;
    /// padding top
    this.top = top || 0;
    /// padding right
    this.right = right || 0;
    /// padding bottom
    this.bottom = bottom || 0;
};

/**
 * cc.BMFontConfiguration has parsed _configuration of the the .fnt file
 * @class
 * @extends cc.Class
 */
cc.BMFontConfiguration = cc.Class.extend(/** @lends cc.BMFontConfiguration# */{
    // XXX: Creating a public interface so that the bitmapFontArray[] is acc.esible
    //@public
    /**
     *  The characters building up the font
     *  @type object
     */
    bitmapFontArray:{},
    /**
     * FNTConfig: Common Height
     * @type Number
     */
    commonHeight:0,
    /**
     *  Padding
     *  @type cc._BMFontPadding
     */
    padding:new cc._BMFontPadding(),
    /**
     * atlas name
     * @type String
     */
    atlasName:"",
    /**
     * values for kerning
     * @type cc._KerningHashElement
     */
    kerningDictionary:{},

    /**
     * Description of BMFontConfiguration
     * @return {String}
     */
    description:function () {
        var ret = "<cc.BMFontConfiguration | Kernings:" + this.kerningDictionary + " | Image = " + this.atlasName.toString() + ">";
        return ret;
    },

    /**
     * initializes a BitmapFontConfiguration with a FNT file
     * @param {String} FNTfile
     * @return {Boolean}
     */
    initWithFNTfile:function (FNTfile) {
        cc.Assert(FNTfile != null && FNTfile.length != 0, "");
        this._parseConfigFile(FNTfile);
        return true;
    },

    _parseConfigFile:function (controlFile) {
        var data = cc.SAXParser.shareParser().getList(controlFile);
        cc.Assert(data, "cc.BMFontConfiguration._parseConfigFile | Open file error.");

        // parse spacing / padding
        var line, re;

        re = /padding+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseInfoArguments(line);
        }

        re = /common lineHeight+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseCommonArguments(line);
        }

        re = /page id=[a-zA-Z0-9\.\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseImageFileName(line, controlFile);
        }

        re = /chars c+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            // Ignore this line
        }

        re = /char id=\w[a-z0-9\-= ]+/gi;
        line = data.match(re);
        if (line) {
            // Parse the current line and create a new CharDef
            for (var i = 0; i < line.length; i++) {
                var characterDefinition = new cc._BMFontDef();
                this._parseCharacterDefinition(line[i], characterDefinition);
                //Add the CharDef returned to the charArray
                this.bitmapFontArray[characterDefinition.charID] = characterDefinition;
            }
        }

        re = /kernings count+[a-z0-9\-= ",]+/gi;
        if(re.test(data)){
        line = RegExp.$1[0];
        }
        if (line) {
            this._parseKerningCapacity(line);
        }

        re = /first=\w[a-z0-9\-= ]+/gi;
        line = data.match(re);
        if (line) {
            for (var i = 0; i < line.length; i++) {
                this._parseKerningEntry(line[i]);
            }
        }
    },
    _parseCharacterDefinition:function (line, characterDefinition) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=44    xadvance=14     page=0  chnl=0
        //////////////////////////////////////////////////////////////////////////
        // Character ID
        var value = /id=(\d+)/gi.exec(line)[1];
        characterDefinition.charID = value.toString();

        // Character x
        value = /x=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.origin.x = parseInt(value);

        // Character y
        value = /y=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.origin.y = parseInt(value);

        // Character width
        value = /width=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.size.width = parseInt(value);

        // Character height
        value = /height=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.size.height = parseInt(value);

        // Character xoffset
        value = /xoffset=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.xOffset = parseInt(value);

        // Character yoffset
        value = /yoffset=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.yOffset = parseInt(value);

        // Character xadvance
        value = /xadvance=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.xAdvance = parseInt(value);

    },
    _parseInfoArguments:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // possible lines to parse:
        // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1,4,3,2 spacing=0,0 outline=0
        // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1
        //////////////////////////////////////////////////////////////////////////

        // padding
        var tmpPadding = /padding=(\d+)[,](\d+)[,](\d+)[,](\d+)/gi.exec(line);
        this.padding.left = tmpPadding[1];
        this.padding.top = tmpPadding[2]
        this.padding.right = tmpPadding[3];
        this.padding.bottom = tmpPadding[4];
    },
    _parseCommonArguments:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // common lineHeight=104 base=26 scaleW=1024 scaleH=512 pages=1 packed=0
        //////////////////////////////////////////////////////////////////////////

        var value;
        // Height
        this.commonHeight = /lineHeight=(\d+)/gi.exec(line)[1];

        // pages. sanity check
        value = /pages=(\d+)/gi.exec(line)[1];
        cc.Assert(parseInt(value) == 1, "cc.BitfontAtlas: only supports 1 page");

        // packed (ignore) What does this mean ??
    },
    _parseImageFileName:function (line, fntFile) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // page id=0 file="bitmapFontTest.png"
        //////////////////////////////////////////////////////////////////////////
        var value;
        // page ID. Sanity check
        value = /id=(\d+)/gi.exec(line)[1];
        cc.Assert(parseInt(value) == 0, "LabelBMFont file could not be found");

        // file
        value = /file="([a-zA-Z0-9\-\._]+)/gi.exec(line)[1];

        this.atlasName = cc.FileUtils.fullPathFromRelativeFile(value, fntFile);
    },
    _parseKerningCapacity:function (line) {
    },
    _parseKerningEntry:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // kerning first=121  second=44  amount=-7
        //////////////////////////////////////////////////////////////////////////
        // first
        var value = /first=([\-\d]+)/gi.exec(line)[1];
        var first = parseInt(value);

        // second
        value = /second=([\-\d]+)/gi.exec(line)[1];
        var second = parseInt(value);

        // amount
        value = /amount=([\-\d]+)/gi.exec(line)[1];
        var amount = parseInt(value);

        var element = new cc._KerningHashElement();
        element.amount = amount;
        element.key = (first << 16) | (second & 0xffff);

        this.kerningDictionary[element.key] = element;

    },
    _purgeKerningDictionary:function () {
        this.kerningDictionary = {};
    }
});

/**
 * Create a cc.BMFontConfiguration
 * @param {String} FNTfile
 * @return {cc.BMFontConfiguration|Null} returns the configuration or null if error
 * @example
 * // Example
 * var conf = cc.BMFontConfiguration.create('myfont.fnt');
 */
cc.BMFontConfiguration.create = function (FNTfile) {
    var ret = new cc.BMFontConfiguration();
    if (ret.initWithFNTfile(FNTfile)) {
        return ret;
    }
    return null;
};

/**
 * <p>cc.LabelBMFont is a subclass of cc.SpriteSheet.</p>

 <p>Features:<br/>
 <ul><li>- Treats each character like a cc.Sprite. This means that each individual character can be:</li>
 <li>- rotated</li>
 <li>- scaled</li>
 <li>- translated</li>
 <li>- tinted</li>
 <li>- chage the opacity</li>
 <li>- It can be used as part of a menu item.</li>
 <li>- anchorPoint can be used to align the "label"</li>
 <li>- Supports AngelCode text format</li></ul></p>

 <p>Limitations:<br/>
 - All inner characters are using an anchorPoint of (0.5, 0.5) and it is not recommend to change it
 because it might affect the rendering</p>

 <p>cc.LabelBMFont implements the protocol cc.LabelProtocol, like cc.Label and cc.LabelAtlas.<br/>
 cc.LabelBMFont has the flexibility of cc.Label, the speed of cc.LabelAtlas and all the features of cc.Sprite.<br/>
 If in doubt, use cc.LabelBMFont instead of cc.LabelAtlas / cc.Label.</p>

 <p>Supported editors:<br/>
 http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)<br/>
 http://www.n4te.com/hiero/hiero.jnlp (Free, Java)<br/>
 http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)<br/>
 http://www.angelcode.com/products/bmfont/ (Free, Windows only)</p>
 * @class
 * @extends cc.
 */
cc.LabelBMFont = cc.SpriteBatchNode.extend(/** @lends cc.LabelBMFont# */{
    _opacity:0,
    _color:null,
    _isOpacityModifyRGB:false,
    _string:"",
    _configuration:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        //LabelBMFont - Debug draw
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            this.draw();
            var s = this.getContentSize();
            var vertices = [cc.ccp(0, 0), cc.ccp(s.width, 0),
                cc.ccp(s.width, s.height), cc.ccp(0, s.height)];
            cc.drawPoly(vertices, 4, true);
        }

    },

    /**
     * conforms to cc.RGBAProtocol protocol
      * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * set the opacity of this label
     * @param {Number} Var
     */
    setOpacity:function (Var) {
        this._opacity = Var;
        if (this._children) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var node = this._children[i];
                if (node) {
                    node.setOpacity(this._opacity);
                }
            }
        }
    },

    /**
     * conforms to cc.RGBAProtocol protocol
      * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * tint this label
     * @param {cc.Color3B} Var
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r)&&(this._color.g == color3.g)&&(this._color.b == color3.b)) {
            return;
        }
        this._color = color3;
        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.sharedTextureCache().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    //generate color texture cache
                    var tx = this.getTexture();
                    var textureRect = new cc.Rect(0,0,tx.width,tx.height);
                    var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color,textureRect);
                    var img = new Image();
                    img.src = colorTexture.toDataURL();
                    this.setTexture(img);
                }
            }
        }
    },

    /**
     * conforms to cc.RGBAProtocol protocol
      * @return {Boolean}
     */
    getIsOpacityModifyRGB:function () {
        return this._isOpacityModifyRGB;
    },

    /**
     *
     * @param {Boolean} Var
     */
    setIsOpacityModifyRGB:function (Var) {
        this._isOpacityModifyRGB = Var;
        if (this._children && this._children.length != 0) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var node = this._children[i];
                if (node) {
                    var pRGBAProtocol = node instanceof cc.RGBAProtocol;
                    if (pRGBAProtocol) {
                        pRGBAProtocol.setIsOpacityModifyRGB(this._isOpacityModifyRGB);
                    }
                }
            }
        }
    },


    /**
     * init a bitmap font altas with an initial string and the FNT file
      * @param {String} theString
     * @param {String} fntFile
     * @return {Boolean}
     */
    initWithString:function (theString, fntFile) {
        cc.Assert(theString != null, "");
        this._configuration = cc.FNTConfigLoadFile(fntFile);

        cc.Assert(this._configuration, "Error creating config for LabelBMFont");
        if (this.initWithFile(this._configuration.atlasName, theString.length)) {
            this._opacity = 255;
            this._color = cc.WHITE();
            this._contentSize = cc.SizeZero();
            this.setAnchorPoint(cc.ccp(0.5, 0.5));
            this.setString(theString);
            return true;
        }
        return false;
    },

    /**
     * updates the font chars based on the string to render
      */
    createFontChars:function () {
        var nextFontPositionX = 0;
        var nextFontPositionY = 0;
        var prev = -1;
        var kerningAmount = 0;

        var tmpSize = cc.SizeZero();

        var longestLine = 0;
        var totalHeight = 0;

        var quantityOfLines = 1;

        var stringLen = this._string.length;

        if (stringLen == 0) {
            return;
        }

        for (var i = 0; i < stringLen; i++) {
            var c = this._string.charCodeAt(i);
            if (c == 10) {
                quantityOfLines++;
            }
        }

        totalHeight = this._configuration.commonHeight * quantityOfLines;
        nextFontPositionY = -(this._configuration.commonHeight - this._configuration.commonHeight * quantityOfLines);

        for (var i = 0; i < stringLen; i++) {
            var c = this._string.charCodeAt(i);

            if (c == 10) {
                nextFontPositionX = 0;
                nextFontPositionY -= this._configuration.commonHeight;
                continue;
            }

            kerningAmount = this._kerningAmountForFirst(prev, c);

            var fontDef = this._configuration.bitmapFontArray[c];

            var rect = fontDef.rect;

            var fontChar = this.getChildByTag(i);
            if (!fontChar) {
                fontChar = new cc.Sprite();
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(rect);
                }
                else {
                    fontChar.initWithBatchNodeRectInPixels(this, rect);
                }
                this.addChild(fontChar, 0, i);
            }
            else {
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.RectMake(0, 0, 0, 0));
                }
                else {
                    // reusing fonts
                    fontChar.initWithBatchNodeRectInPixels(this, rect);
                    // restore to default in case they were modified
                    fontChar.setIsVisible(true);
                    fontChar.setOpacity(255);
                }
            }

            var yOffset = this._configuration.commonHeight - fontDef.yOffset;
            fontChar.setPositionInPixels(cc.ccp(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0 + kerningAmount,
                nextFontPositionY + yOffset - rect.size.height / 2.0));

            // update kerning
            nextFontPositionX += this._configuration.bitmapFontArray[c].xAdvance + kerningAmount;
            prev = c;

            // Apply label properties
            fontChar.setIsOpacityModifyRGB(this._isOpacityModifyRGB);
            // Color MUST be set before opacity, since opacity might change color if OpacityModifyRGB is on
            //fontChar.setColor(this._color);

            // only apply opacity if it is different than 255 )
            // to prevent modifying the color too (issue #610)
            if (this._opacity != 255) {
                fontChar.setOpacity(this._opacity);
            }

            if (longestLine < nextFontPositionX) {
                longestLine = nextFontPositionX;
            }
        }

        tmpSize.width = longestLine;
        tmpSize.height = totalHeight;
        this.setContentSizeInPixels(tmpSize);
    },

    /**
     * get the text of this label
     * @return {String}
     */
    getString:function () {
        return this._string;
    },

    /**
     * set the text
     * @param newString
     */
    setString:function (newString) {
        this._string = newString;

        if (this._children) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    node.setIsVisible(false);
                }
            }
        }
        this.createFontChars();
    },

    /**
     * @deprecated
     * @param label
     */
    setCString:function (label) {
        this.setString(label);
    },

    /**
     * set the anchorpoint of the label
     * @param {cc.Point} point
     */
    setAnchorPoint:function (point) {
        if (!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
            this._super(point);
            this.createFontChars();
        }
    },

    _atlasNameFromFntFile:function (fntFile) {
    },
    _kerningAmountForFirst:function (first, second) {
        var ret = 0;
        var key = (first << 16) | (second & 0xffff);
        if (this._configuration.kerningDictionary) {
            var element = this._configuration.kerningDictionary[key.toString()];
            if (element) {
                ret = element.amount;
            }
        }
        return ret;
    }

});

/**
 * creates a bitmap font altas with an initial string and the FNT file
 * @param {String} str
 * @param {String} fntFile
 * @return {cc.LabelBMFont}
 * @example
 * // Example
 * var label = cc.LabelBMFont.create('label text', 'fontfile.fnt')
 */
cc.LabelBMFont.create = function (str, fntFile) {
    var ret = new cc.LabelBMFont();
    if (ret && ret.initWithString(str, fntFile)) {
        return ret;
    }
    return null;
};

/**
 * shared instance of configuration
 * @type cc.BMFontConfiguration
 */
cc.configurations = null;

/**
 * Load the .fnt file
 * @param {String} fntFile
 * @return {cc.BMFontConfiguration}
 * Constructor
 */
cc.FNTConfigLoadFile = function (fntFile) {
    if (!cc.configurations) {
        cc.configurations = {};
    }
    var ret = cc.configurations[fntFile];
    if (!ret) {
        ret = cc.BMFontConfiguration.create(fntFile);
    }
    return ret;
};

/**
 * Purges the cached .fnt data
 */
cc.purgeCachedData = function () {
    cc.FNTConfigRemoveCache();
};

/**
 * Purges the FNT config cache
 */
cc.FNTConfigRemoveCache = function () {
    if (cc.configurations) {
        cc.configurations = {};
    }
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

// ideas taken from:
//	 . The ocean spray in your face [Jeff Lander]
//		http://www.double.co.nz/dust/col0798.pdf
//	 . Building an Advanced Particle System [John van der Burg]
//		http://www.gamasutra.com/features/20000623/vanderburg_01.htm
//   . LOVE game engine
//		http://love2d.org/
//
//
// Radius mode support, from 71 squared
//		http://particledesigner.71squared.com/
//
// IMPORTANT: Particle Designer is supported by cocos2d, but
// 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
//  cocos2d uses a another approach, but the results are almost identical.
//

/**
 * Shape Mode of Particle Draw
 * @constant
 * @type Number
 */
cc.PARTICLE_SHAPE_MODE = 0;
/**
 * Texture Mode of Particle Draw
 * @constant
 * @type Number
 */
cc.PARTICLE_TEXTURE_MODE = 1;

/**
 * Star Shape for ShapeMode of Particle
 * @constant
 * @type Number
 */
cc.PARTICLE_STAR_SHAPE = 0;
/**
 * Ball Shape for ShapeMode of Particle
 * @constant
 * @type Number
 */
cc.PARTICLE_BALL_SHAPE = 1;

/**
 * The Particle emitter lives forever
 * @constant
 * @type Number
 */
cc.CCPARTICLE_DURATION_INFINITY = -1;

/**
 * The starting size of the particle is equal to the ending size
 * @constant
 * @type Number
 */
cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE = -1;

/**
 * The starting radius of the particle is equal to the ending radius
 * @constant
 * @type Number
 */
cc.CCPARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS = -1;

/**
 * backward compatible
 * @constant
 * @type Number
 */
cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
cc.PARTICLE_DURATION_INFINITY = cc.CCPARTICLE_DURATION_INFINITY;


/**
 * Gravity mode (A mode)
 * @constant
 * @type Number
 */
cc.CCPARTICLE_MODE_GRAVITY = 0;

/**
 * Radius mode (B mode)
 * @constant
 * @type Number
 */
cc.CCPARTICLE_MODE_RADIUS = 1;

 // tCCPositionType
 // possible types of particle positions

/**
 * Living particles are attached to the world and are unaffected by emitter repositioning.
 * @constant
 * @type Number
 */
cc.CCPARTICLE_TYPE_FREE = 0;

/**
 * Living particles are attached to the world but will follow the emitter repositioning.<br/>
 * Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.
 * @constant
 * @type Number
 */
cc.CCPARTICLE_TYPE_RELATIVE = 1;

/**
 * Living particles are attached to the emitter and are translated along with it.
 * @constant
 * @type Number
 */
cc.CCPARTICLE_TYPE_GROUPED = 2;

// backward compatible
cc.PARTICLE_TYPE_FREE = cc.CCPARTICLE_TYPE_FREE;
cc.PARTICLE_TYPE_GROUPED = cc.CCPARTICLE_TYPE_GROUPED;


/**
 * Structure that contains the values of each particle
 * @Class
 * @Construct
 * @param {cc.Point} pos Position of particle
 * @param {cc.Point} startPos
 * @param {cc.Color4F} color
 * @param {cc.Color4F} deltaColor
 * @param {cc.Size} size
 * @param {cc.Size} deltaSize
 * @param {Number} rotation
 * @param {Number} deltaRotation
 * @param {Number} timeToLive
 * @param {cc.Particle.ModeA} modeA
 * @param {cc.Particle.ModeA} modeB
 */
cc.Particle = function (pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, modeA, modeB) {
    this.pos = pos ? pos : cc.PointZero();
    this.startPos = startPos ? startPos : cc.PointZero();
    this.color = color ? color : new cc.Color4F(0, 0, 0, 1);
    this.deltaColor = deltaColor ? deltaColor : new cc.Color4F(0, 0, 0, 1);
    this.size = size || 0;
    this.deltaSize = deltaSize || 0;
    this.rotation = rotation || 0;
    this.deltaRotation = deltaRotation || 0;
    this.timeToLive = timeToLive || 0;
    this.modeA = modeA ? modeA : new cc.Particle.ModeA();
    this.modeB = modeB ? modeB : new cc.Particle.ModeB();
    this.isChangeColor = false;
    this.drawPos = new cc.Point(0, 0);
};

/**
 * Mode A: gravity, direction, radial accel, tangential accel
 * @Class
 * @Construct
 * @param {cc.Point} dir direction of particle
 * @param {Number} radialAccel
 * @param {Number} tangentialAccel
 */
cc.Particle.ModeA = function (dir, radialAccel, tangentialAccel) {
    this.dir = dir ? dir : cc.PointZero();
    this.radialAccel = radialAccel || 0;
    this.tangentialAccel = tangentialAccel || 0;
};

/**
 * Mode B: radius mode
 * @Class
 * @Construct
 * @param {Number} angle
 * @param {Number} degreesPerSecond
 * @param {Number} radius
 * @param {Number} deltaRadius
 */
cc.Particle.ModeB = function (angle, degreesPerSecond, radius, deltaRadius) {
    this.angle = angle || 0;
    this.degreesPerSecond = degreesPerSecond || 0;
    this.radius = radius || 0;
    this.deltaRadius = deltaRadius || 0;
};


/**
 * <p>
 *     Particle System base class. <br/>
 *     Attributes of a Particle System:<br/>
 *     - emmision rate of the particles<br/>
 *     - Gravity Mode (Mode A): <br/>
 *     - gravity <br/>
 *     - direction <br/>
 *     - speed +-  variance <br/>
 *     - tangential acceleration +- variance<br/>
 *     - radial acceleration +- variance<br/>
 *     - Radius Mode (Mode B):      <br/>
 *     - startRadius +- variance    <br/>
 *     - endRadius +- variance      <br/>
 *     - rotate +- variance         <br/>
 *     - Properties common to all modes: <br/>
 *     - life +- life variance      <br/>
 *     - start spin +- variance     <br/>
 *     - end spin +- variance       <br/>
 *     - start size +- variance     <br/>
 *     - end size +- variance       <br/>
 *     - start color +- variance    <br/>
 *     - end color +- variance      <br/>
 *     - life +- variance           <br/>
 *     - blending function          <br/>
 *     - texture                    <br/>
 *                                  <br/>
 *     cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).<br/>
 *     'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,  <br/>
 *     cocos2d uses a another approach, but the results are almost identical.<br/>
 *     cocos2d supports all the variables used by Particle Designer plus a bit more:  <br/>
 *     - spinning particles (supported when using CCParticleSystemQuad)       <br/>
 *     - tangential acceleration (Gravity mode)                               <br/>
 *     - radial acceleration (Gravity mode)                                   <br/>
 *     - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only) <br/>
 *     It is possible to customize any of the above mentioned properties in runtime. Example:   <br/>
 * </p>
 * @class
 * @extends cc.Node
 *
 * @example
 *  emitter.radialAccel = 15;
 *  emitter.startSpin = 0;
 */
cc.ParticleSystem = cc.Node.extend(/** @lends cc.ParticleSystem# */{
    //***********variables*************
    _plistFile:"",
    //! time elapsed since the start of the system (in seconds)
    _elapsed:0,

    // Different modes
    //! Mode A:Gravity + Tangential Accel + Radial Accel
    modeA:null,
    //! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
    modeB:null,

    //! Array of particles
    _particles:null,

    // color modulate
    //	BOOL colorModulate;

    //! How many particles can be emitted per second
    _emitCounter:0,
    //!  particle idx
    _particleIdx:0,

    // profiling
    _profilingTimer:null,

    //drawMode
    _drawMode:cc.PARTICLE_SHAPE_MODE,

    /**
     * Return DrawMode of ParticleSystem
     * @return {Number}
     */
    getDrawMode:function () {
        return this._drawMode;
    },

    /**
     * DrawMode of ParticleSystem setter
     * @param {Number} drawMode
     */
    setDrawMode:function (drawMode) {
        this._drawMode = drawMode;
    },

    //shape type
    _shapeType:cc.PARTICLE_BALL_SHAPE,

    /**
     * Return ShapeType of ParticleSystem
     * @return {Number}
     */
    getShapeType:function () {
        return this._shapeType;
    },

    /**
     * ShapeType of ParticleSystem setter
     * @param {Number} shapeType
     */
    setShapeType:function (shapeType) {
        this._shapeType = shapeType;
    },

    _isActive:false,

    /**
     * Return ParticleSystem is active
     * @return {Boolean}
     */
    getIsActive:function () {
        return this._isActive;
    },

    /**
     * Whether or not ParticleSystem is active
     * @param isActive
     */
    setIsActive:function (isActive) {
        this._isActive = isActive;
    },

    _particleCount:0,

    /**
     * Quantity of particles that are being simulated at the moment
     * @return {Number}
     */
    getParticleCount:function () {
        return this._particleCount;
    },

    /**
     * Quantity of particles setter
     * @param {Number} particleCount
     */
    setParticleCount:function (particleCount) {
        this._particleCount = particleCount;
    },

    _duration:0,
    /**
     * How many seconds the emitter wil run. -1 means 'forever'
     * @return {Number}
     */
    getDuration:function () {
        return this._duration;
    },

    /**
     * set run seconds of the emitter
     * @param {Number} duration
     */
    setDuration:function (duration) {
        this._duration = duration;
    },

    _sourcePosition:cc.PointZero(),
    /**
     * Return sourcePosition of the emitter
     * @return {cc.Point}
     */
    getSourcePosition:function () {
        return this._sourcePosition;
    },

    /**
     * sourcePosition of the emitter setter
     * @param sourcePosition
     */
    setSourcePosition:function (sourcePosition) {
        this._sourcePosition = sourcePosition;
    },

    _posVar:cc.PointZero(),
    /**
     * Return Position variance of the emitter
     * @return {cc.Point}
     */
    getPosVar:function () {
        return this._posVar;
    },

    /**
     * Position variance of the emitter setter
     * @param {cc.Point} posVar
     */
    setPosVar:function (posVar) {
        this._posVar = posVar;
    },

    _life:0,
    /**
     * Return life of each particle
     * @return {Number}
     */
    getLife:function () {
        return this._life;
    },

    /**
     * life of each particle setter
     * @param {Number} life
     */
    setLife:function (life) {
        this._life = life;
    },

    _lifeVar:0,
    /**
     * Return life variance of each particle
     * @return {Number}
     */
    getLifeVar:function () {
        return this._lifeVar;
    },

    /**
     * life variance of each particle setter
     * @param {Number} lifeVar
     */
    setLifeVar:function (lifeVar) {
        this._lifeVar = lifeVar;
    },

    _angle:0,
    /**
     * Return angle of each particle
     * @return {Number}
     */
    getAngle:function () {
        return this._angle;
    },

    /**
     * angle of each particle setter
     * @param {Number} angle
     */
    setAngle:function (angle) {
        this._angle = angle;
    },

    _angleVar:0,
    /**
     * Return angle variance of each particle
     * @return {Number}
     */
    getAngleVar:function () {
        return this._angleVar;
    },

    /**
     * angle variance of each particle setter
     * @param angleVar
     */
    setAngleVar:function (angleVar) {
        this._angleVar = angleVar;
    },

    // mode A
    /**
     * Return Gravity of emitter
     * @return {cc.Point}
     */
    getGravity:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.gravity;
    },

    /**
     * Gravity of emitter setter
     * @param {cc.Point} gravity
     */
    setGravity:function (gravity) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.gravity = gravity;
    },

    /**
     * Return Speed of each particle
     * @return {Number}
     */
    getSpeed:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.speed;
    },

    /**
     * Speed of each particle setter
     * @param {Number} speed
     */
    setSpeed:function (speed) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.speed = speed;
    },

    /**
     * return speed variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getSpeedVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.speedVar;
    },

    /**
     * speed variance of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} speedVar
     */
    setSpeedVar:function (speedVar) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.speedVar = speedVar;
    },

    /**
     * Return tangential acceleration of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getTangentialAccel:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.tangentialAccel;
    },

    /**
     * Tangential acceleration of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} tangentialAccel
     */
    setTangentialAccel:function (tangentialAccel) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.tangentialAccel = tangentialAccel;
    },

    /**
     * Return tangential acceleration variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getTangentialAccelVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar;
    },

    /**
     * tangential acceleration variance of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} tangentialAccelVar
     */
    setTangentialAccelVar:function (tangentialAccelVar) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = tangentialAccelVar;
    },

    /**
     * Return radial acceleration of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getRadialAccel:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.radialAccel;
    },

    /**
     * radial acceleration of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} radialAccel
     */
    setRadialAccel:function (radialAccel) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.radialAccel = radialAccel;
    },

    /**
     * Return radial acceleration variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getRadialAccelVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.radialAccelVar;
    },

    /**
     * radial acceleration variance of each particle setter. Only available in 'Gravity' mode.
     * @param radialAccelVar
     */
    setRadialAccelVar:function (radialAccelVar) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.radialAccelVar = radialAccelVar;
    },

    // mode B
    /**
     * Return starting radius of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getStartRadius:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.startRadius;
    },

    /**
     * starting radius of the particles setter. Only available in 'Radius' mode.
     * @param {Number} startRadius
     */
    setStartRadius:function (startRadius) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.startRadius = startRadius;
    },

    /**
     * Return starting radius variance of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getStartRadiusVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.startRadiusVar;
    },

    /**
     * starting radius variance of the particles setter. Only available in 'Radius' mode.
     * @param {Number} startRadiusVar
     */
    setStartRadiusVar:function (startRadiusVar) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.startRadiusVar = startRadiusVar;
    },

    /**
     * Return ending radius of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getEndRadius:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.endRadius;
    },

    /**
     * ending radius of the particles setter. Only available in 'Radius' mode.
     * @param {Number} endRadius
     */
    setEndRadius:function (endRadius) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.endRadius = endRadius;
    },

    /**
     * Return ending radius variance of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getEndRadiusVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.endRadiusVar;
    },

    /**
     * ending radius variance of the particles setter. Only available in 'Radius' mode.
     * @param endRadiusVar
     */
    setEndRadiusVar:function (endRadiusVar) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.endRadiusVar = endRadiusVar;
    },

    /**
     * get Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
     * @return {Number}
     */
    getRotatePerSecond:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.rotatePerSecond;
    },

    /**
     * set Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
     * @param {Number} degrees
     */
    setRotatePerSecond:function (degrees) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.rotatePerSecond = degrees;
    },

    /**
     * Return Variance in degrees for rotatePerSecond. Only available in 'Radius' mode.
     * @return {Number}
     */
    getRotatePerSecondVar:function () {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.rotatePerSecondVar;
    },

    /**
     * Variance in degrees for rotatePerSecond setter. Only available in 'Radius' mode.
     * @param degrees
     */
    setRotatePerSecondVar:function (degrees) {
        cc.Assert(this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.rotatePerSecondVar = degrees;
    },
    //////////////////////////////////////////////////////////////////////////

    _startSize:0,
    /**
     * get start size in pixels of each particle
     * @return {Number}
     */
    getStartSize:function () {
        return this._startSize;
    },

    /**
     * set start size in pixels of each particle
     * @param {Number} startSize
     */
    setStartSize:function (startSize) {
        this._startSize = startSize;
    },


    _startSizeVar:0,
    /**
     * get size variance in pixels of each particle
     * @return {Number}
     */
    getStartSizeVar:function () {
        return this._startSizeVar;
    },

    /**
     * set size variance in pixels of each particle
     * @param {Number} startSizeVar
     */
    setStartSizeVar:function (startSizeVar) {
        this._startSizeVar = startSizeVar;
    },


    _endSize:0,
    /**
     * get end size in pixels of each particle
     * @return {Number}
     */
    getEndSize:function () {
        return this._endSize;
    },

    /**
     * set end size in pixels of each particle
     * @param endSize
     */
    setEndSize:function (endSize) {
        this._endSize = endSize;
    },

    _endSizeVar:0,
    /**
     * get end size variance in pixels of each particle
     * @return {Number}
     */
    getEndSizeVar:function () {
        return this._endSizeVar;
    },

    /**
     * set end size variance in pixels of each particle
     * @param {Number} endSizeVar
     */
    setEndSizeVar:function (endSizeVar) {
        this._endSizeVar = endSizeVar;
    },


    _startColor:new cc.Color4F(0, 0, 0, 1),
    /**
     * set start color of each particle
     * @return {cc.Color4F}
     */
    getStartColor:function () {
        return this._startColor;
    },

    /**
     * get start color of each particle
     * @param {cc.Color4F} startColor
     */
    setStartColor:function (startColor) {
        this._startColor = startColor;
    },

    _startColorVar:new cc.Color4F(0, 0, 0, 1),
    /**
     * get start color variance of each particle
     * @return {cc.Color4F}
     */
    getStartColorVar:function () {
        return this._startColorVar;
    },

    /**
     * set start color variance of each particle
     * @param {cc.Color4F} startColorVar
     */
    setStartColorVar:function (startColorVar) {
        this._startColorVar = startColorVar;
    },


    _endColor:new cc.Color4F(0, 0, 0, 1),
    /**
     * get end color and end color variation of each particle
     * @return {cc.Color4F}
     */
    getEndColor:function () {
        return this._endColor;
    },

    /**
     * set end color and end color variation of each particle
     * @param {cc.Color4F} endColor
     */
    setEndColor:function (endColor) {
        this._endColor = endColor;
    },

    _endColorVar:new cc.Color4F(0, 0, 0, 1),
    /**
     * get end color variance of each particle
     * @return {cc.Color4F}
     */
    getEndColorVar:function () {
        return this._endColorVar;
    },

    /**
     * set end color variance of each particle
     * @param {cc.Color4F} endColorVar
     */
    setEndColorVar:function (endColorVar) {
        this._endColorVar = endColorVar;
    },

    _startSpin:0,
    /**
     * get initial angle of each particle
     * @return {Number}
     */
    getStartSpin:function () {
        return this._startSpin;
    },

    /**
     * set initial angle of each particle
     * @param {Number} startSpin
     */
    setStartSpin:function (startSpin) {
        this._startSpin = startSpin;
    },

    _startSpinVar:0,
    /**
     * get initial angle variance of each particle
     * @return {Number}
     */
    getStartSpinVar:function () {
        return this._startSpinVar;
    },

    /**
     * set initial angle variance of each particle
     * @param {Number} startSpinVar
     */
    setStartSpinVar:function (startSpinVar) {
        this._startSpinVar = startSpinVar;
    },

    _endSpin:0,
    /**
     * get end angle of each particle
     * @return {Number}
     */
    getEndSpin:function () {
        return this._endSpin;
    },

    /**
     * set end angle of each particle
     * @param {Number} endSpin
     */
    setEndSpin:function (endSpin) {
        this._endSpin = endSpin;
    },

    _endSpinVar:0,
    /**
     * get end angle variance of each particle
     * @return {Number}
     */
    getEndSpinVar:function () {
        return this._endSpinVar;
    },

    /**
     * set end angle variance of each particle
     * @param {Number} endSpinVar
     */
    setEndSpinVar:function (endSpinVar) {
        this._endSpinVar = endSpinVar;
    },

    _emissionRate:0,
    /**
     * get emission rate of the particles
     * @return {Number}
     */
    getEmissionRate:function () {
        return this._emissionRate;
    },

    /**
     * set emission rate of the particles
     * @param {Number} emissionRate
     */
    setEmissionRate:function (emissionRate) {
        this._emissionRate = emissionRate;
    },

    _totalParticles:0,
    /**
     * get maximum particles of the system
     * @return {Number}
     */
    getTotalParticles:function () {
        return this._totalParticles;
    },

    /**
     * set maximum particles of the system
     * @param {Number} totalParticles
     */
    setTotalParticles:function (totalParticles) {
        this._totalParticles = totalParticles;
    },

    _texture:null,
    /**
     * get Texture of Particle System
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._texture;
    },

    /**
     * set Texture of Particle System
     * @param {cc.Texture2D} texture
     */
    setTexture:function (texture) {
        //TODO
        this._texture = texture;

        if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {

        } else {
            // If the new texture has No premultiplied alpha, AND the blendFunc hasn't been changed, then update it
            if (this._texture && !this._texture.getHasPremultipliedAlpha() &&
                ( this._blendFunc.src == cc.BLEND_SRC && this._blendFunc.dst == cc.BLEND_DST )) {
                this._blendFunc.src = GL_SRC_ALPHA;
                this._blendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;
            }
        }
    },

    /** conforms to CocosNodeTexture protocol */
    _blendFunc:new cc.BlendFunc(0, 0),
    /**
     * get BlendFunc of Particle System
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * set BlendFunc of Particle System
     * @param {cc.BlendFunc} blendFunc
     */
    setBlendFunc:function (blendFunc) {
        this._blendFunc = blendFunc;
    },

    _isBlendAdditive:false,
    /**
     * <p>whether or not the particles are using blend additive.<br/>
     *     If enabled, the following blending function will be used.<br/>
     * </p>
     * @return {Boolean}
     * @example
     *    source blend function = GL_SRC_ALPHA;
     *    dest blend function = GL_ONE;
     */
    getIsBlendAdditive:function () {
        return this._isBlendAdditive;
        //return( this._blendFunc.src == GL_SRC_ALPHA && this._blendFunc.dst == GL_ONE);
    },

    /**
     * <p>whether or not the particles are using blend additive.<br/>
     *     If enabled, the following blending function will be used.<br/>
     * </p>
     * @param {Boolean} isBlendAdditive
     */
    setIsBlendAdditive:function (isBlendAdditive) {
        //TODO
        this._isBlendAdditive = isBlendAdditive;
        return;
        if (isBlendAdditive) {
            //this._blendFunc.src = GL_SRC_ALPHA;
            //this._blendFunc.dst = GL_ONE;
        } else {
            if (this._texture && !this._texture.getHasPremultipliedAlpha()) {
                //this._blendFunc.src = GL_SRC_ALPHA;
                //this._blendFunc.dst = GL_ONE_MINUS_SRC_ALPHA;
            } else {
                this._blendFunc.src = cc.BLEND_SRC;
                this._blendFunc.dst = cc.BLEND_DST;
            }
        }
    },

    _positionType:cc.CCPARTICLE_TYPE_FREE,
    /**
     * get particles movement type: Free or Grouped
     * @return {Number}
     */
    getPositionType:function () {
        return this._positionType;
    },

    /**
     * set particles movement type: Free or Grouped
     * @param {Number} positionType
     */
    setPositionType:function (positionType) {
        this._positionType = positionType;
    },

    _isAutoRemoveOnFinish:false,
    /**
     *  <p> return whether or not the node will be auto-removed when it has no particles left.<br/>
     *      By default it is false.<br/>
     *  </p>
     * @return {Boolean}
     */
    getIsAutoRemoveOnFinish:function () {
        return this._isAutoRemoveOnFinish;
    },

    /**
     *  <p> set whether or not the node will be auto-removed when it has no particles left.<br/>
     *      By default it is false.<br/>
     *  </p>
     * @param {Boolean} isAutoRemoveOnFinish
     */
    setIsAutoRemoveOnFinish:function (isAutoRemoveOnFinish) {
        this._isAutoRemoveOnFinish = isAutoRemoveOnFinish;
    },

    _emitterMode:0,
    /**
     * return kind of emitter modes
     * @return {Number}
     */
    getEmitterMode:function () {
        return this._emitterMode;
    },

    /**
     * <p>Switch between different kind of emitter modes:<br/>
     *  - CCPARTICLE_MODE_GRAVITY: uses gravity, speed, radial and tangential acceleration<br/>
     *  - CCPARTICLE_MODE_RADIUS: uses radius movement + rotation <br/>
     *  </p>
     * @param {Number} emitterMode
     */
    setEmitterMode:function (emitterMode) {
        this._emitterMode = emitterMode;
    },

    /**
     * Constructor
     * @override
     */
    ctor:function () {
        this._super();
        this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA();
        this.modeB = new cc.ParticleSystem.ModeB();
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    },

    /**
     * <p> initializes a CCParticleSystem from a plist file. <br/>
     *      This plist files can be creted manually or with Particle Designer:<br/>
     *      http://particledesigner.71squared.com/<br/></p>
     * @param {String} plistFile
     * @return {cc.ParticleSystem}
     */
    initWithFile:function (plistFile) {
        var ret = false;
        //TODO
        this._plistFile = plistFile;
        var dict = cc.FileUtils.dictionaryWithContentsOfFileThreadSafe(this._plistFile);

        cc.Assert(dict != null, "Particles: file not found");
        return this.initWithDictionary(dict);
    },

    /**
     * return bounding box of particle system in world space
     * @return {cc.Rect}
     */
    boundingBoxToWorld:function () {
        return new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height);
    },

    /**
     * initializes a CCQuadParticleSystem from a CCDictionary.
     * @param {object} dictionary
     * @return {Boolean}
     */
    initWithDictionary:function (dictionary) {
        var ret = false;
        var buffer = null;
        var deflated = null;
        var image = null;

        var maxParticles = parseInt(this._valueForKey("maxParticles", dictionary));
        // self, not super
        if (this.initWithTotalParticles(maxParticles)) {
            // angle
            this._angle = parseFloat(this._valueForKey("angle", dictionary));
            this._angleVar = parseFloat(this._valueForKey("angleVariance", dictionary));

            // duration
            this._duration = parseFloat(this._valueForKey("duration", dictionary));

            // blend function
            this._blendFunc.src = parseInt(this._valueForKey("blendFuncSource", dictionary));
            this._blendFunc.dst = parseInt(this._valueForKey("blendFuncDestination", dictionary));

            // color
            this._startColor.r = parseFloat(this._valueForKey("startColorRed", dictionary));
            this._startColor.g = parseFloat(this._valueForKey("startColorGreen", dictionary));
            this._startColor.b = parseFloat(this._valueForKey("startColorBlue", dictionary));
            this._startColor.a = parseFloat(this._valueForKey("startColorAlpha", dictionary));

            this._startColorVar.r = parseFloat(this._valueForKey("startColorVarianceRed", dictionary));
            this._startColorVar.g = parseFloat(this._valueForKey("startColorVarianceGreen", dictionary));
            this._startColorVar.b = parseFloat(this._valueForKey("startColorVarianceBlue", dictionary));
            this._startColorVar.a = parseFloat(this._valueForKey("startColorVarianceAlpha", dictionary));

            this._endColor.r = parseFloat(this._valueForKey("finishColorRed", dictionary));
            this._endColor.g = parseFloat(this._valueForKey("finishColorGreen", dictionary));
            this._endColor.b = parseFloat(this._valueForKey("finishColorBlue", dictionary));
            this._endColor.a = parseFloat(this._valueForKey("finishColorAlpha", dictionary));

            this._endColorVar.r = parseFloat(this._valueForKey("finishColorVarianceRed", dictionary));
            this._endColorVar.g = parseFloat(this._valueForKey("finishColorVarianceGreen", dictionary));
            this._endColorVar.b = parseFloat(this._valueForKey("finishColorVarianceBlue", dictionary));
            this._endColorVar.a = parseFloat(this._valueForKey("finishColorVarianceAlpha", dictionary));

            // particle size
            this._startSize = parseFloat(this._valueForKey("startParticleSize", dictionary));
            this._startSizeVar = parseFloat(this._valueForKey("startParticleSizeVariance", dictionary));
            this._endSize = parseFloat(this._valueForKey("finishParticleSize", dictionary));
            this._endSizeVar = parseFloat(this._valueForKey("finishParticleSizeVariance", dictionary));

            // position
            var x = parseFloat(this._valueForKey("sourcePositionx", dictionary));
            var y = parseFloat(this._valueForKey("sourcePositiony", dictionary));
            this.setPosition(cc.ccp(x, y));
            this._posVar.x = parseFloat(this._valueForKey("sourcePositionVariancex", dictionary));
            this._posVar.y = parseFloat(this._valueForKey("sourcePositionVariancey", dictionary));

            // Spinning
            this._startSpin = parseFloat(this._valueForKey("rotationStart", dictionary));
            this._startSpinVar = parseFloat(this._valueForKey("rotationStartVariance", dictionary));
            this._endSpin = parseFloat(this._valueForKey("rotationEnd", dictionary));
            this._endSpinVar = parseFloat(this._valueForKey("rotationEndVariance", dictionary));

            this._emitterMode = parseInt(this._valueForKey("emitterType", dictionary));

            // Mode A: Gravity + tangential accel + radial accel
            if (this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY) {
                // gravity
                this.modeA.gravity.x = parseFloat(this._valueForKey("gravityx", dictionary));
                this.modeA.gravity.y = parseFloat(this._valueForKey("gravityy", dictionary));

                // speed
                this.modeA.speed = parseFloat(this._valueForKey("speed", dictionary));
                this.modeA.speedVar = parseFloat(this._valueForKey("speedVariance", dictionary));

                // radial acceleration
                var pszTmp = this._valueForKey("radialAcceleration", dictionary);
                this.modeA.radialAccel = (pszTmp) ? parseFloat(pszTmp) : 0;

                pszTmp = this._valueForKey("radialAccelVariance", dictionary);
                this.modeA.radialAccelVar = (pszTmp) ? parseFloat(pszTmp) : 0;

                // tangential acceleration
                pszTmp = this._valueForKey("tangentialAcceleration", dictionary);
                this.modeA.tangentialAccel = (pszTmp) ? parseFloat(pszTmp) : 0;

                pszTmp = this._valueForKey("tangentialAccelVariance", dictionary);
                this.modeA.tangentialAccelVar = (pszTmp) ? parseFloat(pszTmp) : 0;
            } else if (this._emitterMode == cc.CCPARTICLE_MODE_RADIUS) {
                // or Mode B: radius movement
                this.modeB.startRadius = parseFloat(this._valueForKey("maxRadius", dictionary));
                this.modeB.startRadiusVar = parseFloat(this._valueForKey("maxRadiusVariance", dictionary));
                this.modeB.endRadius = parseFloat(this._valueForKey("minRadius", dictionary));
                this.modeB.endRadiusVar = 0;
                this.modeB.rotatePerSecond = parseFloat(this._valueForKey("rotatePerSecond", dictionary));
                this.modeB.rotatePerSecondVar = parseFloat(this._valueForKey("rotatePerSecondVariance", dictionary));
            } else {
                cc.Assert(false, "Invalid emitterType in config file");
                cc.BREAK_IF(true);
            }

            // life span
            this._life = parseFloat(this._valueForKey("particleLifespan", dictionary));
            this._lifeVar = parseFloat(this._valueForKey("particleLifespanVariance", dictionary));

            // emission Rate
            this._emissionRate = this._totalParticles / this._life;

            // texture
            // Try to get the texture from the cache
            var textureName = this._valueForKey("textureFileName", dictionary);
            var fullpath = cc.FileUtils.fullPathFromRelativeFile(textureName, this._plistFile);

            var tex = null;

            if (textureName.length > 0) {
                // set not pop-up message box when load image failed
                var notify = cc.FileUtils.getIsPopupNotify();
                cc.FileUtils.setIsPopupNotify(false);
                tex = cc.TextureCache.sharedTextureCache().addImage(fullpath);

                // reset the value of UIImage notify
                cc.FileUtils.setIsPopupNotify(notify);
            }

            if (tex) {
                this._texture = tex;
            } else {
                var textureData = this._valueForKey("textureImageData", dictionary);
                cc.Assert(textureData, "cc.ParticleSystem.initWithDictory:textureImageData is null");

                if (textureData.length != 0) {
                    //TODO base64Decode
                    // if it fails, try to get it from the base64-gzipped data
                    var decodeLen = cc.base64Decode(textureData, textureData.length, buffer);
                    cc.Assert(buffer != null, "CCParticleSystem: error decoding textureImageData");
                    if (!buffer)
                        return false

                    var deflatedLen = cc.ZipUtils.ccInflateMemory(buffer, decodeLen, deflated);
                    cc.Assert(deflated != null, "CCParticleSystem: error ungzipping textureImageData");
                    if (!deflated)
                        return false

                    image = new cc.Image();
                    var isOK = image.initWithImageData(deflated, deflatedLen);
                    cc.Assert(isOK, "CCParticleSystem: error init image with Data");
                    if (!isOK)
                        return false

                    this._texture = cc.TextureCache.sharedTextureCache().addUIImage(image, fullpath);
                }
            }
            cc.Assert(this._texture != null, "CCParticleSystem: error loading the texture");

            if (!this._texture)
                return false
            ret = true;
        }

        return ret;
    },

    /**
     * Initializes a system with a fixed number of particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        this._totalParticles = numberOfParticles;

        this._particles = [];

        if (!this._particles) {
            cc.Log("Particle system: not enough memory");
            return false;
        }

        // default, active
        this._isActive = true;

        // default blend function
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        // default movement type;
        this._positionType = cc.CCPARTICLE_TYPE_FREE;

        // by default be in mode A:
        this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

        // default: modulate
        // XXX: not used
        //	colorModulate = YES;
        this._isAutoRemoveOnFinish = false;

        // profiling
        /// @todo _profilingTimer = [[CCProfiler timerWithName:@"particle system" andInstance:self] retain];


        // Optimization: compile udpateParticle method
        //updateParticleSel = @selector(updateQuadWithParticle:newPosition:);
        //updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];

        // udpate after action in run!
        this.scheduleUpdateWithPriority(1);

        return true;
    },

    /**
     * Add a particle to the emitter
     * @return {Boolean}
     */
    addParticle:function () {
        if (this.isFull()) {
            return false;
        }

        var particle = new cc.Particle();
        this.initParticle(particle);
        this._particles.push(particle);
        ++this._particleCount;

        return true;
    },

    /**
     * Initializes a particle
     * @param {cc.Particle} particle
     */
    initParticle:function (particle) {
        // timeToLive
        // no negative life. prevent division by 0
        particle.timeToLive = this._life + this._lifeVar * cc.RANDOM_MINUS1_1();
        particle.timeToLive = Math.max(0, particle.timeToLive);

        // position
        particle.pos.x = this._sourcePosition.x + this._posVar.x * cc.RANDOM_MINUS1_1();
        particle.pos.x *= cc.CONTENT_SCALE_FACTOR();
        particle.pos.y = this._sourcePosition.y + this._posVar.y * cc.RANDOM_MINUS1_1();
        particle.pos.y *= cc.CONTENT_SCALE_FACTOR();

        // Color
        var start = new cc.Color4F(
            cc.clampf(this._startColor.r + this._startColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.g + this._startColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.b + this._startColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.a + this._startColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1)
        );

        var end = new cc.Color4F(
            cc.clampf(this._endColor.r + this._endColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.g + this._endColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.b + this._endColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.a + this._endColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1)
        );

        particle.color = start;
        particle.deltaColor.r = (end.r - start.r) / particle.timeToLive;
        particle.deltaColor.g = (end.g - start.g) / particle.timeToLive;
        particle.deltaColor.b = (end.b - start.b) / particle.timeToLive;
        particle.deltaColor.a = (end.a - start.a) / particle.timeToLive;

        // size
        var startS = this._startSize + this._startSizeVar * cc.RANDOM_MINUS1_1();
        startS = Math.max(0, startS); // No negative value
        startS *= cc.CONTENT_SCALE_FACTOR();

        particle.size = startS;

        if (this._endSize == cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE) {
            particle.deltaSize = 0;
        } else {
            var endS = this._endSize + this._endSizeVar * cc.RANDOM_MINUS1_1();
            endS = Math.max(0, endS); // No negative values
            endS *= cc.CONTENT_SCALE_FACTOR();
            particle.deltaSize = (endS - startS) / particle.timeToLive;
        }

        // rotation
        var startA = this._startSpin + this._startSpinVar * cc.RANDOM_MINUS1_1();
        var endA = this._endSpin + this._endSpinVar * cc.RANDOM_MINUS1_1();
        particle.rotation = startA;
        particle.deltaRotation = (endA - startA) / particle.timeToLive;

        // position
        if (this._positionType == cc.CCPARTICLE_TYPE_FREE) {
            var p = this.convertToWorldSpace(cc.PointZero());
            particle.startPos = cc.ccpMult(p, cc.CONTENT_SCALE_FACTOR());

        } else if (this._positionType == cc.CCPARTICLE_TYPE_RELATIVE) {
            particle.startPos = cc.ccpMult(this._position, cc.CONTENT_SCALE_FACTOR());
        }

        // direction
        var a = cc.DEGREES_TO_RADIANS(this._angle + this._angleVar * cc.RANDOM_MINUS1_1());

        // Mode Gravity: A
        if (this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY) {
            var v = cc.ccp(Math.cos(a), Math.sin(a));
            var s = this.modeA.speed + this.modeA.speedVar * cc.RANDOM_MINUS1_1();
            s *= cc.CONTENT_SCALE_FACTOR();

            // direction
            particle.modeA.dir = cc.ccpMult(v, s);

            // radial accel
            particle.modeA.radialAccel = this.modeA.radialAccel + this.modeA.radialAccelVar * cc.RANDOM_MINUS1_1();
            particle.modeA.radialAccel *= cc.CONTENT_SCALE_FACTOR();

            // tangential accel
            particle.modeA.tangentialAccel = this.modeA.tangentialAccel + this.modeA.tangentialAccelVar * cc.RANDOM_MINUS1_1();
            particle.modeA.tangentialAccel *= cc.CONTENT_SCALE_FACTOR();
        } else {
            // Mode Radius: B

            // Set the default diameter of the particle from the source position
            var startRadius = this.modeB.startRadius + this.modeB.startRadiusVar * cc.RANDOM_MINUS1_1();
            var endRadius = this.modeB.endRadius + this.modeB.endRadiusVar * cc.RANDOM_MINUS1_1();
            startRadius *= cc.CONTENT_SCALE_FACTOR();
            endRadius *= cc.CONTENT_SCALE_FACTOR();

            particle.modeB.radius = startRadius;

            if (this.modeB.endRadius == cc.CCPARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS)
                particle.modeB.deltaRadius = 0;
            else
                particle.modeB.deltaRadius = (endRadius - startRadius) / particle.timeToLive;

            particle.modeB.angle = a;
            particle.modeB.degreesPerSecond = cc.DEGREES_TO_RADIANS(this.modeB.rotatePerSecond + this.modeB.rotatePerSecondVar * cc.RANDOM_MINUS1_1());
        }
    },

    /**
     * stop emitting particles. Running particles will continue to run until they die
     */
    stopSystem:function () {
        this._isActive = false;
        this._elapsed = this._duration;
        this._emitCounter = 0;
    },

    /**
     * Kill all living particles.
     */
    resetSystem:function () {
        this._isActive = true;
        this._elapsed = 0;
        for (this._particleIdx = 0; this._particleIdx < this._particleCount; ++this._particleIdx) {
            var p = this._particles[this._particleIdx];
            p.timeToLive = 0;
        }
    },

    /**
     * whether or not the system is full
     * @return {Boolean}
     */
    isFull:function () {
        return (this._particleCount >= this._totalParticles);
    },

    /**
     * should be overriden by subclasses
     * @param {cc.Particle} particle
     * @param {cc.Point} newPosition
     */
    updateQuadWithParticle:function (particle, newPosition) {
        // should be overriden
    },

    /**
     * should be overriden by subclasses
     */
    postStep:function () {
        // should be overriden
    },

    /**
     * update emitter's status
     * @override
     * @param {Number} dt delta time
     */
    update:function (dt) {
        if (this._isActive && this._emissionRate) {
            var rate = 1.0 / this._emissionRate;
            this._emitCounter += dt;
            while ((this._particleCount < this._totalParticles) && (this._emitCounter > rate)) {
                this.addParticle();
                this._emitCounter -= rate;
            }

            this._elapsed += dt;
            if (this._duration != -1 && this._duration < this._elapsed) {
                this.stopSystem();
            }
        }
        this._particleIdx = 0;

        /// @todo CCProfilingBeginTimingBlock(_profilingTimer);

        var currentPosition = cc.PointZero();
        if (this._positionType == cc.CCPARTICLE_TYPE_FREE) {
            currentPosition = this.convertToWorldSpace(cc.PointZero());
            currentPosition.x *= cc.CONTENT_SCALE_FACTOR();
            currentPosition.y *= cc.CONTENT_SCALE_FACTOR();
        } else if (this._positionType == cc.CCPARTICLE_TYPE_RELATIVE) {
            currentPosition = cc.ccp(this._position.x, this._position.y);
            currentPosition.x *= cc.CONTENT_SCALE_FACTOR();
            currentPosition.y *= cc.CONTENT_SCALE_FACTOR();
        }

        while (this._particleIdx < this._particleCount) {
            var selParticle = this._particles[this._particleIdx];

            // life
            selParticle.timeToLive -= dt;

            if (selParticle.timeToLive > 0) {
                // Mode A: gravity, direction, tangential accel & radial accel
                if (this._emitterMode == cc.CCPARTICLE_MODE_GRAVITY) {
                    var tmp, radial, tangential;

                    radial = cc.PointZero();
                    // radial acceleration
                    if (selParticle.pos.x || selParticle.pos.y)
                        radial = cc.ccpNormalize(selParticle.pos);
                    tangential = radial;
                    radial = cc.ccpMult(radial, selParticle.modeA.radialAccel);

                    // tangential acceleration
                    var newy = tangential.x;
                    tangential.x = -tangential.y;
                    tangential.y = newy;
                    tangential = cc.ccpMult(tangential, selParticle.modeA.tangentialAccel);

                    // (gravity + radial + tangential) * dt
                    tmp = cc.ccpAdd(cc.ccpAdd(radial, tangential), this.modeA.gravity);
                    tmp = cc.ccpMult(tmp, dt);
                    selParticle.modeA.dir = cc.ccpAdd(selParticle.modeA.dir, tmp);
                    tmp = cc.ccpMult(selParticle.modeA.dir, dt);
                    selParticle.pos = cc.ccpAdd(selParticle.pos, tmp);
                } else {
                    // Mode B: radius movement

                    // Update the angle and radius of the particle.
                    selParticle.modeB.angle += selParticle.modeB.degreesPerSecond * dt;
                    selParticle.modeB.radius += selParticle.modeB.deltaRadius * dt;

                    selParticle.pos.x = -Math.cos(selParticle.modeB.angle) * selParticle.modeB.radius;
                    selParticle.pos.y = -Math.sin(selParticle.modeB.angle) * selParticle.modeB.radius;
                }

                // color
                selParticle.color.r += (selParticle.deltaColor.r * dt);
                selParticle.color.g += (selParticle.deltaColor.g * dt);
                selParticle.color.b += (selParticle.deltaColor.b * dt);
                selParticle.color.a += (selParticle.deltaColor.a * dt);
                selParticle.isChangeColor = true;

                // size
                selParticle.size += (selParticle.deltaSize * dt);
                selParticle.size = Math.max(0, selParticle.size);

                // angle
                selParticle.rotation += (selParticle.deltaRotation * dt);

                //
                // update values in quad
                //
                var newPos;
                if (this._positionType == cc.CCPARTICLE_TYPE_FREE || this._positionType == cc.CCPARTICLE_TYPE_RELATIVE) {
                    var diff = cc.ccpSub(currentPosition, selParticle.startPos);
                    newPos = cc.ccpSub(selParticle.pos, diff);
                } else {
                    newPos = selParticle.pos;
                }

                if (cc.renderContextType == cc.WEBGL) {
                    this.updateQuadWithParticle(selParticle, newPos);
                } else {
                    selParticle.drawPos = newPos;
                }
                //updateParticleImp(self, updateParticleSel, p, newPos);

                // update particle counter
                ++this._particleIdx;
            } else {
                // life < 0
                cc.ArrayRemoveObject(this._particles, selParticle);

                --this._particleCount;

                if (this._particleCount == 0 && this._isAutoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, true);
                    return;
                }
            }
        }

        /// @todo CCProfilingEndTimingBlock(_profilingTimer);

        if (cc.USES_VBO)
            this.postStep();
    },

    /**
     * return the string found by key in dict.
     * @param {string} key
     * @param {object} dict
     * @return {String} "" if not found; return the string if found.
     * @private
     */
    _valueForKey:function (key, dict) {
        if (dict) {
            var pString = dict[key];
            return pString ? pString : "";
        }
        return "";
    }
});

/**
 * <p> return the string found by key in dict. <br/>
 *    This plist files can be creted manually or with Particle Designer:<br/>
 *    http://particledesigner.71squared.com/<br/>
 * </p>
 * @param {String} plistFile
 * @return {cc.ParticleSystem}
 */
cc.ParticleSystem.create = function (plistFile) {
    var ret = new cc.ParticleSystem();
    if (ret && ret.initWithFile(plistFile)) {
        return ret;
    }
    return null;
};

// Different modes
/**
 * Mode A:Gravity + Tangential Accel + Radial Accel
 * @Class
 * @Construct
 * @param {cc.Point} gravity Gravity value.
 * @param {Number} speed speed of each particle.
 * @param {Number} speedVar speed variance of each particle.
 * @param {Number} tangentialAccel tangential acceleration of each particle.
 * @param {Number} tangentialAccelVar tangential acceleration variance of each particle.
 * @param {Number} radialAccel radial acceleration of each particle.
 * @param {Number} radialAccelVar radial acceleration variance of each particle.
 */
cc.ParticleSystem.ModeA = function (gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar) {
    /** Gravity value. Only available in 'Gravity' mode. */
    this.gravity = gravity ? gravity : cc.PointZero();
    /** speed of each particle. Only available in 'Gravity' mode.  */
    this.speed = speed || 0;
    /** speed variance of each particle. Only available in 'Gravity' mode. */
    this.speedVar = speedVar || 0;
    /** tangential acceleration of each particle. Only available in 'Gravity' mode. */
    this.tangentialAccel = tangentialAccel || 0;
    /** tangential acceleration variance of each particle. Only available in 'Gravity' mode. */
    this.tangentialAccelVar = tangentialAccelVar || 0;
    /** radial acceleration of each particle. Only available in 'Gravity' mode. */
    this.radialAccel = radialAccel || 0;
    /** radial acceleration variance of each particle. Only available in 'Gravity' mode. */
    this.radialAccelVar = radialAccelVar || 0;
};

/**
 * Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
 * @Class
 * @Construct
 * @param {Number} startRadius The starting radius of the particles.
 * @param {Number} startRadiusVar The starting radius variance of the particles.
 * @param {Number} endRadius The ending radius of the particles.
 * @param {Number} endRadiusVar The ending radius variance of the particles.
 * @param {Number} rotatePerSecond Number of degress to rotate a particle around the source pos per second.
 * @param {Number} rotatePerSecondVar Variance in degrees for rotatePerSecond.
 */
cc.ParticleSystem.ModeB = function (startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
    /** The starting radius of the particles. Only available in 'Radius' mode. */
    this.startRadius = startRadius || 0;
    /** The starting radius variance of the particles. Only available in 'Radius' mode. */
    this.startRadiusVar = startRadiusVar || 0;
    /** The ending radius of the particles. Only available in 'Radius' mode. */
    this.endRadius = endRadius || 0;
    /** The ending radius variance of the particles. Only available in 'Radius' mode. */
    this.endRadiusVar = endRadiusVar || 0;
    /** Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode. */
    this.rotatePerSecond = rotatePerSecond || 0;
    /** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
    this.rotatePerSecondVar = rotatePerSecondVar || 0;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *     CCParticleSystemQuad is a subclass of CCParticleSystem<br/>
 *     <br/>
 *     It includes all the features of ParticleSystem.<br/>
 *     <br/>
 *     Special features and Limitations:<br/>
 *      - Particle size can be any float number. <br/>
 *      - The system can be scaled <br/>
 *      - The particles can be rotated     <br/>
 *      - On 1st and 2nd gen iPhones: It is only a bit slower that CCParticleSystemPoint <br/>
 *      - On 3rd gen iPhone and iPads: It is MUCH faster than CCParticleSystemPoint  <br/>
 *      - It consumes more RAM and more GPU memory than CCParticleSystemPoint  <br/>
 *      - It supports subrects   <br/>
 * </p>
 * @class
 * @extends cc.ParticleSystem
 * @example
 * //create a particle system
 *   this._emitter = new cc.ParticleSystemQuad();
 *   this._emitter.initWithTotalParticles(150);
 */
cc.ParticleSystemQuad = cc.ParticleSystem.extend(/** @lends cc.ParticleSystemQuad# */{
    // quads to be rendered
    _quads:null,
    // indices
    _indices:null,
    // VBO id
    _quadsID:0,
    /**
     * Constructor
     * @override
     */
    ctor:function () {
        this._super();
    },

    /**
     * initialices the indices for the vertices
     */
    initIndices:function () {
        for (var i = 0; i < this._totalParticles; ++i) {
            var i6 = i * 6;
            var i4 = i * 4;
            this._indices[i6 + 0] = i4 + 0;
            this._indices[i6 + 1] = i4 + 1;
            this._indices[i6 + 2] = i4 + 2;

            this._indices[i6 + 5] = i4 + 1;
            this._indices[i6 + 4] = i4 + 2;
            this._indices[i6 + 3] = i4 + 3;
        }
    },

    /**
     * <p> initilizes the texture with a rectangle measured Points<br/>
     * pointRect should be in Texture coordinates, not pixel coordinates
     * </p>
     * @param {cc.Rect} pointRect
     */
    initTexCoordsWithRect:function (pointRect) {
        // convert to pixels coords
        var rect = cc.RectMake(
            pointRect.origin.x * cc.CONTENT_SCALE_FACTOR(),
            pointRect.origin.y * cc.CONTENT_SCALE_FACTOR(),
            pointRect.size.width * cc.CONTENT_SCALE_FACTOR(),
            pointRect.size.height * cc.CONTENT_SCALE_FACTOR());

        var wide = pointRect.size.width;
        var high = pointRect.size.height;

        if (this._texture) {
            if ((this._texture instanceof HTMLImageElement) || (this._texture instanceof HTMLCanvasElement)) {
                wide = this._texture.width;
                high = this._texture.height;
            } else {
                wide = this._texture.getPixelsWide();
                high = this._texture.getPixelsHigh();
            }
        }

        var left, bottom, right, top;
        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
            left = (rect.origin.x * 2 + 1) / (wide * 2);
            bottom = (rect.origin.y * 2 + 1) / (high * 2);
            right = left + (rect.size.width * 2 - 2) / (wide * 2);
            top = bottom + (rect.size.height * 2 - 2) / (high * 2);
        } else {
            left = rect.origin.x / wide;
            bottom = rect.origin.y / high;
            right = left + rect.size.width / wide;
            top = bottom + rect.size.height / high;
        }

        // Important. Texture in cocos2d are inverted, so the Y component should be inverted
        var temp = top;
        top = bottom;
        bottom = temp;

        this._quads = [];
        for (var i = 0; i < this._totalParticles; i++) {
            this._quads[i] = cc.V3F_C4B_T2F_QuadZero();
        }

        for (var i = 0; i < this._totalParticles; i++) {
            // bottom-left vertex:
            this._quads[i].bl.texCoords.u = left;
            this._quads[i].bl.texCoords.v = bottom;
            // bottom-right vertex:
            this._quads[i].br.texCoords.u = right;
            this._quads[i].br.texCoords.v = bottom;
            // top-left vertex:
            this._quads[i].tl.texCoords.u = left;
            this._quads[i].tl.texCoords.v = top;
            // top-right vertex:
            this._quads[i].tr.texCoords.u = right;
            this._quads[i].tr.texCoords.v = top;
        }
    },

    /**
     * <p> Sets a new CCSpriteFrame as particle.</br>
     * WARNING: this method is experimental. Use setTexture:withRect instead.
     * </p>
     * @param {cc.SpriteFrame} spriteFrame
     */
    setDisplayFrame:function (spriteFrame) {
        cc.Assert(cc.Point.CCPointEqualToPoint(spriteFrame.getOffsetInPixels(), cc.PointZero()), "QuadParticle only supports SpriteFrames with no offsets");

        // update texture before updating texture rect
        if (!this._texture || spriteFrame.getTexture().getName() != this._texture.getName()) {
            this.setTexture(spriteFrame.getTexture());
        }
    },

    /**
     *  Sets a new texture with a rect. The rect is in Points.
     * @param {cc.Texture2D} texture
     * @param {cc.Rect} rect
     */
    setTextureWithRect:function (texture, rect) {
        // Only update the texture if is different from the current one
        if (!this._texture || texture.getName() != this._texture.getName()) {
            this.setTexture(texture, true);
        }

        this.initTexCoordsWithRect(rect);
    },

    // super methods
    // overriding the init method
    /**
     * Initializes a system with a fixed number of particles
     * @override
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        // base initialization
        if (this._super(numberOfParticles)) {
            // allocating data space
            this._quads = [];
            for (var i = 0; i < this._totalParticles; i++) {
                this._quads[i] = cc.V3F_C4B_T2F_QuadZero();
            }
            this._indices = [];
            for (i = 0; i < this._totalParticles * 6; i++) {
                this._indices[i] = 0;
            }

            if (!this._quads || !this._indices) {
                cc.Log("cocos2d: Particle system: not enough memory");
                if (this._quads)
                    this._quads = null;
                if (this._indices)
                    this._indices = null;

                return null;
            }

            // initialize only once the texCoords and the indices
            if (this._texture) {
                this.initTexCoordsWithRect(cc.RectMake(0, 0, this._texture.getPixelsWide(), this._texture.getPixelsHigh()));
            } else {
                this.initTexCoordsWithRect(cc.RectMake(0, 0, 1, 1));
            }

            this.initIndices();

            if (cc.USES_VBO) {
                //TODO
                //glEnable(GL_VERTEX_ARRAY);

                // create the VBO buffer
                //glGenBuffers(1, quadsID);


                // initial binding
                //glBindBuffer(GL_ARRAY_BUFFER, quadsID);
                //glBufferData(GL_ARRAY_BUFFER, sizeof(quads[0])*totalParticles, quads, GL_DYNAMIC_DRAW);
                //glBindBuffer(GL_ARRAY_BUFFER, 0);
            }

            return true;
        }
        return false;
    },

    /**
     * set Texture of Particle System
     * @override
     * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
     * @param {Boolean} isCallSuper is direct call super method
     */
    setTexture:function (texture, isCallSuper) {
        if (isCallSuper) {
            if (isCallSuper == true) {
                this._super(texture);
                return;
            }
        }
        var size = null;
        if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {
            size = cc.SizeMake(texture.width, texture.height);
        } else {
            size = texture.getContentSize();
        }

        this.setTextureWithRect(texture, cc.RectMake(0, 0, size.width, size.height));
    },

    /**
     * update particle's quad
     * @override
     * @param {cc.Particle} particle
     * @param {cc.Point} newPosition
     */
    updateQuadWithParticle:function (particle, newPosition) {
        // colors
        var quad = this._quads[this._particleIdx];

        var color = new cc.Color4B((particle.color.r * 255), (particle.color.g * 255), (particle.color.b * 255),
            (particle.color.a * 255));
        quad.bl.colors = color;
        quad.br.colors = color;
        quad.tl.colors = color;
        quad.tr.colors = color;

        // vertices
        var size_2 = particle.size / 2;
        if (particle.rotation) {
            var x1 = -size_2;
            var y1 = -size_2;

            var x2 = size_2;
            var y2 = size_2;
            var x = newPosition.x;
            var y = newPosition.y;

            var r = -cc.DEGREES_TO_RADIANS(particle.rotation);
            var cr = Math.cos(r);
            var sr = Math.sin(r);
            var ax = x1 * cr - y1 * sr + x;
            var ay = x1 * sr + y1 * cr + y;
            var bx = x2 * cr - y1 * sr + x;
            var by = x2 * sr + y1 * cr + y;
            var cx = x2 * cr - y2 * sr + x;
            var cy = x2 * sr + y2 * cr + y;
            var dx = x1 * cr - y2 * sr + x;
            var dy = x1 * sr + y2 * cr + y;

            // bottom-left
            quad.bl.vertices.x = ax;
            quad.bl.vertices.y = ay;

            // bottom-right vertex:
            quad.br.vertices.x = bx;
            quad.br.vertices.y = by;

            // top-left vertex:
            quad.tl.vertices.x = dx;
            quad.tl.vertices.y = dy;

            // top-right vertex:
            quad.tr.vertices.x = cx;
            quad.tr.vertices.y = cy;
        } else {
            // bottom-left vertex:
            quad.bl.vertices.x = newPosition.x - size_2;
            quad.bl.vertices.y = newPosition.y - size_2;

            // bottom-right vertex:
            quad.br.vertices.x = newPosition.x + size_2;
            quad.br.vertices.y = newPosition.y - size_2;

            // top-left vertex:
            quad.tl.vertices.x = newPosition.x - size_2;
            quad.tl.vertices.y = newPosition.y + size_2;

            // top-right vertex:
            quad.tr.vertices.x = newPosition.x + size_2;
            quad.tr.vertices.y = newPosition.y + size_2;
        }
    },

    /**
     * override cc.ParticleSystem
     * @override
     */
    postStep:function () {
        if (cc.renderContextType == cc.CANVAS) {

        } else {
            if (cc.USES_VBO) {
                //TODO
                glBindBuffer(GL_ARRAY_BUFFER, quadsID);
                glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(quads[0]) * particleCount, quads);
                glBindBuffer(GL_ARRAY_BUFFER, 0);
            }
        }
    },

    /**
     * draw particle
     * @param {CanvasContext} ctx CanvasContext
     * @override
     */
    draw:function (ctx) {
        this._super();
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            context.save();
            if (this._isBlendAdditive) {
                context.globalCompositeOperation = 'lighter';
            } else {
                context.globalCompositeOperation = 'source-over';
            }

            for (var i = 0; i < this._particleCount; i++) {
                var particle = this._particles[i];
                var lpx = (0 | (particle.size * 0.5));

                //TODO these are temporary code, need modifier
                if (this._drawMode == cc.PARTICLE_TEXTURE_MODE) {
                    var drawTexture = this.getTexture();
                    if (particle.isChangeColor) {
                        var cacheTextureForColor = cc.TextureCache.sharedTextureCache().getTextureColors(this.getTexture());
                        if (cacheTextureForColor) {
                            drawTexture = cc.generateTintImage(this.getTexture(), cacheTextureForColor, particle.color);
                        }
                    }

                    context.save();
                    context.globalAlpha = particle.color.a;
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    context.drawImage(drawTexture,
                        lpx, -(lpx + particle.size),
                        particle.size, particle.size);
                    context.restore();
                } else {
                    context.save();
                    context.globalAlpha = particle.color.a;
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    if (this._shapeType == cc.PARTICLE_STAR_SHAPE) {
                        cc.drawingUtil.drawStar(context, new cc.Point(0, 0), lpx, particle.color);
                    } else {
                        cc.drawingUtil.drawColorBall(context, new cc.Point(0, 0), lpx, particle.color);
                    }
                    context.restore()
                }
            }
            context.restore();
        } else {
            //TODO need fixed for webGL
            // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
            // Unneeded states: -
            glBindTexture(GL_TEXTURE_2D, this._texture.getName());

            var quadSize = sizeof(this._quads[0].bl);

            if (cc.USES_VBO) {
                glBindBuffer(GL_ARRAY_BUFFER, this._quadsID);

                if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
                    glBufferData(GL_ARRAY_BUFFER, sizeof(this._quads[0]) * this._totalParticles, this._quads, GL_DYNAMIC_DRAW);
                }

                glVertexPointer(2, GL_FLOAT, quadSize, 0);

                glColorPointer(4, GL_UNSIGNED_BYTE, quadSize, offsetof(ccV2F_C4B_T2F, colors));

                glTexCoordPointer(2, GL_FLOAT, quadSize, offsetof(ccV2F_C4B_T2F, texCoords));
            } else {
                var offset = this._quads;

                // vertex
                var diff = offsetof(cc.V2F_C4B_T2F, vertices);
                glVertexPointer(2, GL_FLOAT, quadSize, (offset + diff));

                // color
                diff = offsetof(cc.V2F_C4B_T2F, colors);
                glColorPointer(4, GL_UNSIGNED_BYTE, quadSize, (offset + diff));

                // tex coords
                diff = offsetof(cc.V2F_C4B_T2F, texCoords);
                glTexCoordPointer(2, GL_FLOAT, quadSize, (offset + diff));
            }


            var newBlend = !!(this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST);
            if (newBlend) {
                glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
            }

            cc.Assert(this._particleIdx == this._particleCount, "Abnormal error in particle quad");

            glDrawElements(GL_TRIANGLES, (this._particleIdx * 6), GL_UNSIGNED_SHORT, this._indices);

            // restore blend state
            if (newBlend)
                glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);

            if (cc.USES_VBO)
                glBindBuffer(GL_ARRAY_BUFFER, 0);
        }
    }
});

/**
 * <p>
 *   creates an initializes a CCParticleSystemQuad from a plist file.<br/>
 *   This plist files can be creted manually or with Particle Designer:<br/>
 *   http://particledesigner.71squared.com/<br/>
 * </p>
 * @param {String} pListFile
 * @return {cc.ParticleSystem}
 * @example
 *  //creates an initializes a CCParticleSystemQuad from a plist file.
 *  var system = cc.ParticleSystemQuad.create("Images/SpinningPeas.plist");
 */
cc.ParticleSystemQuad.create = function (pListFile) {
    var ret = new cc.ParticleSystemQuad();
    if (ret && ret.initWithFile(pListFile)) {
        return ret;
    }
    return null;
};

cc.ARCH_OPTIMAL_PARTICLE_SYSTEM = cc.ParticleSystemQuad;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

cc.MAX_PARTICLE_SIZE = 64;

/** @brief CCParticleSystemPoint is a subclass of CCParticleSystem
 Attributes of a Particle System:
 * All the attributes of Particle System

 Features:
 * consumes small memory: uses 1 vertex (x,y) per particle, no need to assign tex coordinates
 * size can't be bigger than 64
 * the system can't be scaled since the particles are rendered using GL_POINT_SPRITE

 Limitations:
 * On 3rd gen iPhone devices and iPads, this node performs MUCH slower than CCParticleSystemQuad.
 */
cc.ParticleSystemPoint = cc.ParticleSystem.extend({
    //! Array of (x,y,size)
    _vertices:null,
    //! vertices buffer id
    _verticesID:0,
    //ctor:function(){this._super();},

    // super methods
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            this._vertices = [];
            for (var i = 0; i < this._totalParticles; i++) {
                this._vertices[i] = new cc.PointSprite(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), 0);
            }

            if (!this._vertices) {
                cc.Log("cocos2d: Particle system: not enough memory");
                return false;
            }

            if (cc.USES_VBO) {
                glGenBuffers(1, this._verticesID);

                // initial binding
                glBindBuffer(GL_ARRAY_BUFFER, this._verticesID);
                glBufferData(GL_ARRAY_BUFFER, sizeof(cc.PointSprite) * this._totalParticles, this._vertices, GL_DYNAMIC_DRAW);
                glBindBuffer(GL_ARRAY_BUFFER, 0);
            }
            return true;
        }
        return false;
    },

    updateQuadWithParticle:function (particle, newPosition) {
        // place vertices and colos in array
        this._vertices[this._particleIdx].pos = new cc.Vertex2(newPosition.x, newPosition.y);
        this._vertices[this._particleIdx].size = particle.size;
        var color = new cc.Color4B((particle.color.r * 255), (particle.color.g * 255), (particle.color.b * 255), (particle.color.a * 255));
        this._vertices[this._particleIdx].color = color;
    },

    postStep:function () {
        if (cc.USES_VBO) {
            glBindBuffer(GL_ARRAY_BUFFER, this._verticesID);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(cc.PointSprite) * this._particleCount, this._vertices);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }
    },
    draw:function () {
        //TODO
        this._super();

        if (this._particleIdx == 0) {
            return;
        }

        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY
        // Unneeded states: GL_TEXTURE_COORD_ARRAY
        glDisableClientState(GL_TEXTURE_COORD_ARRAY);

        glBindTexture(GL_TEXTURE_2D, this._texture.getName());

        glEnable(GL_POINT_SPRITE_OES);
        glTexEnvi(GL_POINT_SPRITE_OES, GL_COORD_REPLACE_OES, GL_TRUE);

        var pointSize = sizeof(this._vertices[0]);

        if (cc.USES_VBO) {
            glBindBuffer(GL_ARRAY_BUFFER, verticesID);

            if (cc.ENABLE_CACHE_TEXTTURE_DATA)
                glBufferData(GL_ARRAY_BUFFER, sizeof(cc.PointSprite) * this._totalParticles, this._vertices, GL_DYNAMIC_DRAW);

            glVertexPointer(2, GL_FLOAT, pointSize, 0);

            glColorPointer(4, GL_UNSIGNED_BYTE, pointSize, offsetof(cc.PointSprite, color));

            glEnableClientState(GL_POINT_SIZE_ARRAY_OES);

            glPointSizePointerOES(GL_FLOAT, pointSize, offsetof(cc.PointSprite, size));
        } else {
            var offset = this._vertices.length;
            glVertexPointer(2, GL_FLOAT, pointSize, offset);

            var diff = offsetof(cc.PointSprite, color);
            glColorPointer(4, GL_UNSIGNED_BYTE, pointSize, (offset + diff));

            glEnableClientState(GL_POINT_SIZE_ARRAY_OES);
            diff = offsetof(cc.PointSprite, size);
            glPointSizePointerOES(GL_FLOAT, pointSize, (offset + diff));
        }

        var newBlend = (this._blendFunc.src != cc.BLEND_SRC || this._blendFunc.dst != cc.BLEND_DST) ? true : false;
        if (newBlend) {
            glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        }

        glDrawArrays(GL_POINTS, 0, this._particleIdx);

        // restore blend state
        if (newBlend)
            glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);

        // unbind VBO buffer
        if (cc.USES_VBO)
            glBindBuffer(GL_ARRAY_BUFFER, 0);

        glDisableClientState(GL_POINT_SIZE_ARRAY_OES);
        glDisable(GL_POINT_SPRITE_OES);

        // restore GL default state
        glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    },
    setStartSpin:function (varValue) {
        cc.Assert(varValue == 0, "PointParticleSystem doesn't support spinning");
        this._super(varValue);
    },
    setStartSpinVar:function (varValue) {
        cc.Assert(varValue == 0, "PointParticleSystem doesn't support spinning");
        this._super(varValue);
    },
    setEndSpin:function (varValue) {
        cc.Assert(varValue == 0, "PointParticleSystem doesn't support spinning");
        this._super(varValue);
    },
    setEndSpinVar:function (varValue) {
        cc.Assert(varValue == 0, "PointParticleSystem doesn't support spinning");
        this._super(varValue);
    },
    //
    // SIZE > 64 IS NOT SUPPORTED
    //
    setStartSize:function (varValue) {
        cc.Assert(((varValue >= 0) && (varValue <= cc.MAX_PARTICLE_SIZE)), "PointParticleSystem only supports 0 <= size <= 64");
        this._super(varValue);
    },
    setEndSize:function (varValue) {
        cc.Assert(((varValue == cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE) ||
            ( varValue >= 0 && varValue <= cc.MAX_PARTICLE_SIZE)), "PointParticleSystem only supports 0 <= size <= 64");
        this._super(varValue);
    }
});

/** creates an initializes a CCParticleSystemPoint from a plist file.
 This plist files can be creted manually or with Particle Designer:
 */
cc.ParticleSystemPoint.create = function (plistFile) {
    var ret = new cc.ParticleSystemPoint();
    if (ret && ret.initWithFile(plistFile)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * A fire particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFire.create();
 */
cc.ParticleFire = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleFire# */{
    /**
     * initialize a fire particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(150);
        //return this.initWithTotalParticles(250);
    },

    /**
     * initialize a fire particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: speed of particles
            this.modeA.speed = 60;
            this.modeA.speedVar = 20;

            // starting angle
            this._angle = 90;
            this._angleVar = 10;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, 60));
            this._posVar = cc.ccp(40, 20);

            // life of particles
            this._life = 3;
            this._lifeVar = 0.25;


            // size, in pixels
            this._startSize = 54.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.76;
            this._startColor.g = 0.25;
            this._startColor.b = 0.12;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a fire particle system
 * @return {cc.ParticleFire}
 *
 * @example
 * var emitter = cc.ParticleFire.create();
 */
cc.ParticleFire.create = function () {
    var ret = new cc.ParticleFire();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A fireworks particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleFireworks = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleFireworks# */{
    /**
     * initialize a fireworks particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(1500);
        return this.initWithTotalParticles(150);
    },

    /**
     * initialize a fireworks particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, -90);

            // Gravity Mode:  radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            //  Gravity Mode: speed of particles
            this.modeA.speed = 180;
            this.modeA.speedVar = 50;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));

            // angle
            this._angle = 90;
            this._angleVar = 20;

            // life of particles
            this._life = 3.5;
            this._lifeVar = 1;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.5;
            this._startColor.g = 0.5;
            this._startColor.b = 0.5;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.1;
            this._endColor.r = 0.1;
            this._endColor.g = 0.1;
            this._endColor.b = 0.1;
            this._endColor.a = 0.2;
            this._endColorVar.r = 0.1;
            this._endColorVar.g = 0.1;
            this._endColorVar.b = 0.1;
            this._endColorVar.a = 0.2;

            // size, in pixels
            this._startSize = 8.0;
            this._startSizeVar = 2.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a fireworks particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleFireworks.create = function () {
    var ret = new cc.ParticleFireworks();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A sun particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSun.create();
 */
cc.ParticleSun = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleSun# */{
    /**
     * initialize a sun particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(350);
        return this.initWithTotalParticles(150);
    },

    /**
     * initialize a sun particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // additive
            this.setIsBlendAdditive(true);

            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity mode: speed of particles
            this.modeA.speed = 20;
            this.modeA.speedVar = 5;


            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 1;
            this._lifeVar = 0.5;

            // size, in pixels
            this._startSize = 30.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per seconds
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.76;
            this._startColor.g = 0.25;
            this._startColor.b = 0.12;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            return true;
        }
        return false;
    }
});

/**
 * Create a sun particle system
 * @return {cc.ParticleSun}
 *
 * @example
 * var emitter = cc.ParticleSun.create();
 */
cc.ParticleSun.create = function () {
    var ret = new cc.ParticleSun();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A  particle system
/**
 * A galaxy particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleGalaxy.create();
 */
cc.ParticleGalaxy = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleGalaxy# */{
    /**
     * initialize a galaxy particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(200);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a galaxy particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 60;
            this.modeA.speedVar = 10;

            // Gravity Mode: radial
            this.modeA.radialAccel = -80;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 80;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 37.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.12;
            this._startColor.g = 0.25;
            this._startColor.b = 0.76;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(true);
            return true;
        }
        return false;
    }
});
/**
 * Create a galaxy particle system
 * @return {cc.ParticleGalaxy}
 *
 * @example
 * var emitter = cc.ParticleGalaxy.create();
 */
cc.ParticleGalaxy.create = function () {
    var ret = new cc.ParticleGalaxy();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A flower particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFlower.create();
 */
cc.ParticleFlower = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleFlower# */{
    /**
     * initialize a flower particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(250);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a flower particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 80;
            this.modeA.speedVar = 10;

            // Gravity Mode: radial
            this.modeA.radialAccel = -60;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 15;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 30.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.50;
            this._startColor.g = 0.50;
            this._startColor.b = 0.50;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.5;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a flower particle system
 * @return {cc.ParticleFlower}
 *
 * @example
 * var emitter = cc.ParticleFlower.create();
 */
cc.ParticleFlower.create = function () {
    var ret = new cc.ParticleFlower();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A meteor particle system
/**
 * A meteor particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleMeteor.create();
 */
cc.ParticleMeteor = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleMeteor# */{
    /**
     * initialize a meteor particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(150);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a meteor particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(-200, 200);

            // Gravity Mode: speed of particles
            this.modeA.speed = 15;
            this.modeA.speedVar = 5;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 2;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 60.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.2;
            this._startColor.g = 0.4;
            this._startColor.b = 0.7;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.2;
            this._startColorVar.a = 0.1;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a meteor particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleMeteor.create();
 */
cc.ParticleMeteor.create = function () {
    var ret = new cc.ParticleMeteor();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A spiral particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSpiral.create();
 */
cc.ParticleSpiral = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleSpiral# */{
    /**
     * initialize a spiral particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(500);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a spiral particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 150;
            this.modeA.speedVar = 0;

            // Gravity Mode: radial
            this.modeA.radialAccel = -380;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 45;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 0;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 12;
            this._lifeVar = 0;

            // size, in pixels
            this._startSize = 20.0;
            this._startSizeVar = 0.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.5;
            this._startColor.g = 0.5;
            this._startColor.b = 0.5;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.5;
            this._endColor.g = 0.5;
            this._endColor.b = 0.5;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.5;
            this._endColorVar.g = 0.5;
            this._endColorVar.b = 0.5;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a spiral particle system
 * @return {cc.ParticleSpiral}
 *
 * @example
 * var emitter = cc.ParticleSpiral.create();
 */
cc.ParticleSpiral.create = function () {
    var ret = new cc.ParticleSpiral();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * An explosion particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleExplosion.create();
 */
cc.ParticleExplosion = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleExplosion# */{
    /**
     * initialize an explosion particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(700);
        return this.initWithTotalParticles(300);
    },

    /**
     * initialize an explosion particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = 0.1;

            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 70;
            this.modeA.speedVar = 40;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 5.0;
            this._lifeVar = 2;

            // size, in pixels
            this._startSize = 15.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._duration;

            // color of particles
            this._startColor.r = 0.7;
            this._startColor.g = 0.1;
            this._startColor.b = 0.2;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.5;
            this._endColor.g = 0.5;
            this._endColor.b = 0.5;
            this._endColor.a = 0.0;
            this._endColorVar.r = 0.5;
            this._endColorVar.g = 0.5;
            this._endColorVar.b = 0.5;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create an explosion particle system
 * @return {cc.ParticleExplosion}
 *
 * @example
 * var emitter = cc.ParticleExplosion.create();
 */
cc.ParticleExplosion.create = function () {
    var ret = new cc.ParticleExplosion();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A smoke particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSmoke.create();
 */
cc.ParticleSmoke = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleSmoke# */{
    /**
     * initialize a smoke particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(200);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a smoke particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // Emitter mode: Gravity Mode
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, 0);

            // Gravity Mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: speed of particles
            this.modeA.speed = 25;
            this.modeA.speedVar = 10;

            // angle
            this._angle = 90;
            this._angleVar = 5;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, 0));
            this._posVar = cc.ccp(20, 0);

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 60.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.8;
            this._startColor.g = 0.8;
            this._startColor.b = 0.8;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.02;
            this._startColorVar.g = 0.02;
            this._startColorVar.b = 0.02;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a smoke particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleSmoke.create = function () {
    var ret = new cc.ParticleSmoke();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A snow particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSnow.create();
 */
cc.ParticleSnow = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleSnow# */{
    /**
     * initialize a snow particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(250);
        //return this.initWithTotalParticles(700);
    },

    /**
     * initialize a snow particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            // set gravity mode.
            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(0, -1);

            // Gravity Mode: speed of particles
            this.modeA.speed = 5;
            this.modeA.speedVar = 1;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 1;

            // Gravity mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 1;

            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height + 10));
            this._posVar = cc.ccp(winSize.width / 2, 0);

            // angle
            this._angle = -90;
            this._angleVar = 5;

            // life of particles
            this._life = 45;
            this._lifeVar = 15;

            // size, in pixels
            this._startSize = 10.0;
            this._startSizeVar = 5.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = 10;

            // color of particles
            this._startColor.r = 1.0;
            this._startColor.g = 1.0;
            this._startColor.b = 1.0;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 1.0;
            this._endColor.g = 1.0;
            this._endColor.b = 1.0;
            this._endColor.a = 0.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a snow particle system
 * @return {cc.ParticleSnow}
 *
 * @example
 * var emitter = cc.ParticleSnow.create();
 */
cc.ParticleSnow.create = function () {
    var ret = new cc.ParticleSnow();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A rain particle system
/**
 * A rain particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleRain.create();
 */
cc.ParticleRain = cc.ARCH_OPTIMAL_PARTICLE_SYSTEM.extend(/** @lends cc.ParticleRain# */{
    /**
     * initialize a rain particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(300);
        //return this.initWithTotalParticles(1000);
    },

    /**
     * initialize a rain particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.CCPARTICLE_DURATION_INFINITY;

            this._emitterMode = cc.CCPARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.ccp(10, -10);

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 1;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 1;

            // Gravity Mode: speed of particles
            this.modeA.speed = 130;
            this.modeA.speedVar = 30;

            // angle
            this._angle = -90;
            this._angleVar = 5;


            // emitter position
            var winSize = cc.Director.sharedDirector().getWinSize();
            this.setPosition(cc.ccp(winSize.width / 2, winSize.height));
            this._posVar = cc.ccp(winSize.width / 2, 0);

            // life of particles
            this._life = 4.5;
            this._lifeVar = 0;

            // size, in pixels
            this._startSize = 4.0;
            this._startSizeVar = 2.0;
            this._endSize = cc.CCPARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = 20;

            // color of particles
            this._startColor.r = 0.7;
            this._startColor.g = 0.8;
            this._startColor.b = 1.0;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.7;
            this._endColor.g = 0.8;
            this._endColor.b = 1.0;
            this._endColor.a = 0.5;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setIsBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a rain particle system
 * @return {cc.ParticleRain}
 *
 * @example
 * var emitter = cc.ParticleRain.create();
 */
cc.ParticleRain.create = function () {
    var ret = new cc.ParticleRain();
    if (ret.init()) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.Touch = cc.Class.extend(/** @lends cc.Touch# */{
    _viewId:0,
    _point:null,
    _prevPoint:cc.PointZero(),
    _id:0,

    /**
     * Constructor
     */
    ctor:function (viewId, x, y) {
        this._viewId = viewId;
        this._point = new cc.Point(x || 0, y || 0);
    },

    /**
     * @param {Number} viewId
     * @return {cc.Point}
     */
    locationInView:function (viewId) {
        return this._point;
    },

    /**
     * @param {Number} viewId
     * @return {cc.Point}
     */
    previousLocationInView:function (viewId) {
        return this._prevPoint;
    },

    /**
     * @return {Number}
     */
    view:function () {
        return this._viewId;
    },

    /**
     * @return {Number}
     */
    id:function () {
        return this._id;
    },

    /**
     * @param {Number} viewId
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Number} id
     */
    setTouchInfo:function (viewId, x, y, id) {
        this._viewId = viewId;
        this._prevPoint = this._point;
        this._point = new cc.Point(x || 0, y || 0);
        this._id = id || 0;
    },
    _setPrevPoint:function (x, y) {
        this._prevPoint = new cc.Point(x || 0, y || 0);
    }
});

/**
 * @class
 * @extends cc.Class
 */
cc.TouchDelegate = cc.Class.extend(/** @lends cc.TouchDelegate# */{
    _eventTypeFuncMap:null,

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    ccTouchBegan:function (touch, event) {
        return false;
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchMoved:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchEnded:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchCancelled:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesBegan:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesMoved:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesEnded:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchesCancelled:function (touches, event) {
    },

    /*
     * In TouchesTest, class Padle inherits from cc.Sprite and cc.TargetedTouchDelegate.
     * When it invoke  cc.TouchDispatcher.sharedDispatcher().addTargetedDelegate(this, 0, true),
     * it will crash in cc.TouchHandler.initWithDelegate() because of dynamic_cast() on android.
     * I don't know why, so add these functions for the subclass to invoke it's own retain() and  release
     *Virtual function
     */
    touchDelegateRetain:function () {
    },

    /**
     * Virtual function
    */
    touchDelegateRelease:function () {
    }
});

/**
 * Using this type of delegate results in two benefits:
 * - 1. You don't need to deal with cc.Sets, the dispatcher does the job of splitting
 * them. You get exactly one UITouch per call.
 * - 2. You can *claim* a UITouch by returning YES in ccTouchBegan. Updates of claimed
 * touches are sent only to the delegate(s) that claimed them. So if you get a move/
 * ended/cancelled update you're sure it's your touch. This frees you from doing a
 * lot of checks when doing multi-touch.
 *
 * (The name TargetedTouchDelegate relates to updates "targeting" their specific
 * handler, without bothering the other handlers.)
 * @class
 * @extends cc.Class
 */
cc.TargetedTouchDelegate = cc.TouchDelegate.extend(/** @lends cc.TargetedTouchDelegate# */{

    /**
     * Return YES to claim the touch.
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    ccTouchBegan:function (touch, event) {
        return false;
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchMoved:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchEnded:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    ccTouchCancelled:function (touch, event) {
    }
});

/**
 * This type of delegate is the same one used by CocoaTouch. You will receive all the events (Began,Moved,Ended,Cancelled).
 * @class
 * @extends cc.Class
 */
cc.StandardTouchDelegate = cc.TouchDelegate.extend(/** @lends cc.StandardTouchDelegate# */{

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    ccTouchesBegan:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    ccTouchesMoved:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    ccTouchesEnded:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    ccTouchesCancelled:function (touches, event) {
    }
});

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.TouchHandler
 * Object than contains the delegate and priority of the event handler.
 * @class
 * @extends cc.Class
 */
cc.TouchHandler = cc.Class.extend(/** @lends cc.TouchHandler# */{
    _delegate:null,
    _priority:0,
    _enabledSelectors:0,

    /**
     * @return {cc.TouchDelegate}
     */
    getDelegate:function () {
        return this._delegate;
    },

    /**
     * @param {cc.TouchDelegate} delegate
     */
    setDelegate:function (delegate) {
        this._delegate = delegate;
    },

    /**
     * @return {Number}
     */
    getPriority:function () {
        return this._priority;
    },

    /**
     * @param {Number} priority
     */
    setPriority:function (priority) {
        this._priority = priority;
    },

    /**
     *  Enabled selectors
     * @return {Number}
     */
    getEnabledSelectors:function () {
        return this._enabledSelectors;
    },

    /**
     * @param {Number} value
     */
    setEnalbedSelectors:function (value) {
        this._enabledSelectors = value;
    },

    /**
     * initializes a TouchHandler with a delegate and a priority
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority) {
        cc.Assert(delegate != null, "TouchHandler.initWithDelegate():touch delegate should not be null");
        this._delegate = delegate;
        this._priority = priority;
        this._enabledSelectors = 0;
        return true;
    }
});

/**
 *  Allocates a TouchHandler with a delegate and a priority
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @return {cc.TouchHandler}
 */
cc.TouchHandler.handlerWithDelegate = function (delegate, priority) {
    var handler = new cc.TouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority);
    }
    return handler;
};

/**
 * cc.StandardTouchHandler
 * It forwardes each event to the delegate.
 * @class
 * @extends cc.TouchHandler
 */
cc.StandardTouchHandler = cc.TouchHandler.extend(/** @lends cc.StandardTouchHandler# */{
    /**
     * Initializes a TouchHandler with a delegate and a priority
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority) {
        if (this._super(delegate, priority)) {
            return true;
        }
        return false;
    }
});

/**
 * Allocates a TouchHandler with a delegate and a priority
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @return {cc.StandardTouchHandler}
 */
cc.StandardTouchHandler.handlerWithDelegate = function (delegate, priority) {
    var handler = new cc.StandardTouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority);
    }
    return handler;
};

/**
 * @class
 * @extends cc.TouchHandler
 */
cc.TargetedTouchHandler = cc.TouchHandler.extend(/** @lends cc.TargetedTouchHandler# */{
    _swallowsTouches:false,
    _claimedTouches:null,

    /**
     * Whether or not the touches are swallowed
     * @return {Boolean}
     */
    isSwallowsTouches:function () {
        return this._swallowsTouches;
    },

    /**
     * @param {Boolean} swallowsTouches
     */
    setSwallowsTouches:function (swallowsTouches) {
        this._swallowsTouches = swallowsTouches;
    },

    /**
     * MutableSet that contains the claimed touches
     * @return {Array}
     */
    getClaimedTouches:function () {
        return this._claimedTouches;
    },

    /**
     * Initializes a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @param {Boolean} swallow
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority, swallow) {
        if (this._super(delegate, priority)) {
            this._claimedTouches = [];
            this._swallowsTouches = swallow;
            return true;
        }
        return false;
    }
});

/**
 * Allocates a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @param {Boolean} swallow
 * @return {cc.TargetedTouchHandler}
 */
cc.TargetedTouchHandler.handlerWithDelegate = function (delegate, priority, swallow) {
    var handler = new cc.TargetedTouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority, swallow);
    }
    return handler;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorBeganBit = 1 << 0;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorMovedBit = 1 << 1;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorEndedBit = 1 << 2;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorCancelledBit = 1 << 3;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorAllBits = ( cc.TouchSelectorBeganBit | cc.TouchSelectorMovedBit | cc.TouchSelectorEndedBit | cc.TouchSelectorCancelledBit);

/**
 * @constant
 * @type Number
 */
cc.TOUCH_BEGAN = 0;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_MOVED = 1;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_ENDED = 2;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_CANCELLED = 3;

/**
 * @constant
 * @type Number
 */
cc.TouchMax = 4;

/**
 * @function
 * @param {cc.TouchHandler} p1
 * @param {cc.TouchHandler} p2
 * @return {Boolean}
 */
cc.less = function (p1, p2) {
    return p1.getPriority() > p2.getPriority();
};

/**
 * @param {Number} type
 * Constructor
 */
cc.TouchHandlerHelperData = function (type) {
    // we only use the type
    this.type = type;
};

/**
 * cc.TouchDispatcher.
 * Singleton that handles all the touch events.
 * The dispatcher dispatches events to the registered TouchHandlers.
 * There are 2 different type of touch handlers:
 * - Standard Touch Handlers
 * - Targeted Touch Handlers
 *
 * The Standard Touch Handlers work like the CocoaTouch touch handler: a set of touches is passed to the delegate.
 * On the other hand, the Targeted Touch Handlers only receive 1 touch at the time, and they can "swallow" touches (avoid the propagation of the event).
 *
 * Firstly, the dispatcher sends the received touches to the targeted touches.
 * These touches can be swallowed by the Targeted Touch Handlers. If there are still remaining touches, then the remaining touches will be sent
 * to the Standard Touch Handlers.
 * @class
 * @extends cc.Class
 */
cc.TouchDispatcher = cc.Class.extend(/** @lends cc.TouchDispatcher# */{
    _targetedHandlers:null,
    _standardHandlers:null,
    _locked:false,
    _toAdd:false,
    _toRemove:false,
    _handlersToAdd:null,
    _handlersToRemove:null,
    _toQuit:false,
    _dispatchEvents:false,
    _handlerHelperData:[new cc.TouchHandlerHelperData(cc.TOUCH_BEGAN), new cc.TouchHandlerHelperData(cc.TOUCH_MOVED),
        new cc.TouchHandlerHelperData(cc.TOUCH_ENDED), new cc.TouchHandlerHelperData(cc.TOUCH_CANCELLED)],

    /**
     * @return {Boolean}
     */
    init:function () {
        this._dispatchEvents = true;
        this._targetedHandlers = new Array();
        this._standardHandlers = new Array();
        this._handlersToAdd = new Array();
        this._handlersToRemove = new Array();
        this._toRemove = false;
        this._toAdd = false;
        this._toQuit = false;
        this._locked = false;
        return true;
    },

    /**
     * Whether or not the events are going to be dispatched. Default: true
     * @return {Boolean}
     */
    isDispatchEvents:function () {
        return this._dispatchEvents;
    },

    /**
     * @param {Boolean} dispatchEvents
     */
    setDispatchEvents:function (dispatchEvents) {
        this._dispatchEvents = dispatchEvents;
    },

    /**
     * Adds a standard touch delegate to the dispatcher's list.
     * See StandardTouchDelegate description.
     * IMPORTANT: The delegate will be retained.
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     */
    addStandardDelegate:function (delegate, priority) {
        var handler = cc.StandardTouchHandler.handlerWithDelegate(delegate, priority);

        if (!this._locked) {
            this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers);
        } else {
            /* If handler is contained in m_pHandlersToRemove, if so remove it from m_pHandlersToRemove and retrun.
             * Refer issue #752(cocos2d-x)
             */
            if (this._handlersToRemove.indexOf(delegate) != -1) {
                cc.ArrayRemoveObject(this._handlersToRemove, delegate);
                return;
            }

            this._handlersToAdd.push(handler);
            this._toAdd = true;
        }
    },

    /**
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @param {Boolean} swallowsTouches
     */
    addTargetedDelegate:function (delegate, priority, swallowsTouches) {
        var handler = cc.TargetedTouchHandler.handlerWithDelegate(delegate, priority, swallowsTouches);
        if (!this._locked) {
            this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers);
        } else {
            /* If handler is contained in m_pHandlersToRemove, if so remove it from m_pHandlersToRemove and retrun.
             * Refer issue #752(cocos2d-x)
             */
            if (this._handlersToRemove.indexOf(delegate) != -1) {
                cc.ArrayRemoveObject(this._handlersToRemove, delegate);
                return;
            }

            this._handlersToAdd.push(handler);
            this._toAdd = true;
        }
    },

    /**
     *  Force add handler
     * @param {cc.TouchHandler} handler
     * @param {Array} array
     * @return {Array}
     */
    forceAddHandler:function (handler, array) {
        var u = 0;

        for (var i = 0; i < array.length; i++) {
            var h = array[i];
            if (h) {
                if (h.getPriority() < handler.getPriority()) {
                    ++u;
                }
                if (h.getDelegate() == handler.getDelegate()) {
                    cc.Assert(0, "TouchDispatcher.forceAddHandler()");
                    return array;
                }
            }
        }
        return cc.ArrayAppendObjectToIndex(array, handler, u);
    },

    /**
     *  Force remove all delegates
     */
    forceRemoveAllDelegates:function () {
        this._standardHandlers.length = 0;
        this._targetedHandlers.length = 0;
    },

    /**
     * Removes a touch delegate.
     * The delegate will be released
     * @param {cc.TouchDelegate} delegate
     */
    removeDelegate:function (delegate) {
        if (delegate == null) {
            return;
        }

        if (!this._locked) {
            this.forceRemoveDelegate(delegate);
        } else {
            /*
             * If handler is contained in m_pHandlersToAdd, if so remove it from m_pHandlersToAdd and return.
             */
            var handler = this.findHandler(this._handlersToAdd, delegate);
            if (handler) {
                cc.ArrayRemoveObject(this._handlersToAdd, handler);
                return;
            }

            this._handlersToRemove.push(delegate);
            this._toRemove = true;
        }
    },

    /**
     * Removes all touch delegates, releasing all the delegates
     */
    removeAllDelegates:function () {
        if (!this._locked) {
            this.forceRemoveAllDelegates();
        } else {
            this._toQuit = true;
        }
    },

    /**
     * Changes the priority of a previously added delegate. The lower the number,  the higher the priority
     * @param {Number} priority
     * @param {cc.TouchDelegate} delegate
     */
    setPriority:function (priority, delegate) {
        cc.Assert(delegate != null, "TouchDispatcher.setPriority():Arguments is null");

        var handler = this.findHandler(delegate);

        cc.Assert(handler != null, "TouchDispatcher.setPriority():Cant find TouchHandler");

        handler.setPriority(priority);

        this.rearrangeHandlers(this._targetedHandlers);
        this.rearrangeHandlers(this._standardHandlers);
    },

    /**
     * @param {Array} touches
     * @param {event} event
     * @param {Number} index
     */
    touches:function (touches, event, index) {
        cc.Assert(index >= 0 && index < 4, "TouchDispatcher.touches()");

        this._locked = true;

        // optimization to prevent a mutable copy when it is not necessary
        var targetedHandlersCount = this._targetedHandlers.length;
        var standardHandlersCount = this._standardHandlers.length;
        var needsMutableSet = (targetedHandlersCount && standardHandlersCount);

        var mutableTouches = (needsMutableSet ? touches.slice() : touches);
        var helper = this._handlerHelperData[index];
        //
        // process the target handlers 1st
        //
        if (targetedHandlersCount > 0) {
            var touch;
            for (var i = 0; i < touches.length; i++) {
                touch = touches[i];
                var handler;

                for (var j = 0; j < this._targetedHandlers.length; j++) {
                    handler = this._targetedHandlers[j];

                    if (!handler) {
                        break;
                    }

                    var claimed = false;
                    if (index == cc.TOUCH_BEGAN) {
                        claimed = handler.getDelegate().ccTouchBegan(touch, event);

                        if (claimed) {
                            handler.getClaimedTouches().push(touch);
                        }
                        //} else if (handler.getClaimedTouches().indexOf(touch)> -1){
                    } else if (handler.getClaimedTouches().length > 0) {
                        // moved ended cancelled
                        claimed = true;
                        switch (helper.type) {
                            case cc.TOUCH_MOVED:
                                handler.getDelegate().ccTouchMoved(touch, event);
                                break;
                            case cc.TOUCH_ENDED:
                                handler.getDelegate().ccTouchEnded(touch, event);
                                handler.getClaimedTouches().length = 0;
                                //cc.ArrayRemoveObject(handler.getClaimedTouches(),touch);
                                break;
                            case cc.TOUCH_CANCELLED:
                                handler.getDelegate().ccTouchCancelled(touch, event);
                                handler.getClaimedTouches().length = 0;
                                //cc.ArrayRemoveObject(handler.getClaimedTouches(),touch);
                                break;
                        }
                    }

                    if (claimed && handler.isSwallowsTouches()) {
                        if (needsMutableSet) {
                            cc.ArrayRemoveObject(mutableTouches, touch);
                        }
                        break;
                    }
                }
            }
        }

        //
        // process standard handlers 2nd
        //
        if (standardHandlersCount > 0) {
            for (i = 0; i < this._standardHandlers.length; i++) {
                handler = this._standardHandlers[i];

                if (!handler) {
                    break;
                }

                switch (helper.type) {
                    case cc.TOUCH_BEGAN:
                        if (mutableTouches.length > 0) {
                            handler.getDelegate().ccTouchesBegan(mutableTouches, event);
                        }
                        break;
                    case cc.TOUCH_MOVED:
                        if (mutableTouches.length > 0) {
                            handler.getDelegate().ccTouchesMoved(mutableTouches, event);
                        }
                        break;
                    case cc.TOUCH_ENDED:
                        handler.getDelegate().ccTouchesEnded(mutableTouches, event);
                        break;
                    case cc.TOUCH_CANCELLED:
                        handler.getDelegate().ccTouchesCancelled(mutableTouches, event);
                        break;
                }
            }
        }

        if (needsMutableSet) {
            mutableTouches = null;
        }

        //
        // Optimization. To prevent a [handlers copy] which is expensive
        // the add/removes/quit is done after the iterations
        //
        this._locked = false;
        if (this._toRemove) {
            this._toRemove = false;
            for (i = 0; i < this._handlersToRemove.length; i++) {
                this.forceRemoveDelegate(this._handlersToRemove[i]);
            }
            this._handlersToRemove.length = 0;
        }

        if (this._toAdd) {
            this._toAdd = false;

            for (i = 0; i < this._handlersToAdd.length; i++) {
                handler = this._handlersToAdd[i];
                if (!handler) {
                    break;
                }

                if (handler  instanceof cc.TargetedTouchHandler) {
                    this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers);
                } else {
                    this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers);
                }
            }
            this._handlersToAdd.length = 0;
        }

        if (this._toQuit) {
            this._toQuit = false;
            this.forceRemoveAllDelegates();
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesBegan:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_BEGAN);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesMoved:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_MOVED);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesEnded:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_ENDED);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesCancelled:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_CANCELLED);
        }
    },

    /**
     * @param {Array} array
     * @param {cc.TouchDelegate} delegate
     * @return {cc.TargetedTouchHandler|cc.StandardTouchHandler|Null}
     */
    findHandler:function (array, delegate) {
        switch (arguments.length) {
            case 1:
                delegate = arguments[0];
                for (var i = 0; i < this._targetedHandlers.length; i++) {
                    if (this._targetedHandlers[i].getDelegate() == delegate) {
                        return this._targetedHandlers[i];
                    }
                }
                for (i = 0; i < this._standardHandlers.length; i++) {
                    if (this._standardHandlers[i].getDelegate() == delegate) {
                        return this._standardHandlers[i];
                    }
                }
                return null;
                break;
            case 2:
                cc.Assert(array != null && delegate != null, "TouchDispatcher.findHandler():Arguments is null");

                for (i = 0; i < array.length; i++) {
                    if (array[i].getDelegate() == delegate) {
                        return array[i];
                    }
                }

                return null;
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }
    },

    /**
     * @param {cc.TouchDelegate} delegate
     */
    forceRemoveDelegate:function (delegate) {
        var handler;
        // XXX: remove it from both handlers ???
        // remove handler from m_pStandardHandlers
        for (var i = 0; i < this._standardHandlers.length; i++) {
            handler = this._standardHandlers[i];
            if (handler && handler.getDelegate() == delegate) {
                cc.ArrayRemoveObject(this._standardHandlers, handler);
                break;
            }
        }

        for (i = 0; i < this._targetedHandlers.length; i++) {
            handler = this._targetedHandlers[i];
            if (handler && handler.getDelegate() == delegate) {
                cc.ArrayRemoveObject(this._targetedHandlers, handler);
                break;
            }
        }
    },

    /**
     * @param {Array} array
     */
    rearrangeHandlers:function (array) {
        array.sort(cc.less);
    }
});

/**
 * @type {cc.Point}
 */
cc.TouchDispatcher.preTouchPoint = new cc.Point(0, 0);

/**
 * @param {HTMLCanvasElement|HTMLDivElement} element
 */
cc.TouchDispatcher.registerHtmlElementEvent = function (element) {
    //register canvas mouse event
    element.addEventListener("mousedown", function (event) {
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }

        var tx = event.pageX;
        var ty = event.pageY;

        var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
        var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

        var touch = new cc.Touch(0, mouseX, mouseY);
        touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
        cc.TouchDispatcher.preTouchPoint.x = mouseX;
        cc.TouchDispatcher.preTouchPoint.y = mouseY;

        var set = [];
        set.push(touch);
        cc.TouchDispatcher.sharedDispatcher().touchesBegan(set, null);
    });

    element.addEventListener("mouseup", function (event) {
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        var tx = event.pageX;
        var ty = event.pageY;

        var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
        var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

        var touch = new cc.Touch(0, mouseX, mouseY);
        touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
        cc.TouchDispatcher.preTouchPoint.x = mouseX;
        cc.TouchDispatcher.preTouchPoint.y = mouseY;

        var set = [];
        set.push(touch);
        cc.TouchDispatcher.sharedDispatcher().touchesEnded(set, null);
    });

    element.addEventListener("mousemove", function (event) {
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        var tx = event.pageX;
        var ty = event.pageY;

        var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
        var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

        var touch = new cc.Touch(0, mouseX, mouseY);
        touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
        cc.TouchDispatcher.preTouchPoint.x = mouseX;
        cc.TouchDispatcher.preTouchPoint.y = mouseY;

        var set = [];
        set.push(touch);

        cc.TouchDispatcher.sharedDispatcher().touchesMoved(set, null);
    });

    //register canvas touch event
    element.addEventListener("touchstart", function (event) {
        if (!event.touches)
            return;

        var set = [];
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;

        for (var i = 0; i < event.touches.length; i++) {
            var tx = event.touches[i].pageX;
            var ty = event.touches[i].pageY;
            if (event.touches[i]) {
                tx = event.touches[i].clientX;
                ty = event.touches[i].clientY;
            }
            var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

            var touch = new cc.Touch(0, mouseX, mouseY);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            set.push(touch);
        }
        cc.TouchDispatcher.sharedDispatcher().touchesBegan(set, null);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    element.addEventListener("touchmove", function (event) {
        if (!event.touches)
            return;

        var set = [];
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;

        for (var i = 0; i < event.touches.length; i++) {
            var tx = event.touches[i].pageX;
            var ty = event.touches[i].pageY;
            if (event.touches[i]) {
                tx = event.touches[i].clientX;
                ty = event.touches[i].clientY;
            }
            var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

            var touch = new cc.Touch(0, mouseX, mouseY);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            set.push(touch);
        }
        cc.TouchDispatcher.sharedDispatcher().touchesMoved(set, null);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    element.addEventListener("touchend", function (event) {
        if (!event.touches)
            return;

        var set = [];
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;

        var fireTouches = event.touches;
        if (!fireTouches || (fireTouches.length == 0)) {
            fireTouches = event.changedTouches;
        }
        for (var i = 0; i < fireTouches.length; i++) {
            var tx = fireTouches[i].pageX;
            var ty = fireTouches[i].pageY;
            if (fireTouches[i]) {
                tx = fireTouches[i].clientX;
                ty = fireTouches[i].clientY;
            }

            var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

            var touch = new cc.Touch(0, mouseX, mouseY);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            set.push(touch);
        }
        cc.TouchDispatcher.sharedDispatcher().touchesEnded(set, null);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    element.addEventListener("touchcancel", function (event) {
        if (!event.touches)
            return;

        var set = [];
        var el = element;
        var pos = null;
        if (element instanceof HTMLCanvasElement) {
            pos = {left:0, top:0, height:el.height};
        } else {
            pos = {left:0, top:0, height:parseInt(el.style.height)};
        }
        while (el != null) {
            pos.left += el.offsetLeft;
            pos.top += el.offsetTop;
            el = el.offsetParent;
        }
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;

        for (var i = 0; i < event.touches.length; i++) {
            var tx = event.touches[i].pageX;
            var ty = event.touches[i].pageY;
            if (event.touches[i]) {
                tx = event.touches[i].clientX;
                ty = event.touches[i].clientY;
            }
            var mouseX = (tx - pos.left) / cc.Director.sharedDirector().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.sharedDirector().getContentScaleFactor();

            var touch = new cc.Touch(0, mouseX, mouseY);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            set.push(touch);
        }
        cc.TouchDispatcher.sharedDispatcher().touchesCancelled(set, null);
        event.stopPropagation();
        event.preventDefault();
    }, false);
};

cc._pSharedDispatcher = null;

/**
 * @return {cc.TouchDispatcher}
 */
cc.TouchDispatcher.sharedDispatcher = function () {
    if (cc._pSharedDispatcher == null) {
        cc._pSharedDispatcher = new cc.TouchDispatcher();
        cc._pSharedDispatcher.init();
        cc.TouchDispatcher.registerHtmlElementEvent(cc.canvas);
    }
    return cc._pSharedDispatcher;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * you must extend the keypadDelegate and
 * implement your own game logic in
 * keydown and keyup functions
 * @class
 * @extends cc.Class
 */
cc.KeypadDelegate = cc.Class.extend(/** @lends cc.KeypadDelegate# */{
    /**
     * Call back when a key is pressed down
     */
    keyDown:function () {
    },

    /**
     * Call back when a key is released
     */
    keyUp:function () {
    }
});

/**
 * KeypadHandler is an object that contains KeypadDelegate
 * @class
 * @extends cc.Class
 */
cc.KeypadHandler = cc.Class.extend(/** @lends cc.KeypadHandler# */{
    /**
     * returns the keypad delegate
     * @return {cc.KeypadDelegate}
     */
    getDelegate:function () {
        return this._delegate;
    },

    /**
     * set the keypad delegate
     * @param {cc.KeypadDelegate} delegate
     */
    setDelegate:function (delegate) {
        this._delegate = delegate;
    },
    /**
     * initializes a cc.KeypadHandler with a delegate
     * @param {cc.KeypadDelegate} delegate
     * @return {Boolean}
     */
    initWithDelegate:function (delegate) {
        cc.Assert(delegate != null, "It's a wrong delegate!");

        this._delegate = delegate;

        return true;
    },
    _delegate:null
});
/**
 * Create a KeypadHandler with KeypadDelegate
 * @param delegate
 * @return {cc.KeypadHandler}
 */
cc.KeypadHandler.create = function (delegate) {
    var handler = new cc.KeypadHandler();
    handler.initWithDelegate(delegate);
    return handler;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * android back button
 * @deprecated These were for android devices, but does not work in html5 environment
 * @constant
 * @type Number
 */
cc.TYPE_BACK_CLICKED = 1;
/**
 * android menu button
 * @deprecated for android devices, does not work in html5 environment
 * @constant
 * @type Number
 */
cc.TYPE_MENU_CLICKED = 2;
/**
 * keymap
 * @example
 * //Example
 * //to mark a keydown
 * cc.keyDown[65] = true;
 * //or
 * cc.keyMap[cc.KEY.a]
 *
 * //to mark a keyup
 * do cc.keyDown[65] = false;
 *
 * //to find out if a key is down, check
 * if(cc.keyDown[65])
 * //or
 * if,(cc.keyDown[cc.KEY.space])
 * //if its undefined or false or null, its not pressed
 * @constant
 * @type object
 */
cc.KEY = {
    backspace:8,
    tab:9,
    enter:13,
    shift:16, //should use shiftkey instead
    ctrl:17, //should use ctrlkey
    alt:18, //should use altkey
    pause:19,
    capslock:20,
    escape:27,
    pageup:33,
    pagedown:34,
    end:35,
    home:36,
    left:37,
    up:38,
    right:39,
    down:40,
    insert:45,
    Delete:46,
    0:48,
    1:49,
    2:50,
    3:51,
    4:52,
    5:53,
    6:54,
    7:55,
    8:56,
    9:57,
    a:65,
    b:66,
    c:67,
    d:68,
    e:69,
    f:70,
    g:71,
    h:72,
    i:73,
    j:74,
    k:75,
    l:76,
    m:77,
    n:78,
    o:79,
    p:80,
    q:81,
    r:82,
    s:83,
    t:84,
    u:85,
    v:86,
    w:87,
    x:88,
    y:89,
    z:90,
    num0:96,
    num1:97,
    num2:98,
    num3:99,
    num4:100,
    num5:101,
    num6:102,
    num7:103,
    num8:104,
    num9:105,
    '*':106,
    '+':107,
    '-':109,
    'numdel':110,
    '/':111,
    f1:112, //f1-f12 dont work on ie
    f2:113,
    f3:114,
    f4:115,
    f5:116,
    f6:117,
    f7:118,
    f8:119,
    f9:120,
    f10:121,
    f11:122,
    f12:123,
    numlock:144,
    scrolllock:145,
    semicolon:186,
    ',':186,
    equal:187,
    '=':187,
    ';':188,
    comma:188,
    dash:189,
    '.':190,
    period:190,
    forwardslash:191,
    grave:192,
    '[':219,
    openbracket:219,
    ']':221,
    closebracket:221,
    backslash:220,
    quote:222,
    space:32
};

/**
 * Dispatch the keypad message
 * @class
 * @extends cc.Class
 */
cc.KeypadDispatcher = cc.Class.extend(/** @lends cc.KeypadDispatcher# */{
    /**
     * add delegate to concern keypad msg
     * @param {cc.KeypadDelegate} delegate keypad delegate object
     */
    addDelegate:function (delegate) {
        if (!delegate) {
            return;
        }
        if (!this._locked) {
            this.forceAddDelegate(delegate);
        }
        else {
            this._handlersToAdd.push(delegate);
            this._toAdd = true;
        }
    },

    /**
     * remove the delegate from the delegates who concern keypad msg
     * @param {cc.KeypadDelegate} delegate
     */
    removeDelegate:function (delegate) {
        if (!delegate) {
            return;
        }
        if (!this._locked) {
            this.forceRemoveDelegate(delegate);
        }
        else {
            this._handlersToRemove.push(delegate);
            this._toRemove = true;
        }
    },

    /**
     * force add the delegate
     * @param {cc.KeypadDelegate} delegate
     */
    forceAddDelegate:function (delegate) {
        var handler = cc.KeypadHandler.create(delegate);
        if (handler) {
            //if handler already exist
            for (var i = 0; i < this._delegates; i++) {
                if (this._delegates[i].getDelegate() == handler.getDelegate()) {
                }
            }
            this._delegates.push(handler);
        }
    },

    /**
     * force remove the delegate
     * @param {cc.KeypadDelegate} delegate
     */
    forceRemoveDelegate:function (delegate) {
        var i = this._delegates.indexOf(delegate);
        if (i != -1) {
            this._delegates.splice(this._delegates.indexOf(delegate), 1);
        }
    },

    /**
     * dispatch the keypad message to the delegates
     * @param {event} e
     * @param {Boolean} keydown whether this is a keydown or keyup
     * @return {Boolean}
     */
    dispatchKeypadMSG:function (e, keydown) {
        this._locked = true;
        e.stopPropagation();
        e.preventDefault();
        //update keymap
        if (keydown && e)//if keydown and our keymap doesnt have it
        {
            //execute all deletegate that registered a keyboard event
            for (var i = 0; i < this._delegates.length; i++) {
                this._delegates[i].getDelegate().keyDown(e.keyCode);
            }
        }
        else if (!keydown && e)//if keyup and our keymap have that key in it
        {
            for (var i = 0; i < this._delegates.length; i++) {
                this._delegates[i].getDelegate().keyUp(e.keyCode);
            }
        }
        this._locked = false;
        if (this._toRemove) {
            this._toRemove = false;
            for (var i = 0; i < this._handlersToRemove.length; ++i) {
                this.forceRemoveDelegate(this._handlersToRemove[i]);
            }
            delete this._handlersToRemove;
            this._handlersToRemove = [];
        }

        if (this._toAdd) {
            this._toAdd = false;
            for (var i = 0; i < this._handlersToAdd.length; ++i) {
                this.forceAddDelegate(this._handlersToAdd[i]);
            }
            this._handlersToAdd = [];
        }
        return true;
    },

    //private
    _delegates:[],
    _locked:false,
    _toAdd:false,
    _toRemove:false,
    _handlersToAdd:[],
    _handlersToRemove:[]
});

/**
 * Returns the shared cc.KeypadDispatcher object for the system.
 * @return {cc.keypadDispatcher}
 */
cc.KeypadDispatcher.sharedDispatcher = function () {
    if (!cc.keypadDispatcher) {
        cc.keypadDispatcher = new cc.KeypadDispatcher();
        //make canvas focusable
        cc.canvas.setAttribute('contentEditable', true);
        cc.canvas.style.outline='none';
        cc.canvas.style.cursor = 'default';
        cc.canvas.addEventListener("keydown", function (e) {
            cc.keypadDispatcher.dispatchKeypadMSG(e, true);
            cc.IMEDispatcher.sharedDispatcher().processKeycode(e.keyCode);
        });
        cc.canvas.addEventListener("keyup", function (e) {
            cc.keypadDispatcher.dispatchKeypadMSG(e, false);
        });
    }
    return cc.keypadDispatcher;
};

/**
 * Release the shared cc.KeypadDispatcher object from the system.
 */
cc.KeypadDispatcher.purgeSharedDispatcher = function () {
    if (cc.keypadDispatcher) {
        delete cc.keypadDispatcher;
        cc.keypadDispatcher = null;
    }
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * IME Keyboard Notification Info structure
 * @param {cc.Rect} begin the soft keyboard rectangle when animatin begin
 * @param {cc.Rect} end the soft keyboard rectangle when animatin end
 * @param {Number} duration the soft keyboard animation duration
 */
cc.IMEKeyboardNotificationInfo = function (begin, end, duration) {
    this.begin = begin || cc.RectZero();
    this.end = end || cc.RectZero();
    this.duration = duration || 0;
};

/**
 * Input method editor delegate.
 * @class
 * @extends cc.Class
 */
cc.IMEDelegate = cc.Class.extend(/** @lends cc.IMEDelegate# */{
    /**
     * Constructor
     */
    ctor:function () {
        cc.IMEDispatcher.sharedDispatcher().addDelegate(this);
    },
    /**
     * Remove delegate
     */
    removeDelegate:function () {
        cc.IMEDispatcher.sharedDispatcher().removeDelegate(this);
    },
    /**
     * Remove delegate
     * @return {Boolean}
     */
    attachWithIME:function () {
        return cc.IMEDispatcher.sharedDispatcher().attachDelegateWithIME(this);
    },
    /**
     * Detach with IME
     * @return {Boolean}
     */
    detachWithIME:function () {
        return cc.IMEDispatcher.sharedDispatcher().detachDelegateWithIME(this);
    },

    /**
     * Decide the delegate instance is ready for receive ime message or not.<br />
     * Called by CCIMEDispatcher.
     * @return {Boolean}
     */
    canAttachWithIME:function () {
        return false;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didAttachWithIME:function () {
    },

    /**
     * Decide the delegate instance can stop receive ime message or not.
     * @return {Boolean}
     */
    canDetachWithIME:function () {
        return false;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didDetachWithIME:function () {
    },

    /**
     * Called by CCIMEDispatcher when some text input from IME.
     */
    insertText:function (text, len) {
    },

    /**
     * Called by CCIMEDispatcher when user clicked the backward key.
     */
    deleteBackward:function () {
    },

    /**
     * Called by CCIMEDispatcher for get text which delegate already has.
     * @return {String}
     */
    getContentText:function () {
        return "";
    },

    //////////////////////////////////////////////////////////////////////////
    // keyboard show/hide notification
    //////////////////////////////////////////////////////////////////////////
    keyboardWillShow:function (info) {
    },
    keyboardDidShow:function (info) {
    },
    keyboardWillHide:function (info) {
    },
    keyboardDidHide:function (info) {
    }
});


/**
 * Input Method Edit Message Dispatcher.
 * @class
 * @extends cc.Class
 */
cc.IMEDispatcher = cc.Class.extend(/**  @lends cc.IMEDispatcher# */{
    impl:null,
    /**
     * Constructor
     */
    ctor:function () {
        this.impl = new cc.IMEDispatcher.Impl();
    },
    /**
     * Dispatch the input text from ime
     * @param {String} text
     * @param {Number} len
     */
    dispatchInsertText:function (text, len) {
        if (!this.impl || !text || len <= 0)
            return;

        // there is no delegate attach with ime
        if (!this.impl._delegateWithIme)
            return;

        this.impl._delegateWithIme.insertText(text, len);
    },

    /**
     * Dispatch the delete backward operation
     */
    dispatchDeleteBackward:function () {
        if (!this.impl) {
            return;
        }

        // there is no delegate attach with ime
        if (!this.impl._delegateWithIme)
            return;

        this.impl._delegateWithIme.deleteBackward();
    },

    /**
     * Get the content text, which current CCIMEDelegate which attached with IME has.
     * @return {String}
     */
    getContentText:function () {
        if (this.impl && this.impl._delegateWithIme) {
            var pszContentText = this.impl._delegateWithIme.getContentText();
            return (pszContentText) ? pszContentText : "";
        }
        return "";
    },

    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardWillShow:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardWillShow(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardDidShow:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardDidShow(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardWillHide:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardWillHide(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardDidHide:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardDidHide(info);
                }
            }
        }
    },

    /**
     * Add delegate to concern ime msg
     * @param {cc.IMEDelegate} delegate
     * @example
     * //example
     * cc.IMEDispatcher.sharedDispatcher().addDelegate(this);
     */
    addDelegate:function (delegate) {
        if (!delegate || !this.impl) {
            return;
        }
        if (this.impl._delegateList.indexOf(delegate) > -1) {
            // delegate already in list
            return;
        }
        this.impl._delegateList = cc.ArrayAppendObjectToIndex(this.impl._delegateList, delegate, 0);
    },

    /**
     * Attach the pDeleate with ime.
     * @param {cc.IMEDelegate} delegate
     * @return {Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.
     * @example
     * //example
     * var ret = cc.IMEDispatcher.sharedDispatcher().attachDelegateWithIME(this);
     */
    attachDelegateWithIME:function (delegate) {
        if (!this.impl || !delegate) {
            return false;
        }

        // if delegate is not in delegate list, return
        if (this.impl._delegateList.indexOf(delegate) == -1) {
            return false;
        }

        if (this.impl._delegateWithIme) {
            // if old delegate canDetachWithIME return false
            // or delegate canAttachWithIME return false,
            // do nothing.
            if (!this.impl._delegateWithIme.canDetachWithIME()
                || !delegate.canAttachWithIME())
                return false;

            // detach first
            var pOldDelegate = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            pOldDelegate.didDetachWithIME();

            this.impl._delegateWithIme = delegate;
            delegate.didAttachWithIME();
            return true;
        }

        // havn't delegate attached with IME yet
        if (!delegate.canAttachWithIME())
            return false;

        this.impl._delegateWithIme = delegate;
        delegate.didAttachWithIME();
        return true;
    },
    /**
     * Detach the pDeleate with ime.
     * @param {cc.IMEDelegate} delegate
     * @return {Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.
     * @example
     * //example
     * var ret = cc.IMEDispatcher.sharedDispatcher().detachDelegateWithIME(this);
     */
    detachDelegateWithIME:function (delegate) {
        if (!this.impl || !delegate) {
            return false;
        }

        // if delegate is not the current delegate attached with ime, return
        if (this.impl._delegateWithIme != delegate) {
            return false;
        }

        if (!delegate.canDetachWithIME()) {
            return false;
        }

        this.impl._delegateWithIme = 0;
        delegate.didDetachWithIME();
        return true;
    },

    /**
     * Remove the delegate from the delegates who concern ime msg
     * @param {cc.IMEDelegate} delegate
     * @example
     * //example
     * cc.IMEDispatcher.sharedDispatcher().removeDelegate(this);
     */
    removeDelegate:function (delegate) {
        if (!this.impl || !delegate) {
            return;
        }

        // if delegate is not in delegate list, return
        if (this.impl._delegateList.indexOf(delegate) == -1) {
            return;
        }

        if (this.impl._delegateWithIme) {
            if (delegate == this.impl._delegateWithIme) {
                this.impl._delegateWithIme = null;
            }
        }
        cc.ArrayRemoveObject(this.impl._delegateList, delegate);
    },

    /**
     * Process keydown's keycode
     * @param {Number} keyCode
     * @example
     * //example
     * document.addEventListener("keydown", function (e) {
     *      cc.IMEDispatcher.sharedDispatcher().processKeycode(e.keyCode);
     * });
     */
    processKeycode:function (keyCode) {
        if (keyCode < 32) {
            if (keyCode == cc.KEY.backspace) {
                this.dispatchDeleteBackward();
            } else if (keyCode == cc.KEY.enter) {
                this.dispatchInsertText("\n", 1);
            } else if (keyCode == cc.KEY.tab) {
                //tab input
            } else if (keyCode == cc.KEY.escape) {
                //ESC input
            }
        } else if (keyCode < 255) {
            this.dispatchInsertText(String.fromCharCode(keyCode), 1);
        } else {
            //
        }
    }
});

/**
 * @class
 * @extends cc.Class
 */
cc.IMEDispatcher.Impl = cc.Class.extend(/** @lends cc.IMEDispatcher.Impl# */{
    _delegateWithIme:null,
    _delegateList:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._delegateList = [];
    },
    /**
     * Find delegate
     * @param {cc.IMEDelegate} delegate
     * @return {Number|Null}
     */
    findDelegate:function (delegate) {
        for (var i = 0; i < this._delegateList.length; i++) {
            if (this._delegateList[i] == delegate) {
                return i;
            }
        }
        return null;
    }
});

/**
 * Returns the shared CCIMEDispatcher object for the system.
 * @return {cc.IMEDispatcher}
 */
cc.IMEDispatcher.sharedDispatcher = function () {
    if (!cc.IMEDispatcher.instance) {
        cc.IMEDispatcher.instance = new cc.IMEDispatcher();
        cc.KeypadDispatcher.sharedDispatcher();
    }
    return cc.IMEDispatcher.instance;
};

/**
 * @type object
 */
cc.IMEDispatcher.instance = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Text field delegate
 * @class
 * @extends cc.Class
 */
cc.TextFieldDelegate = cc.Class.extend(/** @lends cc.TextFieldDelegate# */{
    /**
     * If the sender doesn't want to attach with IME, return true;
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onTextFieldAttachWithIME:function (sender) {
        return false;
    },

    /**
     * If the sender doesn't want to detach with IME, return true;
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onTextFieldDetachWithIME:function (sender) {
        return false;
    },

    /**
     * If the sender doesn't want to insert the text, return true;
     * @param {cc.TextFieldTTF} sender
     * @param {String} text
     * @param {Number} len
     * @return {Boolean}
     */
    onTextFieldInsertText:function (sender, text, len) {
        return false
    },

    /**
     * f the sender doesn't want to delete the delText, return true;
     * @param {cc.TextFieldTTF} sender
     * @param {String} delText
     * @param {Number} len
     * @return {Boolean}
     */
    onTextFieldDeleteBackward:function (sender, delText, len) {
        return false;
    },

    /**
     * If doesn't want draw sender as default, return true.
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onDraw:function (sender) {
        return false;
    }
});

/**
 * A simple text input field with TTF font.
 * @class
 * @extends cc.LabelTTF
 */
cc.TextFieldTTF = cc.LabelTTF.extend(/** @lends cc.TextFieldTTF# */{
    _lens:null,
    _inputText:"",
    _placeHolder:"",
    _charCount:0,
    _delegate:null,
    _ColorSpaceHolder:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._ColorSpaceHolder = new cc.Color3B(127, 127, 127);
        cc.IMEDispatcher.sharedDispatcher().addDelegate(this);
        this._super();
    },
    /**
     * @return {cc.Node}
     */
    getDelegate:function () {
        return this._delegate;
    },
    /**
     * @param {cc.Node} value
     */
    setDelegate:function (value) {
        this._delegate = value;
    },
    /**
     * @return {Number}
     */
    getCharCount:function () {
        return this._charCount;
    },
    /**
     * @return {cc.Color3B}
     */
    getColorSpaceHolder:function () {
        return this._ColorSpaceHolder;
    },
    /**
     * @param {cc.Color3B} value
     */
    setColorSpaceHolder:function (value) {
        this._ColorSpaceHolder = value;
    },
    /**
     * Initializes the cc.TextFieldTTF with a font name, alignment, dimension and font size
     * @param {String} placeholder
     * @param {cc.Size} dimensions
     * @param {Number} alignment
     * @param {String} fontName
     * @param {Number} fontSize
     * @return {Boolean}
     * @example
     * //example
     * var  textField = new cc.TextFieldTTF();
     * // When five parameters
     * textField.initWithPlaceHolder("<click here for input>", new cc.Size(100,50), cc.TEXT_ALIGNMENT_LEFT,"Arial", 32);
     * // When three parameters
     * textField.initWithPlaceHolder("<click here for input>", "Arial", 32);
     */
    initWithPlaceHolder:function (placeholder, dimensions, alignment, fontName, fontSize) {
        switch (arguments.length) {
            case 5:
                if (placeholder) {
                    this._placeHolder = placeholder;
                }
                return this.initWithString(this._placeHolder, dimensions, alignment, fontName, fontSize);
                break;
            case 3:
                if (placeholder) {
                    this._placeHolder = placeholder;
                }
                fontName = arguments[1];
                fontSize = arguments[2];
                return this.initWithString(this._placeHolder, fontName, fontSize);
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }
    },
    /**
     * Input text property
     * @param {String} text
     * @param {Boolean} isCallParent
     */
    setString:function (text, isCallParent) {
        if (isCallParent && isCallParent == true) {
            this._super(text);
            return;
        }
        if (text) {
            this._inputText = text;
        } else {
            this._inputText = "";
        }

        // if there is no input text, display placeholder instead
        if (!this._inputText.length) {
            this._super(this._placeHolder);
        } else {
            this._super(this._inputText);
        }
        this._charCount = this._inputText.length;
    },
    /**
     * @return {String}
     */
    getString:function () {
        return this._inputText;
    },
    /**
     * @param {String} text
     */
    setPlaceHolder:function (text) {
        this._placeHolder = text || "";
        if (!this._inputText.length) {
            this.setString(this._placeHolder, true);
        }
    },
    /**
     * @return {String}
     */
    getPlaceHolder:function () {
        return this._placeHolder;
    },
    /**
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        var context = ctx || cc.renderContext;
        if (this._delegate && this._delegate.onDraw(this)) {
            return;
        }
        if (this._inputText) {
            this._super(context);
            return;
        }

        // draw placeholder
        var color = this.getColor();
        this.setColor(this._ColorSpaceHolder);
        this._super(context);
        this.setColor(color);
    },

    //////////////////////////////////////////////////////////////////////////
    // CCIMEDelegate interface
    //////////////////////////////////////////////////////////////////////////
    /**
     * Open keyboard and receive input text.
     * @return {Boolean}
     */
    attachWithIME:function () {
        var ret = cc.IMEDispatcher.sharedDispatcher().attachDelegateWithIME(this);
        return ret;
    },
    /**
     * End text input  and close keyboard.
     * @return {Boolean}
     */
    detachWithIME:function () {
        var ret = cc.IMEDispatcher.sharedDispatcher().detachDelegateWithIME(this);
        return ret;
    },
    /**
     * @return {Boolean}
     */
    canAttachWithIME:function () {
        return (this._delegate) ? (!this._delegate.onTextFieldAttachWithIME(this)) : true;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didAttachWithIME:function () {
    },
    /**
     * @return {Boolean}
     */
    canDetachWithIME:function () {
        return (this._delegate) ? (!this._delegate.onTextFieldDetachWithIME(this)) : true;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didDetachWithIME:function () {
    },
    /**
     *  Delete backward
     */
    deleteBackward:function () {
        var nStrLen = this._inputText.length;
        if (nStrLen == 0) {
            // there is no string
            return;
        }

        // get the delete byte number
        var nDeleteLen = 1;    // default, erase 1 byte

        if (this._delegate && this._delegate.onTextFieldDeleteBackward(this, this._inputText[nStrLen - nDeleteLen], nDeleteLen)) {
            // delegate don't want delete backward
            return;
        }

        // if delete all text, show space holder string
        if (nStrLen <= nDeleteLen) {
            this._inputText = "";
            this._charCount = 0;
            this.setString(this._placeHolder, true);
            return;
        }

        // set new input text
        var sText = this._inputText.substring(0, nStrLen - nDeleteLen);
        this.setString(sText);
    },
    /**
     *  Remove delegate
     */
    removeDelegate:function () {
        cc.IMEDispatcher.sharedDispatcher().removeDelegate(this);
    },
    /**
     * @param {String} text
     * @param {Number} len
     */
    insertText:function (text, len) {
        var sInsert = text;

        // insert \n means input end
        var nPos = sInsert.indexOf('\n');
        if (nPos > -1) {
            sInsert = sInsert.substring(0, nPos);
        }

        if (sInsert.length > 0) {
            if (this._delegate && this._delegate.onTextFieldInsertText(this, sInsert, sInsert.length)) {
                // delegate doesn't want insert text
                return;
            }

            var sText = this._inputText + sInsert;
            this._charCount = sText.length;
            this.setString(sText);
        }

        if (nPos == -1) {
            return;
        }

        // '\n' has inserted,  let delegate process first
        if (this._delegate && this._delegate.onTextFieldInsertText(this, "\n", 1)) {
            return;
        }

        // if delegate hasn't process, detach with ime as default
        this.detachWithIME();
    },
    /**
     * @return {String}
     */
    getContentText:function () {
        return this._inputText;
    },

    //////////////////////////////////////////////////////////////////////////
    // keyboard show/hide notification
    //////////////////////////////////////////////////////////////////////////
    keyboardWillShow:function (info) {
    },
    keyboardDidShow:function (info) {
    },
    keyboardWillHide:function (info) {
    },
    keyboardDidHide:function (info) {
    }
});

/**
 *  creates a cc.TextFieldTTF from a fontName, alignment, dimension and font size
 * @param {String} placeholder
 * @param {cc.Size} dimensions
 * @param {Number} alignment
 * @param {String} fontName
 * @param {Number} fontSize
 * @return {cc.TextFieldTTF|Null}
 * @example
 * //example
 * // When five parameters
 * var textField = cc.TextFieldTTF.create("<click here for input>", new cc.Size(100,50), cc.TEXT_ALIGNMENT_LEFT,"Arial", 32);
 * // When three parameters
 * var textField = cc.TextFieldTTF.create("<click here for input>", "Arial", 32);
 */
cc.TextFieldTTF.create = function (placeholder, dimensions, alignment, fontName, fontSize) {
    switch (arguments.length) {
        case 5:
            var ret = new cc.TextFieldTTF();
            if (ret && ret.initWithPlaceHolder("", dimensions, alignment, fontName, fontSize)) {
                if (placeholder) {
                    ret.setPlaceHolder(placeholder);
                }
                return ret;
            }
            return null;
            break;
        case 3:
            var ret = new cc.TextFieldTTF();
            fontName = arguments[1];
            fontSize = arguments[2];
            if (ret && ret.initWithString("", fontName, fontSize)) {
                if (placeholder) {
                    ret.setPlaceHolder(placeholder);
                }
                return ret;
            }
            return null;
            break;
        default:
            throw "Argument must be non-nil ";
            break;
    }
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

if (cc.ENABLE_PROFILERS) {
    //TODO include support/CCProfiling
}

//Possible OpenGL projections used by director
/**
 * sets a 2D projection (orthogonal projection)
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_PROJECTION_2D = 0;

/**
 * sets a 3D projection with a fovy=60, znear=0.5f and zfar=1500.
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_PROJECTION_3D = 1;

/**
 * it calls "updateProjection" on the projection delegate.
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_PROJECTION_CUSTOM = 3;

/**
 * Detault projection is 3D projection
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_PROJECTION_DEFAULT = cc.CCDIRECTOR_PROJECTION_3D;


// backward compatibility stuff
/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_2D = cc.CCDIRECTOR_PROJECTION_2D;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_3D = cc.CCDIRECTOR_PROJECTION_3D;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_CUSTOM = cc.CCDIRECTOR_PROJECTION_CUSTOM;

//Possible Director Types.
/**
 * <p>Will use a Director that triggers the main loop from an NSTimer object <br/>
 * <br/>
 * Features and Limitations:  <br/>
 * - Integrates OK with UIKit objects   <br/>
 * - It the slowest director    <br/>
 * - The interval update is customizable from 1 to 60
 * </p>
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_TYPE_NS_TIMER = 0;

/**
 * <p>will use a Director that triggers the main loop from a custom main loop.<br/>
 * <br/>
 * Features and Limitations:<br/>
 * - Faster than NSTimer Director<br/>
 * - It doesn't integrate well with UIKit objects<br/>
 * - The interval update can't be customizable  </p>
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_TYPE_MAIN_LOOP = 1;

/**
 * <p>Will use a Director that triggers the main loop from a thread, but the main loop will be executed on the main thread.<br/>
 * <br/>
 * Features and Limitations:<br/>
 * - Faster than NSTimer Director<br/>
 * - It doesn't integrate well with UIKit objects<br/>
 * - The interval update can't be customizable </p>
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_TYPE_THREAD_MAIN_LOOP = 2;

/**
 * <p>Will use a Director that synchronizes timers with the refresh rate of the display. <br/>
 * <br/>
 * Features and Limitations:  <br/>
 * - Faster than NSTimer Director <br/>
 * - Only available on 3.1+   <br/>
 * - Scheduled timers & drawing are synchronizes with the refresh rate of the display <br/>
 * - Integrates OK with UIKit objects <br/>
 * - The interval update can be 1/60, 1/30, 1/15  </p>
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_TYPE_DISPLAY_LINK = 3;

/**
 * Default director is the NSTimer directory
 * @constant
 * @type Number
 */
cc.CCDIRECTOR_TYPE_DEFAULT = cc.CCDIRECTOR_TYPE_NS_TIMER;

// backward compatibility stuff
/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_TYPE_NS_TIMER = cc.CCDIRECTOR_TYPE_NS_TIMER;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_TYPE_MAIN_LOOP = cc.CCDIRECTOR_TYPE_MAIN_LOOP;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_TYPE_THREAD_MAIN_LOOP = cc.CCDIRECTOR_TYPE_THREAD_MAIN_LOOP;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_TYPE_DISPLAY_LINK = cc.CCDIRECTOR_TYPE_DISPLAY_LINK;

/**
 * @constant
 * @type Number
 */
cc.DIRECTOR_TYPE_DEFAULT = cc.CCDIRECTOR_TYPE_DEFAULT;


//Possible device orientations
/**
 * Device oriented vertically, home button on the bottom (UIDeviceOrientationPortrait)
 * @constant
 * @type Number
 */
cc.CCDEVICE_ORIENTATION_PORTRAIT = 0;

/**
 * Device oriented horizontally, home button on the right (UIDeviceOrientationLandscapeLeft)
 * @constant
 * @type Number
 */
cc.CCDEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;

/**
 * Device oriented vertically, home button on the top (UIDeviceOrientationPortraitUpsideDown)
 * @constant
 * @type Number
 */
cc.CCDEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;

/**
 * Device oriented horizontally, home button on the left (UIDeviceOrientationLandscapeRight)
 * @constant
 * @type Number
 */
cc.CCDEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;

/**
 * In browsers, we only support 2 orientations by change window size.
 * @constant
 * @type Number
 */
cc.DEVICE_MAX_ORIENTATIONS = 2;

// Backward compatibility stuff
/**
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_PORTRAIT = cc.CCDEVICE_ORIENTATION_PORTRAIT;

/**
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = cc.CCDEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN;

/**
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = cc.CCDEVICE_ORIENTATION_LANDSCAPE_LEFT;

/**
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = cc.CCDEVICE_ORIENTATION_LANDSCAPE_RIGHT;

/**
 * <p>
 *    Class that creates and handle the main Window and manages how<br/>
 *    and when to execute the Scenes.<br/>
 *    <br/>
 *    The cc.Director is also responsible for:<br/>
 *      - initializing the OpenGL context<br/>
 *      - setting the OpenGL pixel format (default on is RGB565)<br/>
 *      - setting the OpenGL pixel format (default on is RGB565)<br/>
 *      - setting the OpenGL buffer depth (default one is 0-bit)<br/>
 *      - setting the projection (default one is 3D)<br/>
 *      - setting the orientation (default one is Protrait)<br/>
 *      <br/>
 *    Since the cc.Director is a singleton, the standard way to use it is by calling:<br/>
 *      - cc.Director.sharedDirector().methodName(); <br/>
 *    <br/>
 *    The CCDirector also sets the default OpenGL context:<br/>
 *      - GL_TEXTURE_2D is enabled<br/>
 *      - GL_VERTEX_ARRAY is enabled<br/>
 *      - GL_COLOR_ARRAY is enabled<br/>
 *      - GL_TEXTURE_COORD_ARRAY is enabled<br/>
 * </p>
 * @class
 * @extends cc.Class
 */
cc.Director = cc.Class.extend(/** @lends cc.Director# */{
    //Variables
    _displayFPS:false,
    _isContentScaleSupported:false,
    _landscape:false,
    _nextDeltaTimeZero:false,
    _paused:false,
    _purgeDirecotorInNextLoop:false,
    _retinaDisplay:false,
    _sendCleanupToScene:false,
    _animationInterval:0.0,
    _oldAnimationInterval:0.0,
    _deviceOrientation:0,
    _projection:0,
    _accumDt:0.0,
    _accumDtForProfiler:0.0,
    _contentScaleFactor:1.0,
    _deltaTime:0.0,
    _frameRate:0.0,
    _winSizeInPixels:null,
    _winSizeInPoints:null,
    _FPSLabel:null,
    _lastUpdate:null,
    _nextScene:null,
    _notificationNode:null,
    _openGLView:null,
    _scenesStack:null,
    _projectionDelegate:null,
    _runningScene:null,
    _szFPS:'',
    _frames:0,
    _totalFrames:0,

    _dirtyRegion:null,

    /**
     * initializes cc.Director
     * @return {Boolean}
     */
    init:function () {
        if (!this._FPSLabel) {
            this._FPSLabel = cc.LabelTTF.create("00.0", "Arial", 24);
        }
        this._FPSLabel.setPosition(cc.ccp(0, 0));
        this._FPSLabel.setAnchorPoint(cc.ccp(0, 0));
        // scenes
        //TODO these are already set to null, so maybe we can remove them in the init?
        this._runningScene = null;
        this._nextScene = null;
        this._notificationNode = null;


        this._oldAnimationInterval = this._animationInterval = 1.0 / cc.defaultFPS;
        this._scenesStack = [];
        // Set default projection (3D)
        this._projection = cc.CCDIRECTOR_PROJECTION_DEFAULT;
        // projection delegate if "Custom" projection is used
        this._projectionDelegate = null;

        //FPS
        this._displayFPS = false;//can remove
        this._totalFrames = this._frames = 0;
        this._szFPS = "";
        this._lastUpdate = new cc.timeval();

        //Paused?
        this._paused = false;

        //purge?
        this._purgeDirecotorInNextLoop = false;
        this._winSizeInPixels = this._winSizeInPoints = cc.SizeMake(cc.canvas.width, cc.canvas.height);

        //portrait mode default
        this._deviceOrientation = cc.DEVICE_ORIENTATION_PORTRAIT;
        this._openGLView = null;
        this._retinaDisplay = false;
        this._contentScaleFactor = 1.0;
        this._isContentScaleSupported = false;
        return true;
    },

    /**
     * rotates the screen if an orientation different than Portrait is used
     */
    applyOrientation:function () {
        var s = this._winSizeInPixels;
        var w = s.width / 2;
        var h = s.height / 2;
        // XXX it's using hardcoded values.
        // What if the the screen size changes in the future?
        switch (this._deviceOrientation) {
            case cc.DEVICE_ORIENTATION_PORTRAIT:
                // nothing
                break;
            case cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN:
                // upside down
                //TODO OpenGL stuff
                /*glTranslatef(w,h,0);
                 glRotatef(180,0,0,1);
                 glTranslatef(-w,-h,0);*/
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT:
                /*glTranslatef(w,h,0);
                 glRotatef(90,0,0,1);
                 glTranslatef(-h,-w,0);*/
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT:
                /*glTranslatef(w,h,0);
                 glRotatef(-90,0,0,1);
                 glTranslatef(-h,-w,0);*/
                break;
        }
    },

    /**
     * calculates delta time since last time it was called
     */
    calculateDeltaTime:function () {
        var now = new cc.timeval();
        now = cc.Time.gettimeofdayCocos2d();
        if (!now) {
            cc.Log("error in gettimeofday");
            this._deltaTime = 0;
            return;
        }

        //new delta time
        if (this._nextDeltaTimeZero) {
            this._deltaTime = 0;
            this._nextDeltaTimeZero = false;
        }
        else {
            this._deltaTime = (now.tv_sec - this._lastUpdate.tv_sec) + (now.tv_usec - this._lastUpdate.tv_usec) / 1000000.0;
            this._deltaTime = Math.max(0, this._deltaTime);
        }

        if (cc.DEBUG) {
            if (this._deltaTime > 0.2) {
                this._deltaTime = 1 / 60.0;
            }
        }
        this._lastUpdate = now;
    },

    /**
     * <p>
     *     converts a UIKit coordinate to an OpenGL coordinate<br/>
     *     Useful to convert (multi) touches coordinates to the current layout (portrait or landscape)
     * </p>
     * @param {cc.Point} point
     * @return {cc.Point}
     */
    convertToGL:function (point) {
        var s = this._winSizeInPoints;
        var newY = s.height - point.y;
        var newX = s.width - point.x;

        var ret = cc.PointZero();
        switch (this._deviceOrientation) {
            case cc.DEVICE_ORIENTATION_PORTRAIT:
                ret = cc.ccp(point.x, newY);
                break;
            case cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN:
                ret = cc.ccp(newX, point.y);
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT:
                ret.x = point.y;
                ret.y = point.x;
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT:
                ret.x = newY;
                ret.y = newX;
                break;
        }
        return ret;
    },

    /**
     * <p>converts an OpenGL coordinate to a UIKit coordinate<br/>
     * Useful to convert node points to window points for calls such as glScissor</p>
     * @param {cc.Point} point
     * @return {cc.Point}
     */
    convertToUI:function (point) {
        var winSize = this._winSizeInPoints;
        var oppositeX = winSize.width - point.x;
        var oppositeY = winSize.height - point.y;
        var uiPoint = cc.PointZero();

        switch (this._deviceOrientation) {
            case cc.DEVICE_ORIENTATION_PORTRAIT:
                uiPoint = cc.ccp(point.x, oppositeY);
                break;
            case cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN:
                uiPoint = cc.ccp(oppositeX, point.y);
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT:
                uiPoint = cc.ccp(point.y, point.x);
                break;
            case cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT:
                // Can't use oppositeX/Y because x/y are flipped
                uiPoint = cc.ccp(winSize.width - point.y, winSize.height - point.x);
                break;
        }
        return uiPoint;

    },

    //_fullRect:null,
    /**
     *  Draw the scene. This method is called every frame. Don't call it manually.
     */
    drawScene:function () {
        // calculate "global" dt
        this.calculateDeltaTime();

        //tick before glClear: issue #533
        if (!this._paused) {
            cc.Scheduler.sharedScheduler().tick(this._deltaTime);
        }
        //this._fullRect = new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height);
        //cc.renderContext.clearRect(this._fullRect.origin.x, this._fullRect.origin.y, this._fullRect.size.width, -this._fullRect.size.height);
        cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);

        /*
         var isSaveContext = false;
         //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         if (this._dirtyRegion) {
         //cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);

         var fullRect = new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height);
         this._dirtyRegion = cc.Rect.CCRectIntersection(this._dirtyRegion, fullRect);

         if(cc.Rect.CCRectEqualToRect(cc.RectZero(), this._dirtyRegion)){
         this._dirtyRegion = null;
         }else{
         cc.renderContext.clearRect(0 | this._dirtyRegion.origin.x, -(0 | this._dirtyRegion.origin.y),
         0 | this._dirtyRegion.size.width, -(0 | this._dirtyRegion.size.height));

         if(!cc.Rect.CCRectEqualToRect(fullRect, this._dirtyRegion)){
         isSaveContext = true;
         cc.renderContext.save();
         cc.renderContext.beginPath();
         cc.renderContext.rect(0 | this._dirtyRegion.origin.x - 1, -(0 | this._dirtyRegion.origin.y - 1),
         0 | this._dirtyRegion.size.width + 2, -(0 | this._dirtyRegion.size.height + 2));
         cc.renderContext.clip();
         cc.renderContext.closePath();
         }
         }
         }
         */

        /* to avoid flickr, nextScene MUST be here: after tick and before draw.
         XXX: Which bug is this one. It seems that it can't be reproduced with v0.9 */
        if (this._nextScene) {
            this.setNextScene();
        }

        //glPushMatrix();
        this.applyOrientation();

        // By default enable VertexArray, ColorArray, TextureCoordArray and Texture2D
        cc.ENABLE_DEFAULT_GL_STATES();

        // draw the scene
        if (this._runningScene) {
            //if (this._dirtyRegion) {
            this._runningScene.visit();
            //}
        }

        /*
         if (this._dirtyRegion) {
         this._dirtyRegion = null;
         if(isSaveContext){
         cc.renderContext.restore();
         }
         }
         */

        // draw the notifications node
        if (this._notificationNode) {
            this._notificationNode.visit();
        }

        if (this._displayFPS) {
            this.showFPS();
        }

        if (cc.ENABLE_PROFILERS) {
            this.showProfilers();
        }

        cc.DISABLE_DEFAULT_GL_STATES();
        //TODO OpenGL
        //glPopMatrix();

        this._totalFrames++;

        // swap buffers
        if (this._openGLView) {
            this._openGLView.swapBuffers();
        }
    },

    addRegionToDirtyRegion:function (rect) {
        if (!rect)
            return;

        if (!this._dirtyRegion) {
            this._dirtyRegion = new cc.Rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            return;
        }
        this._dirtyRegion = cc.Rect.CCRectUnion(this._dirtyRegion,
            new cc.Rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height));
    },

    rectIsInDirtyRegion:function (rect) {
        if (!rect || !this._fullRect)
            return false;

        return cc.Rect.CCRectIntersectsRect(this._fullRect, rect);
    },

    /**
     * <p>
     *   Will enable Retina Display on devices that supports it. <br/>
     *   It will enable Retina Display on iPhone4 and iPod Touch 4.<br/>
     *   It will return YES, if it could enabled it, otherwise it will return NO.<br/>
     *   <br/>
     *   This is the recommened way to enable Retina Display.
     * </p>
     * @param {Boolean} enabled
     * @return {Boolean}
     */
    enableRetinaDisplay:function (enabled) {
        // Already enabled?
        if (enabled && this._contentScaleFactor == 2) {
            return true;
        }

        // Already diabled?
        if (!enabled && this._contentScaleFactor == 1) {
            return false;
        }

        // setContentScaleFactor is not supported
        if (!this._openGLView.canSetContentScaleFactor()) {
            return false;
        }

        var newScale = (enabled) ? 2 : 1;
        this.setContentScaleFactor(newScale);

        // release cached texture
        cc.TextureCache.purgeSharedTextureCache();

        if (cc.DIRECTOR_FAST_FPS) {
            if (!this._FPSLabel) {
                this._FPSLabel = cc.LabelTTF.create("00.0", "Arial", 24);
                this._FPSLabel.setPosition(cc.ccp(0, 0));
                this._FPSLabel.setAnchorPoint(cc.ccp(0, 0));
            }
        }

        this._retinaDisplay = !!(this._contentScaleFactor == 2);

        return true;
    },

    /**
     * end director
     */
    end:function () {
        this._purgeDirecotorInNextLoop = true;
    },

    /**
     * <p>get the size in pixels of the surface. It could be different than the screen size.<br/>
     *   High-res devices might have a higher surface size than the screen size.<br/>
     *   Only available when compiled using SDK >= 4.0.
     * </p>
     * @return {Number}
     */
    getContentScaleFactor:function () {
        return this._contentScaleFactor;
    },

    /**
     * get orientation of device
     * @return {Number}
     */
    getDeviceOrientation:function () {
        return this._deviceOrientation;
    },

    /**
     * returns the display size of the OpenGL view in pixels. It doesn't take into account any possible rotation of the window.
     * @return {cc.Size}
     */
    getDisplaySizeInPixels:function () {
        return this._winSizeInPixels;
    },

    /**
     * <p>
     *    This object will be visited after the main scene is visited.<br/>
     *    This object MUST implement the "visit" selector.<br/>
     *    Useful to hook a notification object, like CCNotifications (http://github.com/manucorporat/CCNotifications)
     * </p>
     * @return {cc.Node}
     */
    getNotificationNode:function () {
        return this._notificationNode;
    },

    /**
     * <p>
     *     returns the size of the OpenGL view in points.<br/>
     *     It takes into account any possible rotation (device orientation) of the window
     * </p>
     * @return {cc.Size}
     */
    getWinSize:function () {
        var tmp = this._winSizeInPoints;
        if (this._deviceOrientation == cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT || this._deviceOrientation == cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT) {
            // swap x,y in landspace mode
            var size = new cc.SizeZero();
            size.width = tmp.height;
            size.height = tmp.width;
            return size;
        }
        return tmp;
    },

    /**
     * <p>
     *   returns the size of the OpenGL view in pixels.<br/>
     *   It takes into account any possible rotation (device orientation) of the window.<br/>
     *   On Mac winSize and winSizeInPixels return the same value.
     * </p>
     * @return {cc.Size}
     */
    getWinSizeInPixels:function () {
        var size = this.getWinSize();

        size.width *= cc.CONTENT_SCALE_FACTOR();
        size.height *= cc.CONTENT_SCALE_FACTOR();

        return size;
    },

    getZEye:function () {
        return (this._winSizeInPixels.height / 1.1566);
    },

    /**
     * pause director
     */
    pause:function () {
        if (this._paused) {
            return;
        }

        this._oldAnimationInterval = this._animationInterval;
        // when paused, don't consume CPU
        this.setAnimationInterval(1 / 4.0);
        this._paused = true;
    },

    /**
     * <p>
     *     Pops out a scene from the queue.<br/>
     *     This scene will replace the running one.<br/>
     *     The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.<br/>
     *     ONLY call it if there is a running scene.
     * </p>
     */
    popScene:function () {
        cc.Assert(this._runningScene != null, "running scene should not null");

        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));

        this._scenesStack.pop();
        var c = this._scenesStack.length;

        if (c == 0) {
            this.end();
        }
        else {
            this._sendCleanupToScene = true;
            this._nextScene = this._scenesStack[c - 1];
        }
    },

    /**
     * Removes cached all cocos2d cached data. It will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache
     */
    purgeCachedData:function () {
        cc.LabelBMFont.purgeCachedData();
        cc.TextureCache.sharedTextureCache().removeUnusedTextures();
    },

    /**
     * purge Director
     */
    purgeDirector:function () {
        // don't release the event handlers
        // They are needed in case the director is run again
        cc.TouchDispatcher.sharedDispatcher().removeAllDelegates();

        if (this._runningScene) {
            this._runningScene.onExit();
            this._runningScene.cleanup();
        }

        this._runningScene = null;
        this._nextScene = null;

        // remove all objects, but don't release it.
        // runWithScene might be executed after 'end'.
        this._scenesStack = [];

        this.stopAnimation();

        // purge bitmap cache
        //cc.LabelBMFont.purgeCachedData();

        // purge all managers
        cc.AnimationCache.purgeSharedAnimationCache();
        cc.SpriteFrameCache.purgeSharedSpriteFrameCache();
        cc.ActionManager.sharedManager().purgeSharedManager();
        cc.Scheduler.purgeSharedScheduler();
        cc.TextureCache.purgeSharedTextureCache();

        if (cc.TARGET_PLATFORM != cc.PLATFORM_MARMALADE) {
            cc.UserDefault.purgeSharedUserDefault();
        }
        // OpenGL view
        this._openGLView = null;
    },

    /**
     * <p>
     *    Suspends the execution of the running scene, pushing it on the stack of suspended scenes.<br/>
     *    The new scene will be executed.<br/>
     *    Try to avoid big stacks of pushed scenes to reduce memory allocation.<br/>
     *    ONLY call it if there is a running scene.
     * </p>
     * @param {cc.Scene} scene
     */
    pushScene:function (scene) {
        cc.Assert(scene, "the scene should not null");

        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));

        this._sendCleanupToScene = false;

        this._scenesStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Replaces the running scene with a new one. The running scene is terminated. ONLY call it if there is a running scene.
     * @param {cc.Scene} scene
     */
    replaceScene:function (scene) {
        cc.Assert(scene != null, "the scene should not be null");

        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));
        var i = this._scenesStack.length;

        this._sendCleanupToScene = true;
        this._scenesStack[i - 1] = scene;
        this._nextScene = scene;
    },

    /**
     * reset director
     */
    resetDirector:function () {
        // don't release the event handlers
        // They are needed in case the director is run again
        cc.TouchDispatcher.sharedDispatcher().removeAllDelegates();

        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));

        if (this._runningScene) {
            this._runningScene.onExit();
            this._runningScene.cleanup();
            this._runningScene.release();
        }

        this._runningScene = null;
        this._nextScene = null;

        // remove all objects, but don't release it.
        // runWithScene might be executed after 'end'.
        this._scenesStack.removeAllObjects();

        this.stopAnimation();

        // purge bitmap cache
        cc.LabelBMFont.purgeCachedData();

        // purge all managers
        cc.AnimationCache.purgeSharedAnimationCache();
        cc.SpriteFrameCache.purgeSharedSpriteFrameCache();
        cc.ActionManager.sharedManager().purgeSharedManager();
        cc.Scheduler.purgeSharedScheduler();
        cc.TextureCache.purgeSharedTextureCache();
    },

    /**
     * changes the projection size
     * @param {cc.Size} newWindowSize
     */
    reshapeProjection:function (newWindowSize) {
        cc.UNUSED_PARAM(newWindowSize);
        this._winSizeInPoints = this._openGLView.getSize();
        this._winSizeInPixels = cc.SizeMake(this._winSizeInPoints.width * this._contentScaleFactor,
            this._winSizeInPoints.height * this._contentScaleFactor);

        this.setProjection(this._projection);
    },

    /**
     * resume director
     */
    resume:function () {
        if (!this._paused) {
            return;
        }
        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));

        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = cc.Time.gettimeofdayCocos2d();
        if (!this._lastUpdate) {
            cc.Log("cocos2d: Director: Error in gettimeofday");
        }

        this._paused = false;
        this._deltaTime = 0;
    },

    /**
     * <p>
     *    Enters the Director's main loop with the given Scene.<br/>
     *    Call it to run only your FIRST scene.<br/>
     *    Don't call it if there is already a running scene.
     * </p>
     * @param {cc.Scene} scene
     */
    runWithScene:function (scene) {
        cc.Assert(scene != null, "running scene should not be null");
        cc.Assert(this._runningScene == null, "_runningScene should be null");

        //this.addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * enables/disables OpenGL alpha blending
     * @param {Boolean} on
     */
    setAlphaBlending:function (on) {
        if (on) {
            //TODO OpenGL
            //glEnable(GL_BLEND);
            //glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        }
        else {
            //glDisable(GL_BLEND);
        }
    },

    /**
     * <p>
     *   The size in pixels of the surface. It could be different than the screen size.<br/>
     *   High-res devices might have a higher surface size than the screen size.<br/>
     *   Only available when compiled using SDK >= 4.0.
     * </p>
     * @param {Number} scaleFactor
     */
    setContentScaleFactor:function (scaleFactor) {
        if (scaleFactor != this._contentScaleFactor) {
            this._contentScaleFactor = scaleFactor;
            this._winSizeInPixels = cc.SizeMake(this._winSizeInPoints.width * scaleFactor, this._winSizeInPoints.height * scaleFactor);

            if (this._openGLView) {
                this.updateContentScaleFactor();
            }

            // update projection
            this.setProjection(this._projection);
        }
    },

    /**
     * enables/disables OpenGL depth test
     * @param {Boolean} on
     */
    setDepthTest:function (on) {
        if (on) {
            /*TODO OpenGL Stuff
             ccglClearDepth(1.0f);
             glEnable(GL_DEPTH_TEST);
             glDepthFunc(GL_LEQUAL);
             //        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
             }
             else
             {
             glDisable(GL_DEPTH_TEST);*/
        }
    },

    /**
     * set Orientation of device
     * @param {Number} deviceOrientation
     */
    setDeviceOrientation:function (deviceOrientation) {
        var eNewOrientation = cc.Application.sharedApplication().setOrientation(deviceOrientation);

        if ((this._deviceOrientation % cc.DEVICE_MAX_ORIENTATIONS) != (eNewOrientation % cc.DEVICE_MAX_ORIENTATIONS)) {
            this._deviceOrientation = eNewOrientation;
            if (cc.renderContextType == cc.CANVAS) {
                var height = cc.canvas.height;
                cc.canvas.height = cc.canvas.width;
                cc.canvas.width = height;
                cc.renderContext.translate(0, cc.canvas.height);
                if (cc.domNode) {
                    var cont = cc.$("#Cocos2dGameContainer");
                    if (cont) {
                        cont.style.width = cc.canvas.width + "px";
                        cont.style.height = cc.canvas.height + "px";
                    }
                }
            }
        } else {
            // this logic is only run on win32 now
            // On win32,the return value of CCApplication::setDeviceOrientation is always CCDEVICE_ORIENTATION_PORTRAIT
            // So,we should calculate the Projection and window size again.
            //this._winSizeInPoints = this._openGLView.getSize();
            //this._winSizeInPixels = cc.SizeMake(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
            //this.setProjection(this._projection);
        }
    },

    /**
     * sets the OpenGL default values
     */
    setGLDefaultValues:function () {
        // This method SHOULD be called only after openGLView_ was initialized
        cc.Assert(this._openGLView, "opengl view should not be null");

        this.setAlphaBlending(true);
        this.setDepthTest(true);
        this.setProjection(this._projection);

        // set other opengl default values
        //TODO OpenGl
        //glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

        if (cc.DIRECTOR_FAST_FPS) {
            if (!this._FPSLabel) {
                this._FPSLabel = cc.LabelTTF.create("00.0", "Arial", 24);
                this._FPSLabel.setPosition(cc.ccp(0, 0));
                this._FPSLabel.setAnchorPoint(cc.ccp(0, 0));
                //this._FPSLabel.retain();
            }
        }
    },

    /**
     * set next delta time is zero
     * @param {Boolean} nextDeltaTimeZero
     */
    setNextDeltaTimeZero:function (nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
    },

    /**
     * set next scene
     */
    setNextScene:function () {
        var runningIsTransition = this._runningScene? this._runningScene instanceof cc.TransitionScene:false;

        var newIsTransition = this._nextScene? this._nextScene instanceof cc.TransitionScene:false;

        // If it is not a transition, call onExit/cleanup
        if (!newIsTransition) {
            if (this._runningScene) {
                this._runningScene.onExit();
            }

            // issue #709. the root node (scene) should receive the cleanup message too
            // otherwise it might be leaked.
            if (this._sendCleanupToScene && this._runningScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;
        if ((!runningIsTransition) && (this._runningScene != null)) {
            this._runningScene.onEnter();
            this._runningScene.onEnterTransitionDidFinish();
        }
    },

    /**
     * set Notification Node
     * @param {cc.Node} node
     */
    setNotificationNode:function (node) {
        this._notificationNode = node;
    },

    /**
     * Set the CCEGLView, where everything is rendered
     * @param {*} openGLView
     */
    setOpenGLView:function (openGLView) {
        cc.Assert(openGLView, "opengl view should not be null");

        if (this._openGLView != openGLView) {
            // because EAGLView is not kind of CCObject
            delete this._openGLView; // [openGLView_ release]
            this._openGLView = openGLView;

            // set size
            this._winSizeInPoints = this._openGLView.getSize();
            this._winSizeInPixels = cc.SizeMake(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
            this.setGLDefaultValues();

            if (this._contentScaleFactor != 1) {
                this.updateContentScaleFactor();
            }

            var touchDispatcher = cc.TouchDispatcher.sharedDispatcher();
            this._openGLView.setTouchDelegate(touchDispatcher);
            touchDispatcher.setDispatchEvents(true);
        }
    },

    /**
     * Sets an OpenGL projection
     * @param {Number} projection
     */
    setProjection:function (projection) {
        var size = this._winSizeInPixels;
        var zeye = this.getZEye();
        switch (projection) {
            case cc.CCDIRECTOR_PROJECTION_2D:
                if (this._openGLView) {
                    this._openGLView.setViewPortInPoints(0, 0, size.width, size.height);
                }
                //TODO OpenGL
                //glMatrixMode(GL_PROJECTION);
                //glLoadIdentity();
                //ccglOrtho(0, size.width, 0, size.height, -1024 * cc.CONTENT_SCALE_FACTOR(),1024 * cc.CONTENT_SCALE_FACTOR());
                //glMatrixMode(GL_MODELVIEW);
                //glLoadIdentity();
                break;

            case cc.CCDIRECTOR_PROJECTION_3D:
                if (this._openGLView) {
                    this._openGLView.setViewPortInPoints(0, 0, size.width, size.height);
                }
                //TODO OpenGl
                /*
                 glMatrixMode(GL_PROJECTION);
                 glLoadIdentity();
                 gluPerspective(60, (GLfloat)size.width/size.height, 0.5f, 1500.0f);

                 glMatrixMode(GL_MODELVIEW);
                 glLoadIdentity();
                 gluLookAt( size.width/2, size.height/2, zeye,
                 size.width/2, size.height/2, 0,
                 0.0f, 1.0f, 0.0f);*/
                break;

            case cc.CCDIRECTOR_PROJECTION_CUSTOM:
                if (this._projectionDelegate) {
                    this._projectionDelegate.updateProjection();
                }
                break;

            default:
                cc.Log("cocos2d: Director: unrecognized projecgtion");
                break;
        }

        this._projection = projection;
    },

    /**
     * shows the FPS in the screen
     */
    showFPS:function () {
        this._frames++;
        this._accumDt += this._deltaTime;

        if (this._accumDt > cc.DIRECTOR_FPS_INTERVAL) {
            this._frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._szFPS = ('' + this._frameRate.toFixed(1));
            this._FPSLabel.setString(this._szFPS);
        }
        this._FPSLabel.draw();
    },

    /**
     * show profiler
     */
    showProfilers:function () {
        if (cc.ENABLE_PROFILERS) {
            this._accumDtForProfiler += this._deltaTime;
            if (this._accumDtForProfiler > 1.0) {
                this._accumDtForProfiler = 0;
                cc.Profiler.sharedProfiler().displayTimers();
            }
        }
    },

    /**
     * update content scale factor
     */
    updateContentScaleFactor:function () {
        // [openGLView responseToSelector:@selector(setContentScaleFactor)]
        if (this._openGLView.canSetContentScaleFactor()) {
            this._openGLView.setContentScaleFactor(this._contentScaleFactor);
            this._isContentScaleSupported = true;
        }
        else {
            cc.Log("cocos2d: setContentScaleFactor:'is not supported on this device");
        }
    },

    /**
     * is support retina display
     * @return {Boolean}
     */
    isRetinaDisplay:function () {
        return this._retinaDisplay;
    },

    /**
     * <p>
     *    Whether or not the replaced scene will receive the cleanup message.<br>
     *    If the new scene is pushed, then the old scene won't receive the "cleanup" message.<br/>
     *    If the new scene replaces the old one, the it will receive the "cleanup" message.
     * </p>
     * @return {Boolean}
     */
    isSendCleanupToScene:function () {
        return this._sendCleanupToScene;
    },

    /**
     * Get current running Scene. Director can only run one Scene at the time
     * @return {cc.Scene}
     */
    getRunningScene:function () {
        return this._runningScene;
    },

    /**
     * Get the FPS value
     * @return {Number}
     */
    getAnimationInterval:function () {
        return this._animationInterval;
    },

    /**
     * Whether or not to display the FPS on the bottom-left corner
     * @return {Boolean}
     */
    isDisplayFPS:function () {
        return this._displayFPS;
    },

    /**
     * Display the FPS on the bottom-left corner
     * @param displayFPS
     */
    setDisplayFPS:function (displayFPS) {
        this._displayFPS = displayFPS;
    },

    /**
     *  Get the CCEGLView, where everything is rendered
     * @return {*}
     */
    getOpenGLView:function () {
        return this._openGLView;
    },

    /**
     * is next delta time zero
     * @return {Boolean}
     */
    isNextDeltaTimeZero:function () {
        return this._nextDeltaTimeZero;
    },

    /**
     * Whether or not the Director is paused
     * @return {Boolean}
     */
    isPaused:function () {
        return this._paused;
    },

    /**
     * How many frames were called since the director started
     * @return {Number}
     */
    getFrames:function () {
        return this._frames;
    },

    /**
     * Sets an OpenGL projection
     * @return {Number}
     */
    getProjection:function () {
        return this._projection;
    }
});

/**
 * returns a shared instance of the director
 * @function
 * @return {cc.Director}
 */
cc.Director.sharedDirector = function () {
    if (cc.firstRun) {
        cc.sharedDirector.init();
        cc.firstRun = false;
    }
    return cc.sharedDirector;
};

/**
 * <p>
 *     There are 4 types of Director.<br/>
 *       - kCCDirectorTypeNSTimer (default)<br/>
 *       - kCCDirectorTypeMainLoop<br/>
 *       - kCCDirectorTypeThreadMainLoop<br/>
 *       - kCCDirectorTypeDisplayLink<br/>
 *      <br/>
 *      Each Director has it's own benefits, limitations.<br/>
 *      Now we only support DisplayLink director, so it has not effect.<br/>
 *      <br/>
 *      This method should be called before any other call to the director.
 * </p>
 * @function
 * @param obDirectorType
 * @return {Boolean}
 */
cc.Director.setDirectorType = function (obDirectorType) {
    // we only support CCDisplayLinkDirector
    cc.Director.sharedDirector();
    return true;
};

/***************************************************
 * implementation of DisplayLinkDirector
 **************************************************/
// should we afford 4 types of director ??
// I think DisplayLinkDirector is enough
// so we now only support DisplayLinkDirector
/**
 * <p>
 *   DisplayLinkDirector is a Director that synchronizes timers with the refresh rate of the display.<br/>
 *   Features and Limitations:<br/>
 *      - Scheduled timers & drawing are synchronizes with the refresh rate of the display<br/>
 *      - Only supports animation intervals of 1/60 1/30 & 1/15<br/>
 * </p>
 * @class
 * @extends cc.Director
 */
cc.DisplayLinkDirector = cc.Director.extend(/** @lends cc.DisplayLinkDirector# */{
    invalid:false,

    /**
     * start Animation
     */
    startAnimation:function () {
        this._lastUpdate = cc.Time.gettimeofdayCocos2d();
        this.invalid = false;
        cc.Application.sharedApplication().setAnimationInterval(this._animationInterval);
    },

    /**
     * main loop of director
     */
    mainLoop:function () {
        if (this._purgeDirecotorInNextLoop) {
            this.purgeDirector();
            this._purgeDirecotorInNextLoop = false;
        }
        else if (!this.invalid) {
            this.drawScene();
        }
    },

    /**
     * stop animation
     */
    stopAnimation:function () {
        this.invalid = true;
    },

    /**
     * set Animation Interval
     * @param {Number} value
     */
    setAnimationInterval:function (value) {
        this._animationInterval = value;
        if (!this.invalid) {
            this.stopAnimation();
            this.startAnimation();
        }
    }
});

cc.sharedDirector = new cc.DisplayLinkDirector();

/**
 * is director first run
 * @type Boolean
 */
cc.firstRun = true;

/**
 * set default fps to 60
 * @type Number
 */
cc.defaultFPS = 60;

/*
 window.onfocus = function () {
 if (!cc.firstRun) {
 cc.Director.sharedDirector().addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));
 }
 };
 */

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var cc = cc = cc || {};


/**
 A CCCamera is used in every CCNode.
 Useful to look at the object from different views.
 The OpenGL gluLookAt() function is used to locate the
 camera.

 If the object is transformed by any of the scale, rotation or
 position attributes, then they will override the camera.

 IMPORTANT: Either your use the camera or the rotation/scale/position properties. You can't use both.
 World coordinates won't work if you use the camera.

 Limitations:

 - Some nodes, like CCParallaxNode, CCParticle uses world node coordinates, and they won't work properly if you move them (or any of their ancestors)
 using the camera.

 - It doesn't work on batched nodes like CCSprite objects when they are parented to a CCSpriteBatchNode object.

 - It is recommended to use it ONLY if you are going to create 3D effects. For 2D effecs, use the action CCFollow or position/scale/rotate.

 */
cc.Camera = cc.Class.extend({
    /*protected:*/
    _eyeX:null,
    _eyeY:null,
    _eyeZ:null,
    _centerX:null,
    _centerY:null,
    _centerZ:null,
    _upX:null,
    _upY:null,
    _upZ:null,
    _dirty:null,

    /*public:*/
    ctor:function () {
        this.restore();
    },
    description:function () {
        return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>";
    },
    /** sets the dirty value */
    setDirty:function (value) {
        this._dirty = value;
    },
    /** get the dirty value */
    getDirty:function () {
        return this._dirty;
    },

    /** sets the camera in the default position */
    restore:function () {
        this._eyeX = this._eyeY = 0.0;
        this._eyeZ = cc.Camera.getZEye();

        this._centerX = this._centerY = this._centerZ = 0.0;

        this._upX = 0.0;
        this._upY = 1.0;
        this._upZ = 0.0;

        this._dirty = false;
    },
    /** Sets the camera using gluLookAt using its eye, center and up_vector */
    locate:function () {
        if (this._dirty) {
            //TODO gl
            //gluLookAt(this._eyeX, this._eyeY, this._eyeZ,this._centerX, this._centerY, this._centerZ,this._upX, this._upY, this._upZ);
        }

    },
    /** sets the eye values in points */
    setEyeXYZ:function (eyeX, eyeY, eyeZ) {
        this._eyeX = eyeX * cc.CONTENT_SCALE_FACTOR;
        this._eyeY = eyeY * cc.CONTENT_SCALE_FACTOR;
        this._eyeZ = eyeZ * cc.CONTENT_SCALE_FACTOR;

        this._dirty = true;
    },
    /** sets the center values in points */
    setCenterXYZ:function (centerX, centerY, fenterZ) {
        this._centerX = centerX * cc.CONTENT_SCALE_FACTOR;
        this._centerY = centerY * cc.CONTENT_SCALE_FACTOR;
        this._centerZ = fenterZ * cc.CONTENT_SCALE_FACTOR;

        this._dirty = true;
    },
    /** sets the up values */
    setUpXYZ:function (upX, upY, upZ) {
        this._upX = upX;
        this._upY = upY;
        this._upZ = upZ;

        this._dirty = true;
    },

    /** get the eye vector values in points */
    getEyeXYZ:function (eyeX, eyeY, eyeZ) {
        eyeX = this._eyeX / cc.CONTENT_SCALE_FACTOR;
        eyeY = this._eyeY / cc.CONTENT_SCALE_FACTOR;
        eyeZ = this._eyeZ / cc.CONTENT_SCALE_FACTOR;
    },
    /** get the center vector values int points */
    getCenterXYZ:function (centerX, centerY, centerZ) {
        centerX = this._centerX / cc.CONTENT_SCALE_FACTOR;
        centerY = this._centerY / cc.CONTENT_SCALE_FACTOR;
        centerZ = this._centerZ / cc.CONTENT_SCALE_FACTOR;
    },
    /** get the up vector values */
    getUpXYZ:function (upX, upY, upZ) {
        upX = this._upX;
        upY = this._upY;
        upZ = this._upZ;
    },

    /*private:*/
    _DISALLOW_COPY_AND_ASSIGN:function (CCCamera) {

    }
});
/** returns the Z eye */
cc.Camera.getZEye = function () {
    return cc.FLT_EPSILON;
};

//cc.CONTENT_SCALE_FACTOR = cc.Director.sharedDirector().getContentScaleFactor();
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Removes object at specified index and pushes back all subsequent objects.Behaviour undefined if index outside [0, num-1].
 * @function
 * @param {Array} arr Source Array
 * @param {Number} index index of remove object
 */
cc.ArrayRemoveObjectAtIndex = function (arr, index) {
    arr.splice(index, 1);
};

/**
 * Searches for the first occurance of object and removes it. If object is not found the function has no effect.
 * @function
 * @param {Array} arr Source Array
 * @param {*} delObj  remove object
 */
cc.ArrayRemoveObject = function (arr, delObj) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == delObj) {
            arr.splice(i, 1);
        }
    }
};

/**
 * Removes from arr all values in minusArr. For each Value in minusArr, the first matching instance in arr will be removed.
 * @function
 * @param {Array} arr Source Array
 * @param {Array} minusArr minus Array
 */
cc.ArrayRemoveArray = function (arr, minusArr) {
    for (var i = 0; i < minusArr.length; i++) {
        cc.ArrayRemoveObject(arr, minusArr[i]);
    }
};

/**
 * Returns index of first occurence of value, -1 if value not found.
 * @function
 * @param {Array} arr Source Array
 * @param {*} value find value
 * @return {Number} index of first occurence of value
 */
cc.ArrayGetIndexOfValue = function (arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1;
};

/**
 * append an object to array
 * @function
 * @param {Array} arr
 * @param {*} addObj
 */
cc.ArrayAppendObject = function (arr, addObj) {
    arr.push(addObj);
};

/**
 * Inserts an object at index
 * @function
 * @param {Array} arr
 * @param {*} addObj
 * @param {Number} index
 * @return {Array}
 */
cc.ArrayAppendObjectToIndex = function (arr, addObj, index) {
    var part1 = arr.slice(0, index);
    var part2 = arr.slice(index);
    part1.push(addObj);
    arr = (part1.concat(part2));
    return arr;
};

/**
 * Returns index of first occurence of object, -1 if value not found.
 * @function
 * @param {Array} arr Source Array
 * @param {*} findObj find object
 * @return {Number} index of first occurence of value
 */
cc.ArrayGetIndexOfObject = function (arr, findObj) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == findObj)
            return i;
    }
    return -1;
};

/**
 * Returns a Boolean value that indicates whether value is present in the array.
 * @function
 * @param {Array} arr
 * @param {*} findObj
 * @return {Boolean}
 */
cc.ArrayContainsObject = function (arr, findObj) {
    return cc.ArrayGetIndexOfObject(arr, findObj) != -1;
};

/**
 * find object from array by target
 * @param {Array} arr source array
 * @param {cc.ListEntry|cc.HashUpdateEntry|cc.HashSelectorEntry} findInt find target
 * @return {cc.ListEntry|cc.HashUpdateEntry|cc.HashSelectorEntry}
 */
cc.HASH_FIND_INT = function (arr, findInt) {
    if (arr == null) {
        return null;
    }
    for (var i = 0; i < arr.length; i++) {
        if (arr[i].target == findInt) {
            return arr[i];
        }
    }
    return null;
};

//data structures
/**
 * A list double-linked list used for "updates with priority"
 * @Class
 * @Construct
 * @param {cc.ListEntry} prev
 * @param {cc.ListEntry} next
 * @param {cc.Class} target not retained (retained by hashUpdateEntry)
 * @param {Number} priority
 * @param {Boolean} paused
 * @param {Boolean} markedForDeletion selector will no longer be called and entry will be removed at end of the next tick
 */
cc.ListEntry = function (prev, next, target, priority, paused, markedForDeletion) {
    this.prev = prev;
    this.next = next;
    this.target = target;
    this.priority = priority;
    this.paused = paused;
    this.makedForDeletion = markedForDeletion;
};

/**
 *  a update entry list
 * @Class
 * @Construct
 * @param {cc.ListEntry} list Which list does it belong to ?
 * @param {cc.ListEntry} entry entry in the list
 * @param {cc.Class} target hash key (retained)
 * @param {Array} hh
 */
cc.HashUpdateEntry = function (list, entry, target, hh) {
    this.list = list;
    this.entry = entry;
    this.target = target;
    this.hh = hh;
};

//
/**
 * Hash Element used for "selectors with interval"
 * @Class
 * @Construct
 * @param {Array} timers
 * @param {cc.Class} target  hash key (retained)
 * @param {Number} timerIndex
 * @param {cc.Timer} currentTimer
 * @param {Boolean} currentTimerSalvaged
 * @param {Boolean} paused
 * @param {Array} hh
 */
cc.HashSelectorEntry = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
    this.timers = timers;
    this.target = target;
    this.timerIndex = timerIndex;
    this.currentTimer = currentTimer;
    this.currentTimerSalvaged = currentTimerSalvaged;
    this.paused = paused;
    this.hh = hh;
};

/**
 * Light weight timer
 * @class
 * @extends cc.Class
 */
cc.Timer = cc.Class.extend(/** @lends cc.Timer# */{
    _interval:0.0,
    _selector:"",

    _target:null,
    _elapsed:0.0,

    /**
     * cc.Timer's Constructor
     * Constructor
     */
    ctor:function () {
    },

    /**
     * returns interval of timer
     * @return {Number}
     */
    getInterval:function () {
        return this._interval;
    },

    /**
     * Initializes a timer with a target, a selector and an interval in seconds.
     * @param {cc.Class} target target
     * @param {String|function} selector Selector
     * @param {Number} seconds second
     * @return {Boolean} <tt>true</tt> if inintialized
     * * */
    initWithTarget:function (target, selector, seconds) {
        try {
            this._target = target;
            this._selector = selector;
            this._elapsed = -1;
            this._interval = seconds || 0;
            return true;
        } catch (e) {
            return false;
        }
    },

    /**
     * triggers the timer
     * @param {Number} dt delta time
     */
    update:function (dt) {
        if (this._elapsed == -1) {
            this._elapsed = 0;
        } else {
            this._elapsed += dt;
        }

        if (this._elapsed >= this._interval) {
            if (this._selector) {
                if (typeof(this._selector) == "string") {
                    this._target[this._selector](this._elapsed);
                } else if (typeof(this._selector) == "function") {
                    this._selector.call(this._target, this._elapsed);
                }
                this._elapsed = 0;
            }
        }
    }
});

/**
 * Allocates a timer with a target, a selector and an interval in seconds.
 * @function
 * @param {cc.Class} target
 * @param {String|function} selector Selector
 * @param {Number} seconds
 * @return {cc.Timer} a cc.Timer instance
 * */
cc.Timer.timerWithTarget = function (target, selector, seconds) {
    if (arguments < 2)
        throw new Error("timerWithTarget'argument can't is null");

    var timer = new cc.Timer();
    if (arguments.length == 2) {
        timer.initWithTarget(target, selector, 0);
    } else {
        timer.initWithTarget(target, selector, seconds);
    }
    return timer;
};

cc._sharedScheduler = null;
/**
 * <p>
 *    Scheduler is responsible of triggering the scheduled callbacks.<br/>
 *    You should not use NSTimer. Instead use this class.<br/>
 *    <br/>
 *    There are 2 different types of callbacks (selectors):<br/>
 *       - update selector: the 'update' selector will be called every frame. You can customize the priority.<br/>
 *       - custom selector: A custom selector will be called every frame, or with a custom interval of time<br/>
 *       <br/>
 *    The 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'. *
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * //register a schedule to scheduler
 * cc.Scheduler.sharedScheduler().scheduleSelector(selector, this, interval, !this._isRunning);
 */
cc.Scheduler = cc.Class.extend(/** @lends cc.Scheduler# */{
    _timeScale:0.0,
    _updatesNegList:[], // list of priority < 0
    _updates0List:[], // list priority == 0
    _updatesPosList:[], // list priority > 0
    _hashForUpdates:[], // hash used to fetch quickly the list entries for pause,delete,etc

    _hashForSelectors:[], //Used for "selectors with interval"

    _currentTarget:null,
    _currentTargetSalvaged:false,
    _updateHashLocked:false, //If true unschedule will not remove anything from a hash. Elements will only be marked for deletion.

    /**
     * Constructor
     */
    ctor:function () {
    },

    //-----------------------private method----------------------
    _removeHashElement:function (element) {
        element.Timer = null;
        element.target = null;
        cc.ArrayRemoveObject(this._hashForSelectors, element);
        element = null;
    },

    /**
     * find Object from Array
     * @private
     * @param {Array} Source Array
     * @param {cc.Class} destination object
     * @return {cc.ListEntry} object if finded, or return null
     */
    _findElementFromArray:function (array, target) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].target == target) {
                return array[i];
            }
        }
        return null;
    },

    _removeUpdateFromHash:function (entry) {
        var element = this._findElementFromArray(this._hashForUpdates, entry.target);
        if (element) {
            //list entry
            cc.ArrayRemoveObject(element.list, element.entry);
            element.entry = null;

            //hash entry
            element.target = null;
            cc.ArrayRemoveObject(this._hashForUpdates, element);
        }
    },

    _init:function () {
        this._timeScale = 1.0;

        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];

        this._hashForUpdates = [];
        this._hashForSelectors = [];

        this._currentTarget = null;
        this._currentTargetSalvaged = false;
        this._updateHashLocked = false;

        return true;
    },

    _priorityIn:function (ppList, target, priority, paused) {
        var listElement = new cc.ListEntry(null, null, target, priority, paused, false);

        // empey list ?
        if (!ppList) {
            ppList = [];
            ppList.push(listElement);
        } else {
            var added = false;
            for (var i = 0; i < ppList.length; i++) {
                if (priority < ppList[i].priority) {
                    ppList = cc.ArrayAppendObjectToIndex(ppList, listElement, i);
                    added = true;
                    break;
                }
            }

            // Not added? priority has the higher value. Append it.
            if (!added) {
                ppList.push(listElement);
            }
        }

        //update hash entry for quick access
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        this._hashForUpdates.push(hashElement);
    },

    _appendIn:function (ppList, target, paused) {
        var listElement = new cc.ListEntry(null, null, target, 0, paused, false);
        ppList.push(listElement);

        //update hash entry for quicker access
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        this._hashForUpdates.push(hashElement);
    },

    //-----------------------public method-------------------------
    /**
     * <p>
     *    Modifies the time of all scheduled callbacks.<br/>
     *    You can use this property to create a 'slow motion' or 'fast forward' effect.<br/>
     *    Default is 1.0. To create a 'slow motion' effect, use values below 1.0.<br/>
     *    To create a 'fast forward' effect, use values higher than 1.0.<br/>
     *    @warning It will affect EVERY scheduled selector / action.
     * </p>
     * @param {Number} timeScale
     */
    setTimeScale:function (timeScale) {
        this._timeScale = timeScale;
    },

    /**
     * returns time scale of scheduler
     * @return {Number}
     */
    getTimeScale:function () {
        return this._timeScale;
    },

    /**
     * 'tick' the scheduler. main loop (You should NEVER call this method, unless you know what you are doing.)
     * @param {Number} dt delta time
     */
    tick:function (dt) {
        this._updateHashLocked = true;

        if (this._timeScale != 1.0) {
            dt *= this._timeScale;
        }

        //Iterate all over the Updates selectors
        var tmpEntry;
        var i = 0;
        for (i = 0; i < this._updatesNegList.length; i++) {
            tmpEntry = this._updatesNegList[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        // updates with priority == 0
        for (i = 0; i < this._updates0List.length; i++) {
            tmpEntry = this._updates0List[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        // updates with priority > 0
        for (i = 0; i < this._updatesPosList.length; i++) {
            tmpEntry = this._updatesPosList[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        //Interate all over the custom selectors
        var elt;
        for (i = 0; i < this._hashForSelectors.length; i++) {
            this._currentTarget = this._hashForSelectors[i];
            elt = this._currentTarget;
            this._currentTargetSalvaged = false;

            if (!this._currentTarget.paused) {
                // The 'timers' array may change while inside this loop
                for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; elt.timerIndex++) {
                    elt.currentTimer = elt.timers[elt.timerIndex];
                    elt.currentTimerSalvaged = false;

                    elt.currentTimer.update(dt);
                    elt.currentTimer = null;
                }
            }

            if ((this._currentTargetSalvaged) && (this._currentTarget.timers.length == 0)) {
                this._removeHashElement(this._currentTarget);
            }
        }

        //delete all updates that are marked for deletion
        // updates with priority < 0
        for (i = 0; i < this._updatesNegList.length; i++) {
            if (this._updatesNegList[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        // updates with priority == 0
        for (i = 0; i < this._updates0List.length; i++) {
            if (this._updates0List[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        // updates with priority > 0
        for (i = 0; i < this._updatesPosList.length; i++) {
            if (this._updatesPosList[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        this._updateHashLocked = false;
        this._currentTarget = null;
    },

    /**
     * <p>
     *   The scheduled method will be called every 'interval' seconds.</br>
     *   If paused is YES, then it won't be called until it is resumed.<br/>
     *   If 'interval' is 0, it will be called every frame, but if so, it recommened to use 'scheduleUpdateForTarget:' instead.<br/>
     *   If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.
     * </p>
     * @param {function} selector
     * @param {cc.Class} target
     * @param {Number} interval
     * @param {Boolean} paused
     * @example
     * //register a schedule to scheduler
     * cc.Scheduler.sharedScheduler().scheduleSelector(selector, this, interval, !this._isRunning);
     */
    scheduleSelector:function (selector, target, interval, paused) {
        cc.Assert(selector, "scheduler.scheduleSelector()");
        cc.Assert(target, "");

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);

        if (!element) {
            // Is this the 1st element ? Then set the pause level to all the selectors of this target
            element = new cc.HashSelectorEntry(null, target, 0, null, null, paused, null);
            this._hashForSelectors.push(element);
        } else {
            cc.Assert(element.paused == paused, "Sheduler.scheduleSelector()");
        }

        if (element.timers == null) {
            element.timers = [];
        } else {
            for (var i = 0; i < element.timers.length; i++) {
                var timer = element.timers[i];
                if (selector == timer._selector) {
                    cc.Log("CCSheduler#scheduleSelector. Selector already scheduled.");
                    timer._interval = interval;
                    return;
                }
            }
        }

        var timer = new cc.Timer();
        timer.initWithTarget(target, selector, interval);
        element.timers.push(timer);
    },

    /**
     * <p>
     *    Schedules the 'update' selector for a given target with a given priority.<br/>
     *    The 'update' selector will be called every frame.<br/>
     *    The lower the priority, the earlier it is called.
     * </p>
     * @param {cc.Class} target
     * @param {Number} priority
     * @param {Boolean} paused
     * @example
     * //register this object to scheduler
     * cc.Scheduler.sharedScheduler().scheduleUpdateForTarget(this, priority, !this._isRunning);
     */
    scheduleUpdateForTarget:function (target, priority, paused) {
        var hashElement = cc.HASH_FIND_INT(this._hashForUpdates, target);

        if (hashElement) {
            if (cc.COCOS2D_DEBUG >= 1) {
                cc.Assert(hashElement.entry.markedForDeletion, "");
            }
            // TODO: check if priority has changed!
            hashElement.entry.markedForDeletion = false;
            return;
        }

        // most of the updates are going to be 0, that's way there
        // is an special list for updates with priority 0
        if (priority == 0) {
            this._appendIn(this._updates0List, target, paused);
        } else if (priority < 0) {
            this._priorityIn(this._updatesNegList, target, priority, paused);
        } else {
            // priority > 0
            this._priorityIn(this._updatesPosList, target, priority, paused);
        }
    },

    /**
     * <p>
     *   Unschedule a selector for a given target.<br/>
     *   If you want to unschedule the "update", use unscheudleUpdateForTarget.
     * </p>
     * @param {function} selector
     * @param {cc.Class} target
     * @example
     * //unschedule a selector of target
     * cc.Scheduler.sharedScheduler().unscheduleSelector(selector, this);
     */
    unscheduleSelector:function (selector, target) {
        // explicity handle nil arguments when removing an object
        if ((target == null) || (selector == null)) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element != null) {
            for (var i = 0; i < element.timers.length; i++) {
                var timer = element.timers[i];
                if (selector == timer._selector) {
                    if ((timer == element.currentTimer) && (!element.currentTimerSalvaged)) {
                        element.currentTimerSalvaged = true;
                    }
                    cc.ArrayRemoveObjectAtIndex(element.timers, i);
                    //update timerIndex in case we are in tick;, looping over the actions
                    if (element.timerIndex >= i) {
                        element.timerIndex--;
                    }

                    if (element.timers.length == 0) {
                        if (this._currentTarget == element) {
                            this._currentTargetSalvaged = true;
                        } else {

                            this._removeHashElement(element);
                        }
                    }
                    return;
                }
            }
        }
    },

    /**
     * Unschedules the update selector for a given target
     * @param {cc.Class} target
     * @example
     * //unschedules the "update" method.
     * cc.Scheduler.sharedScheduler().unscheduleUpdateForTarget(this);
     */
    unscheduleUpdateForTarget:function (target) {
        if (target == null) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForUpdates, target);
        if (element != null) {
            if (this._updateHashLocked) {
                element.entry.markedForDeletion = true;
            } else {
                this._removeUpdateFromHash(element.entry);
            }
        }
    },

    /**
     * Unschedules all selectors for a given target. This also includes the "update" selector.
     * @param {cc.Class} target
     */
    unscheduleAllSelectorsForTarget:function (target) {
        //explicit NULL handling
        if (target == null) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            if ((!element.currentTimerSalvaged) && (cc.ArrayContainsObject(element.timers, element.currentTimer))) {
                element.currentTimerSalvaged = true;
            }
            element.timers.length = 0;

            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            } else {
                this._removeHashElement(element);
            }
        }
        // update selector
        this.unscheduleUpdateForTarget(target);
    },

    /**
     *  <p>
     *      Unschedules all selectors from all targets. <br/>
     *      You should NEVER call this method, unless you know what you are doing.
     *  </p>
     */
    unscheduleAllSelectors:function () {
        // Custom Selectors
        var i;
        for (i = 0; i < this._hashForSelectors.length; i++) {
            // element may be removed in unscheduleAllSelectorsForTarget
            this.unscheduleAllSelectorsForTarget(this._hashForSelectors[i].target);
        }

        //updates selectors
        for (i = 0; i < this._updates0List.length; i++) {
            this.unscheduleUpdateForTarget(this._updates0List[i].target);
        }
        for (i = 0; i < this._updatesNegList.length; i++) {
            this.unscheduleUpdateForTarget(this._updatesNegList[i].target);
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
            this.unscheduleUpdateForTarget(this._updatesPosList[i].target);
        }
    },

    /**
     * <p>
     *    Pauses the target.<br/>
     *    All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.<br/>
     *    If the target is not present, nothing happens.
     * </p>
     * @param {cc.Class} target
     */
    pauseTarget:function (target) {
        cc.Assert(target != null, "Scheduler.pauseTarget():entry must be non nil");

        //customer selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            element.paused = true;
        }

        //update selector
        var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);
        if (elementUpdate) {
            cc.Assert(elementUpdate.entry != null, "Scheduler.pauseTarget():entry must be non nil");
            elementUpdate.entry.paused = true;
        }
    },

    /**
     * Resumes the target.<br/>
     * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.<br/>
     * If the target is not present, nothing happens.
     * @param {cc.Class} target
     */
    resumeTarget:function (target) {
        cc.Assert(target != null, "");

        // custom selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);

        if (element) {
            element.paused = false;
        }

        //update selector
        var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);

        if (elementUpdate) {
            cc.Assert(elementUpdate.entry != null, "Scheduler.resumeTarget():entry must be non nil");
            elementUpdate.entry.paused = false;
        }
    },

    /**
     * Returns whether or not the target is paused
     * @param {cc.Class} target
     * @return {Boolean}
     */
    isTargetPaused:function (target) {
        cc.Assert(target != null, "Scheduler.isTargetPaused():target must be non nil");

        // Custom selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            return element.paused;
        }
        return false;
    }
});

/**
 * returns a shared instance of the Scheduler
 * @function
 * @return {cc.Scheduler}
 */
cc.Scheduler.sharedScheduler = function () {
    if (!cc._sharedScheduler) {
        cc._sharedScheduler = new cc.Scheduler();
        cc._sharedScheduler._init();
    }
    return cc._sharedScheduler;
};

/**
 * purges the shared scheduler. It releases the retained instance.
 * @function
 */
cc.Scheduler.purgeSharedScheduler = function () {
    cc._sharedScheduler = null;
};


/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * A class to pre-load resources before engine start game main loop.
 * @class
 * @extends cc.Class
 */
cc.Loader = cc.Class.extend(/**  @lends cc.Loader# */{
    resourceCount:0,
    loadedResourceCount:0,
    timer:0,

    /**
     *  Check the loading status
     */
    isLoadedComplete:function () {
        var loaderCache = cc.Loader.shareLoader();
        if (loaderCache.loadedResourceCount == loaderCache.resourceCount) {
            if (loaderCache.onload) {
                loaderCache.timer = setTimeout(loaderCache.onload, 16);
            } else {
                cc.Assert(0, "cocos2d:no load callback defined");
            }
        } else {
            if (loaderCache.onloading) {
                loaderCache.timer = setTimeout(loaderCache.onloading, 16);
            }
            else {
                cc.LoaderScene.shareLoaderScene().draw();
            }
            loaderCache.timer = setTimeout(loaderCache.isLoadedComplete, 16);
        }
    },

    /**
     * Callback when loading resource error
     * @param {String} name
     * @example
     * //example
     * cc.Loader.shareLoader().onResLoadingErr(name);
     */
    onResLoadingErr:function (name) {
        cc.Log("cocos2d:Failed loading resource: " + name);
    },

    /**
     *Callback when a resource file loaded.
     * @example
     * //example
     * cc.Loader.shareLoader().onResLoaded();
     */
    onResLoaded:function () {
        this.loadedResourceCount++;
    },

    /**
     *  For loading percentage
     *  You can use this method to create a custom loading screen.
     * @return {Number}
     * @example
     * //example
     * cc.Log(cc.Loader.shareLoader().getProgressBar() + "%");
     */
    getProgressBar:function () {
        var per = this.loadedResourceCount / this.resourceCount;
        per = parseInt(per * 100);
        return per;
    },

    /**
     * status when resources loading success
     * @example
     *  //example
     * cc.Loader.shareLoader().onload = function () {
     *      cc.AppController.shareAppController().didFinishLaunchingWithOptions();
     * };
     */
    onload:undefined,

    /**
     *  status when Resources loading error
     * @example
     * //example
     * cc.Loader.shareLoader().onerror = function () {
     *      //do something
     * };
     */
    onerror:undefined,

    /**
     *  status when Resources loading
     * @example
     * //example
     * cc.Loader.shareLoader().onloading = function () {
     *       cc.LoaderScene.shareLoaderScene().draw();
     * };
     */
    onloading:undefined,

    /**
     * Pre-load the resources before engine start game main loop.
     * There will be some error without pre-loading resources.
     * @param {object} res
     * @example
     * //example
     * var res = [
     *               {type:"image", src:"hello.png"},
     *               {type:"tmx", src:"hello.tmx"}
     *     ]
     * cc.Loader.shareLoader().preload(res);
     */
    preload:function (res) {
        var sharedTextureCache = cc.TextureCache.sharedTextureCache();
        var sharedEngine = cc.AudioManager.sharedEngine();
        var shareParser = cc.SAXParser.shareParser();

        for (var i = 0; i < res.length; i++) {
            switch (res[i].type) {
                case "image":
                    sharedTextureCache.addImage(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "bgm":
                    sharedEngine.preloadBackgroundMusic(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "effect":
                    sharedEngine.preloadEffect(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "plist":
                case "tmx":
                case "fnt":
                    shareParser.preloadPlist(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "tga":
                    //cc.Log("cocos2d:not implemented yet")
                    break;
                default:
                    throw "cocos2d:unknow type : " + res[i].type;
                    break;
            }
        }
        this.isLoadedComplete();
    }
});

/**
 * Share Loader
 * @return {cc.Loader}
 */
cc.Loader.shareLoader = function () {
    if (!cc.shareLoader) {
        cc.shareLoader = new cc.Loader();
    }
    return cc.shareLoader;
};

/**
 * Default loading screen, you can customize the loading screen.
 * @class
 * @extends cc.Class
 */
cc.LoaderScene = cc.Class.extend(/**  @lends cc.LoaderScene# */{
    _logo:new Image(),

    /**
     * Constructor
     */
    ctor:function () {
        this._logo.src = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABBAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuZGlkOjU1RUQ3MTcwQjQ4REUxMTE4RkUxODUzMUE4ODZGQ0I4IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1RUQ3MTcwQjQ4REUxMTE4RkUxODUzMUE4ODZGQ0I4Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQABQQEBAQEBQQEBQcFBAUHCQYFBQYJCggICQgICg0KCwsLCwoNDAwMDQwMDA8PEREPDxcWFhYXGRkZGRkZGRkZGQEGBgYKCQoTDQ0TFhEOERYZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZ/8AAEQgAyACgAwERAAIRAQMRAf/EAMQAAAEEAwEBAAAAAAAAAAAAAAcABAUGAQMIAgkBAQACAwEBAAAAAAAAAAAAAAABAwIEBgUHEAABAwICBAcKCQkFBQkAAAABAgMEAAURBiExEgdBUXEiMrITYXIzc5MUNBU2CIGRodFCUpLSVLFigqIjQ3QWF/DBUyRWwqOzNSbhY0SEpCV1RhgRAAIBAwAGBgYJBAIDAAAAAAABAhEDBCExQXESBVFhMnIzFZGhUhMUNLHB0eEiQmIjBoFTYxbwonMkJf/aAAwDAQACEQMRAD8A5loBUAqAVAKgM4UAsKAyE40BtDaRhtEJ2jspx0YnioRU9qjKTwUFTSpBHBQk8YUAqAVALCgFhQCoDFAKgFQCoDNALCgM4UAsKAzhQHoJoDY2nE0IY5nwlP2qTsjFbaO1Thxo0/kqaGFdJAW2/uR9lqWkvxtQP7xI7h4eQ0qZNFl7GPMYEmIsOsq4U6weIjgNTQxqMXGFIOkViZ1NJSRQkxhQCwoBYUAsKAxhQCwoDGFAIUB7CcaA9homgPYYVxUIqZDCuKgqZ7BXFQVPQYVxUFRyxFUVDRUpGLkTDsmBaIK5FyVstLSpCGhpW4SMNlIrPUVvS9BK+7pZcu50v993f5iiofi3y3KkW9a9DjMuEvaSptY5yVdktYOGusC4jc/7sMzbqri/Ohlcywoc7J14jFTRJ0NyUjQMfouDQe4dFTuMK7GREKTDvccvRuY+gft456STxjjT3aayNKND0RSDqqDNMblhQ4KgmouwVxUFTHYK4qCpgsKoDBZUKCp4KMKCp4IoSYTQDuO12hAFEYtm9c6zxHCxKlJQ6npJAUrA8R2QayRjpNgvGXPxo+w592mgijPQvOW/xo8m592mgUZn11lv8aPJufdpoFJGRe8tg+mjybn3aaB+I9O5my9EjrejvedSEj9mwlC07Su6VAADjqaox4Wy1bsN0F53mibnzN7jtvyDaGnZMiQOYuUmMkrUxFx6KBs4Lc4ODFWrFstSoT+53dhm6yHK+/GCwU2ZN5KJFobSoyEWd9Xm65SccStCNtWI17I2tIqDI7C3gZbanw3Lm0yh5SGy1PjrSFoejK0ELSdCtnh7lFoMZRTVGcO70N1MvJzqs55LCzYUK2psMYrcgFR4eFcZR0Ano6lcdZ00VRUpaeGRVI2Z7DMiodmO+aS9TrJStQx40lIOg0qmTwtGDest4+nDybn3aaCaMXrrLn40fYc+7UaBRmPXOXPxo8m592mgUYject4emj7Dn3aaBSRpXd8vnQmYCT+Ysf7NNAoxPsoKUuNELbWNpKknEEHhFQzJDBYw0VBkjwnXQkmbYgKWnlqUVyB9JxMl8nSe0Xif0jQyJS15WzJe2FSbRaJc2Mk7JeYaUpG0NY2tWNWQsznpSbNe7l2bTpOSi94//p5nn/Ttw8iay+Gu+y/QVeZY39yPpF/TzPP+nLh5E0+Gu+y/QPMsb+5H0jG6ZUzLZIwl3i0yoEVSw2l6QjYSVkYhIJ4dFYzszjrVC2zl2brpCSk+oLXu+7i5O9K6+ur2hcfI9tdCZTgxQqY8nT5u0fq/4ixqGgaToqZsnc+c8qetckuZGsTSbfbrgli1OebANojW4qSJGwkYAfsEqQnukUJLVb4EO1wYtst7KY8CGyiNFjoGCUNNJCUpA4gBQDgpSpJSoApIwKTqIOgigAtmW0Gw3Z6MlCVwZCVKabcAUhbDmhTawdCk/RI4qlNp1RhO2pqjOPd8+6lOUJAzNl1pRyjcHdhTIxUYElWnsVH/AA1fu1HvTp15uK1rUVW7jrwy7S9YNrVlXMl8jql2e1SZ8ZC+zW7HRtpSsDHA4ajhSFqctSqRey7Vp0nJRfWP/wCnmef9OXDyJrP4a77L9BT5ljf3I+kX9PM8/wCnLh5E0+Gu+y/QPMsb+5H0nh3IOdmW1vO5duCW0AqWrsFHADWcBiafDXV+V+glcxxpOiuR9JWyCCQdBGgg1UbZe7KjasEZR06XAOQLNSY10jZ0YE1gWI0p10JJ+0eETyiskVSBxJ9If8YvrGoZmjsrIrTbGS8vNMoDbfq9hWykYDaWgKUeUqOJrp8VUtRp0HzDmsnLKuN+0WHE1sHn0MKWltCnHFhDaAVLWo4BKUjEkniApWhKi26LWwAsQLx7we82Nly0uOMZZglSlyQMUsQkKAdkqGrtHTzUA9wcdc1mZLuz/StR9K5Ry1YllJ9uWmX2f0PoHl2yWjKllg5esUZES1W5pLEZlPAka1KP0lKPOUTrNah6xK9tyUBUd5uZG8s7vc031xewYdskFlSTsntnEFtoAjhLik0AOPd+3lZmvNubyTvEiPws5QYLVwt78xJQ5cbW4AEP6ek43iErPDoJ07VAE7O1uTc7Ot9tIMqDi+3hrKB00/Fp+ChDBA83b58SVa7rHTLtFwaMedFXqW2rhHEpJ5yTwGsoSpuKb1vjVV2lqOZFNXLcTvDct0pxcrKlyCVtvjU/CWr9m8ODtWDoUOXjFbdi87Fz9LPMz8SOdYpquR1dT+8vEfPzTu9peX25CXbRIgNxI60KxbMoDzgKB/OCtivSjlVyeGv4dRzc+VNcu941S4pVe7UFDE16JzlDOJGo4UFDjreQy0xnzMTTKEttiashCRgAVAKOA7pNcxlKl2W8+ocrk5YttvXwkrYx/wBORu+c65qnYbm0ZP8ASNYFiNKNdCSes/hE8orJFUwcSvSJHjF9Y1DM0djZKd/6Ry+OK3Rv+GK6rGX7Udx8q5lKmVc7z+ksgUDqq01VKoKN9+blWaxN5ehObNwvIPblPSREScFeVVzeTGvN5lf4Y8C1s6X+N4PvLruy7MNW/wC4Pfu97u2t3ORmHJrQRma/hE+7KUOe2gjFiP3OzQcVD6xNeCd2Fl26RGHo8d6Q23IlqUiK0tQC3VISVqCE61bKRicNQoSbvOhx0BC5jsdszVFiW+8gv2yNMZnvQtHZyFxiVNId+s2lzBZT9IgY6KA33O2W67TbZcpKNm52d8ybdNbwDre2kodbx4WnkEpWjUdesCgJMyUEEK0pIwIPCDwUAEb1G9WXWXC/dtOEtHjbVzk/IamhBTt4OUW94WT5NnbQDmC1hc6wunpFaR+0j4/VdSNHdwq6H4o8O1ajSuv3U1P8r1nHUJy4W2Q1d46FtuW+S2Q6QRsPoO2lCuI8w6KrUmnXoNqcFOLi9Ukdq2i5sXq1QbvGOLE9hEhHc2xiR+icRXVW5qcU1tR8qybDs3ZQf5XQe1mUHH2872/zH/GHqprmcvxpbz6byr5S33SSsXs5F75zrmqNhu7Rk/0jWDLUaE66Ek/Z/CJ5RWSKpA4lekSPGL6xqGZo6syvMWzk21qQcFt2ttSDxKSziPlFdXYdLCf6T5VnxUs6aep3PrHeRs4R822Ji5JKW5bf7K4s4+DeSNJ71Q5wrHFyFdhXo1mXNeXTw77guzLsv/m0HWRbeN7W/Dz+Yntsv2hwzXEK0oMWEoJYbPjXdnHlNc5k3feXGz6NyzFWPjxhtpV7ztty4IbS4++4G2m0qcdcVoSlCRtKUe4AMa1zfOW7Rm3Nmad9mUt4NwivRsiz5kyx5WU5oQWgwtO3s8Cn1c7aw52odGpB1L52eOoAvO+7SoNbVzYfLyWHkOlhwsPhCgrYdSAVIVhqUARooDZ533aAoGfUhMuJNH75stLP5zZxHyGpBU408xZDUlCtlTSgva7g1/JWUZcLTK7ttTg49IJ7tlmNfsn50ukaImO9fJ0i/wBuYSnZKWoqipoYcBdbDiv0qmvFJlUY+7hGuwdbibybhlB62OKxdtMlSEA6+xfHaJ+JW1XuctuVt06GcX/JsfgyFP2160FavROcOPt53t/mP+MPVTXM5fjS3n03lXylvuknYvZyL3zvXNUbDe2jJ/pGsCxGhGuhJPWjwieUVkiuQOJXpEjxi+sahmSOmrA4U5Ngf/FJ/wCDXVWH+wu6fMc23/70n/k+s57y7me55aVNNuXgi4RXIkhsk4YLSQlY/OQTiK5qzflbrw7UfQ8vCt5CjxrsSUkdP+67Y0W3KV0zE4nCReJfm7Kzr83hjD5XFq+KqTdDHmmI9fbK9Ym3FNMXRSIs95s4KTDUcZGyeBS2wWx31AO5EC1yIMW2qitogwVsOQGWxshhcQgslvDolGGjuUBIGVjicaAY3i+s2W03C8vkdjbor0tYPCGUFeHwkYUABtwGYcxwrncbdmxl1gZyC8z2WS9jsyHCopkbB4yjZVs68E46qA6H85oCr5xfblWZqQ0oLS2+kpUOJQKT8tAD1TgWkoUAUqBSoHUQdBFAOIK2jJjsuAebrUllaODs18wjDi2TWUO0im+q23uAxuc27BvAzHlZw4DZfZCTwrhPkD9UmvS5bLhuuJzv8igrmLC50P6ToGvcOHOPt53t/mP+MPVTXM5fjS3n03lXylvuknYvZuL3zvXNUbDd2jJ/pGsC1GhGuhJP2jwieUVkiuQN5XpEjxi+sahmSOkLC7jlGC3wm2JSPhZrqLPgLunz3LS+Ll3/AKwc7sckR895fzdbEBKL3Dbiy7Q8rRg6kuBTZP1XRzT3cDXLH0NHSu6N2LG3d2KFGxQ7CbcjT2VDZW3MQ6rt0LSdIUlZ+KoJLyJXBUgiZObsvwnSxJusZt4HBSC4CQe7s44UBIx7pGmNB+I+3IZVqcaUFp+MUBA54juXnKlzszRIVcwzCURrDbz7aXD9jaoCZXHt6mokcx0Fm3qQqAMBiyWk7CCgjSkhOjRwaKAdedHHRQA0v2abbbHrxZpk5ptLj6X2EFeJSoqClDAY4Yg0BCx7jGlt9rFfQ+3wqbUFAcuGqgN6JOytKhrCgR8BonpMZqqYNV4Wz3jpSUc1uZMcJA4RLi9of1jXoY74cldZz+dHj5bLqX0MPZroDganH2872/zH/GHqprmcvxpbz6byr5S33STsXs3G753rmqNhvbRk/wBI1gWI0I10JJ+0dNPKKyRXMG8n0h/xi+sahmSOhMtOA2C1tnUYbSfjQBXVY6raW4+fZypkzf6vrIj3epPmWasw29RwU5ExA7rD+H+1XKzVGfQYOsUw/RoTMK6TLjEV2SbkEruEcdBchsbKXxxLUjmr+tgDrFQZFYzvmKUP/ZoDpa2k7U11BwVgrU2CNWjSqgBfLl2m1kJnzGIqjpCHFAKP6IxNQCVy5fm2ZHneXri06tPhW2VhSVJ4lo4vgoAzWq9N3WGiSgbC+i80dOwsaxycVSB95yeOgKTmzM8o9pbbc6WW0AiXJScD3UJV9EDhNQwAq73OyC4LSmfHUohO0UrCudw4qGI+WgNsGQ9CdRNgO4HWFIOKFjiOGgipARodwRMjNSUYgODSniUNBHwGo2kPUVDMRx94WApOsvwtrl81SDXoWvmI/wBDwLjry6b6pfSH010KPn5x9vO9v8x/xh6qa5nL8aW8+m8q+Ut90k7F7Nxu+c65qjYb20ZP9I1gWI0I10JJ+0eETyiskVSBvK9If8YvrGoZmg75ddwsls7kVrqiuoxn+3HccNn263p7yt5Gk+ot7ymVHZbnOSI3cwkI7RH6wFc9lw4bsl1nYYM+OxF9R0gJOnXWubYGN42YnLHFfmNEG5XB9bUUq07IHSXh+aMMO7UIMALrrr7q3nlqdecO044s7SlE8JJrIxqe4z8mG+iTFcWxIbO0262dlQI7ooKnSW6jOBv0VxL5Si4x9lqc2nQF449m6BwbWBB7tYmQS5MxTbDi0K5+ydjlPD8FSDlPPmcZF8nvW+A6pFmYWUc04GQtJwLi+NOPRFCGykYEcGAqSKkxYbw5apaErUTBdUEvtHUMdG2OIioJDdYlFKCwDiC6kp/TwolpRjclSLfUyGQoXT3hFuAgtRJStpWOgJixdkknuEVv2NOSjnr74eVvpkvpYcGcw2KVcPVMS4x5Vy2FOKjR1h1SUI1lRRiEgd017qvQb4U9JxksO9G37yUXGPWco7zfb/MX8Yeqmudy/GlvPonKflLfdJOxezkXvneuao2G9tGT/SNYFiNCNdCSetHhE8tZIqkDiV6Q/wCMX1jUMzQZ7C7hZ7cMf/DN9UV0+O/247jj8yP7st5Us5qdtWYrXmGOMFpLbgI/xIygcPhTXk8yt0mpdJ7XJrtbTj7LOiI1zZmxmJsdQUxJbQ+0ocKXEhQ/LXm1PYAdvsC03a0I/cmK4tHFtKdwP5BREMGsGKZLgQPhrKKqyq7c4FUJsnc5miNYvXrsJIihrt1thYL6WsMdtTevDDTx1tvEdKnjrm8XOgy3TrdgZ6biJJ7OZGfbcHBzE9ok/AU1ptUPatz4lUMub7g5EynfZbKsHWYThQRrBXggH4NqoLDnzKWTrjmma3brYx20lYKsCQlKUp1qUo6ABx1fasuZ52ZmKytJI5y3eXjKDjbV0YSjtklTLragttYGg4KHCOEVlex3AqxOYK86FBcTs4itc9MO9hnMW+HapU4rKezYccQ2hTjitlIOASnEkmpjokqmGRGUrbjHW0CbMUS7tzZN6uKfNnLpJedS2VjtSHFFasQk6AAcDjUuVXUm1bUIKPQkH/crlL1FlxV7lN7NxvYDiQoYKRET4NP6Z55+Cvc5dY4IcT1yOG/ked7697uL/DD6fuAhvO9v8x/xh6qa8rK8aW86vlPylvuknYvZyN3znXNUbDe2jJ/pGsCxDdOuhJP2jwieWskVTBxJ9Jf8YvrGoMwr2V/C1wRjqYb6orpsfw1uOVyl+7Lea8zwvWtmebbG1Ij/AOYZHCSnpD4U1Xm2veW30rSWYF33V1V1PQTG6zMomWVVmeX/AJq2H9kDrVHWcR9hXN+KubZ1CHe9CyOX/Ljdyho7SdYlKddbTpUqG7htqA4ezUAo9ypQaAxaJSY8hDh4CCDyVnCXCzVyLbnBo6Onb9LdIy07FbgLTeH4xjrUVJMdJUjYUsfSOjUnCvTeVHhOajy25x9QPN1kBcm+XLMpSRCtUZUdtw6lSpfMSgHjSjaUa8uTqzqbEOGKQTpMZN9gXCxFQSq6RHojSidAdWnFv9cCsC5go3Z5z/kW9uuXCKpY2Vwp0foOoKVDawx+klSdRrdxryizxOZYcrmlExvW3lQc4IiRYEdTEKHtrSXikuLW4ACSE4gAAaKsychTWgo5fgzhLiYJLVbHr3dGIDIwDitp5zgQ0nStZ5BXnnQIMK5DacdghuO0nAFRwCWmxrPcCRQSaSqyp5atDu8rOyA4lQsMHBySo6MI6FaE98+r+2itvEx3enTYtZ5fNM9YlhzfbloW/wC46mSlCUJQ2kJbSAlCE6AlIGAAHEBXSpUPmrk5aWcgbzfb/Mf8YeqmuZy/GlvPpvKvlLfdJKxezcbvneuao2G9tGb/AEjWBYhunXQkn7R4RPLWSK5A4lekv+MX1jUMyQTLUcLbC8Q31RXS4/hx3HMZPiy3kih4pNXlFCmSzJylmBm829P+VdUVdmNCSFeEaPLrFc/m4/u51XZZ0WDke8hR9pBgtF/blMx7rbXQptY2kEgHWMFIWk/EoGtA3yBu+7HLuY31Tcu3JnLtwdJU9ap215kVnWWHk4lsE/QUNHBWRDQ2hbkJbLqF5lzXaoNvxxUITplSFpGsNowSMeWhHCi6retFvgxrFlyOYtihEqaDhBefdV033jwrV8gqCRki4gyCy2rntALUoHDZOPNHLQkhs62fLub5SJ7MlNmzYpOFxeUP8nKIACVqA0odI6RojFopB3bXFC9qferazGGtxDqnlEfmoSASakJE9AhW20MG32VC3FPkCTMdA7Z8jUAB0ED6vx0pXQRKUYqregrt/uUi6SW8r2IGTIkOBuStrSHF46Gkn6idajw8gqyMG3wrS2a0rqUXdufhhHT9/wBgdcjZdi5PszduaKVzHCHp8kfvHiMNH5qNSf8AtrqMXGVmFNu0+ac25lLMvOX5V2V1fay5Nv48NX0PNTOSt5Z2s/ZiPHMPVTXLZnjS3n1TlHydvuknY/ZuL3zvXNUbDf2jN/pGsCxDdOuhJPWfwieUVkiuQOZPpL/jF9Y1DMkEy1/8theIb6orpcfw47jmMnxZbx5V5QaJkRmdGciyBtNuDXwpI1KHdFV3bSuR4WWWrrtS4kVODcLpkycppaS/b3zipGpKwPpIP0Vjhrnb9iVqVGdLYyI3Y1Rf4GYrfc2g5GfGJ6Ta+aoHiIqgvHT60vtFAOyo6ULGghQ1HEUBGC9yW21tOjF9PNS5xHuioA3Yujkdt3Y0vunEuHgHz0A1MgkkqViTpJOvGgPbRU5tFOylCBi46rmoSONSjoFTGLZXcuxhrIO4356W4LNlxK5EiSeyXKbB7RzHQUND6KeNXDyVbFaeGOls1pKv47rSitn29YUMh5JYyvH88l7L17kJwccGlLKD+7Qesrh5K97Bw1aXE+0cbzrmUsr8EPDXr3l7Q6RXpJnMyttDtqQRQqaOXt4itvPF/Vxyz1U1yuZ40t59W5P8na7pL2P2bi9871zWvsN/aMn+kawLEaE66Ek9Z/CJ5RWSK5A5k+kv+MX1jUMyQTLX/wAsh+Ib6orpcfw47jl8nxZbxyp1CdZq5yRUkzQua2ngqt3UWK02MJkuLKZVHktJcaVrSeA8YPAaou3IyVJI2LUJwdYsqUiE7Ce7e3OqwGoY88dziUK8e7ZUXoeg9q1e4u0qMdxc0SmeZICgRoKmzgfhSdFa9DYqSHr2FIVtuSQlZ19olST8gNRwmLl1Hs3W2p6U5HIhK1H8gqeEx949iGz2ZLez6Ow5Kc4FOnsm/iGKjWSojBq49qiM1vXjMCktyHUx4QOIQBsNDkSNKjy1ZGEp9RXJ27OnXIIOVxZsvt4xG+0lrGDsxzAuEcQ+qnuCvWxVbtalp6Tns93sntOkegusa/tKw/urfV5M8WeJKJLsXGO7qVge7Vikac7XSPkuYjEHEVYmac7JzTn045yvh45R6qa5bM8aW8+mcoVMO33Scsfs5G753rmtfYb20ZP9I1gWI0J10JJ20eETyiskVzB1K9Jf8YvrGoZkgl2wY2yGP+4b6orpsfw1uOYyfFlvNrkfa1Gs3CpWp0GbsFZ1VTK0y6N1DJy3O8RqiVhs2I5CQ0ctrx+iaolitmxHMQ0ds63Okgnu1S8RlyzIjc2JR4FCsHhyM/jYmU5fUfrU+DkQ82I8ZsCknFLenjw+erI4bKpZ8SUYs0jRoNXRxmjUuZaZMxbO+CDgavjYZqTyETsW2upAxxFbEbLNK5fROxo5RhtK1VfCFDzr1zi1Eyw8EJA/LVpqs53z0cc33o8ck9UVzGX40t59B5Z8rb7pO2P2ci9851zWvsNzaMn+kawLEaU66Ek5aPCJ5RWSK5g7k+kveMX1jUElsteaYbEJmPLbcS6ykNgtgKCgnUdYwr1sfPjGCUlqPJyOXylNyi1pHn83Wnif+wPnq7zG31lHltzpQv5utP1X/sD56eY2+seWXeoX832nif8AsD56eY2+seW3eoX83Wj6r32B89PMbfWPLbvSjH822f6j3kx89PMLRPlt3pRj+bLN9R7yY+enmFoeXXelGRm2zjUh7yY+enmFojy270o3oznZ060PeTHz08wt9Y8su9Q5Rnuyp+jIHI2Pnp5jb6zF8quvoHCd4FjTwSfJj71SuZW+srfJ7r2o3p3jWAa0yfJj71T5na6yt8lvP2TcneVl4a0yvJD71T5na6yp8hvPbH0m3+qGXkJJS3LWoDEI7MDE8WJVR80tU1Mw/wBfvt6XEE93uK7vdJlzcQG1y3VOlAOISDqGPcFeJdm5zcuk6qxZVq3GC/KqFysns5F753rmsdhntGT3SNYFiNCddCSdtHhE8orJFcgdyfSH/GL6xqCToHLvu62B7J9izVnjeDByqrMTPnduhvoQQWSAoc9x1G0vZUCoAaMagyoaIfu92PMGeoWU8oZ+hXq2m2u3W73hhtCxFQy4Gw2ENuKClr2gRioYDE0FCft/uzZDv8lVqyzvat1zvjiHFRYTTTS1KU2CTiG3lK2RhpwGigoV7J3u7wrllh/NWec6QspQE3GRaY3apS4lb0R1bLhLji20jFbatkDgGNTUUNc/cNlqZmPLOWcjbw7fmWffpLzMotJRhEYYa7VTyg24sq0AgJ0YmoFCzo92nd09dfUDO92Au+KeMNNvDTJeMgHZ7PYD+1tbWjCgoV/Lnu2OS5mcP5uzZCy9ZcnzhbJFzKNtDrqkocSvnrbDaChxGs44nDgoKHnMW5PdfaLDc7pb97tsuU+FFdkRbc2lnbkOtpKktJ2XlHFZGyMBSooD7KOSss5gtJn3fNsayTA8przF8IKthIBC+ctPSxrcsWITjWUlE8nNzr1mfDC07iprRL3ndTbY9gm33L2aI17btxSZbTSEgBClAHBSVK5wBxwOurbmEuByjLioa+PzmUr0bd204OWolJ25zLFqcbYuueI8GQ42l1LUhtDailXCAXNWNZywIR7U0nuNe1z29dTduy5JOlUyNf3NyE5otdkjXlmRbLpFcnNXII0hpnDa5gJCidpOzgrA41g8B+8UU9DVS6PPofDyuSi1KDo49Zav/wA8wdf8xvYHUfNk/frZ8qXteo83/a/8frMH3eYWySMxug8BMZOGPd59R5V+r1D/AGv/AB+sCN9tD9hvE+yylpcfgPqYW430VbJ0KGPGNNeXcg4ScXsOrx7yvW4zjqki3WT2cjd851zWOwz2jJ7pGsCxGka6Ek5aPCJ5RWSK5A8lekP+MX1jQkPm++SH91m5xo6extS0/wC4j/NUGRj3VJIiZwzGoaNrL8hPxuIqGCF92d8Rt8tpeGA2Wp2nlZWKEl13ny+13BxmCccM6XNzDllzPnoiAf8Au3PCNvjy68NGyJXyx1ijB5sjwHvEsSNHteteP/m1GgD/AHXzLOLO+XIDd3hW69XW+RpbQnOBCeyTHjHbw1kYtFPNxwNESAvMnu85jsFguGYIt6tF4ZtbZkS40BxZdSynSpQ2k7J2Rpwx1aqVIKRlnIdxzPCduLUqNCgtOdkHpRI2lgAkDAcGPDW5Yw5XVxVSSPLzua28WSg1KUmtSL5GtbeScj5it8y5xJLl1U0GEx1YkqBCQnA6SeGt1WlYsSTkm5U1HiTyJZubanCElG3WtSv76HzIzJCWrSRbWh8SlVRzTxF3Ub38aTWPKvtsJNtmqF5yYcfB2B9A+FLNelbS47fcOdyLcnZyF/mX1mjMN4uWTswHNiHHpWXbkER7xC2irsXEjZbdaBOAxw/tjWORJ2LnvFphLX1GeDjxzsb4eSUbsNMJdK6GOsmSbzcZUvOV4dcbXdEBq227aPZsQ0nFJ2dW0rj+erMNSm3dn+bUuoq5soWoRxrS7Hal0yAhn9wu50vrh+lLUfkFeJmeNLednylUxLa/STNk9nI3fOdc1r7Dd2jJ7pGsC1Gka6Ek1afCp5RWSK5A+k+kP+MX1jUEhi3syg7u93YNE+Ctyh/umaEmPd2lCNme+LB6VlfT8a01DJoRW4WQI+9G2u46m5fytKoSWrP8wObnI7GOrNU9fxyZJ/voQU3cW+GN6FjdB6Ikau6wujCPFpfA33Mv4/8A2Za//UmgGe+J1L+8zMrqiOdJQdPiUCiBbN0EkMZG3nNg+FtaRo8W9QFTiv4brZkfHQZyTh+kivSj8o+8eLcj/wDRi/0FGbw7VvDDpp/KK89az2JamXfeg/298jKJ1QW0/rKr0OZeIu6jyORw4bL7zLxCmkXPLJx8HZ3UY8oar0IP8dvunjXrT91e/wDIjXdmJmZr2mHckKbyzbgHNjHDzt5Q0aR9FP8AbXS7bleu0kqW4+snGlHFscUHW9P/AKo35ZXdLG9KsT22/Z2f21rmKPRQo6WT3U41lixnbk4Ps7H9RhzCNvIhG6tFx9pfWCnN6+0zPd3PrSVH5BXi5fjS3nT8vVMeC/SWGy+zkbvnOuao2GztGLx5xrBliNYoSStscCXE8tSiuRQ5PpD2P+IvrGhIQrNvdvFqs8OzSbZAubMBHZRnZaCVpbGpJ1jQNGNQZVPCt7N3Rf4t/hWyBCcYjLhPRWUENPNOK2zt4YHEEDAilBUk077rqyVOQ7Dao0nAhD7aFBSSeHRhjShJE5f3rXux25y1vwod1jLkOSkeeIJKXHlFa9Wg4qJOrRQip6uG9a6yp9quUK12+2y7S8t5tUdsgOBxGwpC9WKSmgqSv9brkHe3Tl61CRjtB7ZVt7XHtdLH4aCpE2rerc4D1zlS7Vb7nLukozX3pLelKikICEa8EAJGFAbrvvevFztEy0RbXAtjU9BZkvRUELLZ0EDUNI0Y0oSVSzZmmWeK5CQy1IirX2gbeBwCuHVyVt2MqVqPDSqNLIw43ZcTbT6hzMze9MiuxTborYdTslxCecNOOI0VnPNclThSMLWAoSUuKToOVZ7luYFy3RXCAAFLBUcBy1n5i3rimVLlkVqlJDN7OF0cuUe4pS02YyFNNsJB2NhfSB4dOFVvNnxqXQXR5fbVtw11JD+oVz/CsfGv56u8zn0Gv5Ra6WY/qFc+CKxjwaV/PTzOfQPKLXSyqSpT02S9LkHaffWVuEaBia0JycpNvWz0oQUIqK1IuNnXhYI6fznOuaxeobRs6cVGsSxGuhJvZeLZBoYtGHIlokuqefYPaK0qKFFIJ48BU1IozItuX+GOvyqqnQNJn1bl78O55VVNA0i9W5e/Dr8qqo0DSL1bl38OvyqqaBpF6ty9+Hc8qqmgaRercu/hnPKqpoGkXqzLv4ZflVU0DSL1Zl78O55VVToGkXqzLv4dflVVGgaRercvfh3PKqpoFGL1bl38O55VVToGkXq3L34dzyqqaBpF6ty9+HX5VVRoGkx6ty9+Hc8qqmgaTCrZYfosL+FxVBRm9x9sIS0ykIaQNlCE6AAKE0GajiagkxQkVAKgFQCoBUAqAVAKgFQCoBUAqAVAKgFQCoBUAqAVAf/Z";
        this._logo.width = 160;
        this._logo.height = 200;
    },

    /**
     * Draw loading screen
     */
    draw:function () {
        var logoWidth = (cc.canvas.width - this._logo.width) / 2;
        var logoHeight = (cc.canvas.height - this._logo.height) / 2;
        cc.renderContext.clearRect(0, -cc.canvas.height, cc.canvas.width, cc.canvas.height);
        cc.renderContext.fillStyle = "#202020";
        cc.renderContext.fillRect(0, -cc.canvas.height, cc.canvas.width, cc.canvas.height);
        cc.drawingUtil.drawImage(this._logo, new cc.PointMake(logoWidth, logoHeight));
        cc.renderContext.fillStyle = "#b2b4b3";
        cc.renderContext.font = 'Bold 12px Verdana';
        cc.renderContext.textAlign = 'left';
        cc.drawingUtil.fillText("Loading " + cc.Loader.shareLoader().getProgressBar() + "%", logoWidth + 30, logoHeight - 15);
    }
});

/**
 * Shared loader scene
 * @return {cc.LoaderScene}
 */
cc.LoaderScene.shareLoaderScene = function () {
    if (!cc.shareLoaderScene) {
        cc.shareLoaderScene = new cc.LoaderScene();
    }
    return cc.shareLoaderScene;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *   Drawing primitives Utility Class. this class is base class, it contain some render type version: Canvas, WebGL, DOM.<br/>
 *   this class contain some primitive Drawing Method: <br/>
 *     - drawPoint<br/>
 *     - drawLine<br/>
 *     - drawPoly<br/>
 *     - drawCircle<br/>
 *     - drawQuadBezier<br/>
 *     - drawCubicBezier<br/>
 *     You can change the color, width and other property by calling these WebGL API:<br/>
 *     glColor4ub(), glLineWidth(), glPointSize().<br/>
 * </p>
 * @class
 * @extends cc.Class
 * @warning These functions draws the Line, Point, Polygon, immediately. They aren't batched. <br/>
 *   If you are going to make a game that depends on these primitives, I suggest creating a batch.
 */
cc.DrawingPrimitive = cc.Class.extend(/** @lends cc.DrawingPrimitive# */{
    _renderContext:null,

    /**
     * set render context of drawing primitive
     * @param context
     */
    setRenderContext:function (context) {
        this._renderContext = context;
    },

    /**
     * returns render context of drawing primitive
     * @return {CanvasContext}
     */
    getRenderContext:function () {
        return this._renderContext;
    },

    /**
     * Constructor
     * @param {CanvasContext} renderContext
     */
    ctor:function (renderContext) {
        this._renderContext = renderContext;
    },

    /**
     * draws a point given x and y coordinate measured in points
     * @param {cc.Point} point
     */
    drawPoint:function (point) {
        cc.log("DrawingPrimitive.drawPoint() not implement!");
    },

    /**
     * draws an array of points.
     * @param {Array} points point of array
     * @param {Number} numberOfPoints
     */
    drawPoints:function (points, numberOfPoints) {
        cc.log("DrawingPrimitive.drawPoints() not implement!");
    },

    /**
     * draws a line given the origin and destination point measured in points
     * @param {cc.Point} origin
     * @param {cc.Point} destination
     */
    drawLine:function (origin, destination) {
        cc.log("DrawingPrimitive.drawLine() not implement!");
    },

    /**
     * draws a poligon given a pointer to cc.Point coordiantes and the number of vertices measured in points.
     * @param {Array} vertices a pointer to cc.Point coordiantes
     * @param {Number} numOfVertices the number of vertices measured in points
     * @param {Boolean} closePolygon The polygon can be closed or open
     * @param {Boolean} fill The polygon can be closed or open and optionally filled with current color
     */
    drawPoly:function (vertices, numOfVertices, closePolygon, fill) {
        cc.log("DrawingPrimitive.drawPoly() not implement!");
    },

    /**
     * draws a circle given the center, radius and number of segments.
     * @param {cc.Point} center center of circle
     * @param {Number} radius
     * @param {Number} angle angle in radians
     * @param {Number} segments
     * @param {Boolean} drawLineToCenter
     */
    drawCircle:function (center, radius, angle, segments, drawLineToCenter) {
        //WEBGL version
        if ((segments == "undefined") || (segments == 0)) {
            return;
        }
        var additionalSegment = 1;
        if (drawLineToCenter) {
            ++additionalSegment;
        }

        var coef = 2.0 * Math.PI / segments;

        var vertices = [];

        for (var i = 0; i <= segments; i++) {
            var rads = i * coef;
            var j = radius * Math.cos(rads + angle) + center.x;
            var k = radius * Math.sin(rads + angle) + center.y;
            var addPoint = new cc.Point(j * cc.CONTENT_SCALE_FACTOR(), k * cc.CONTENT_SCALE_FACTOR());
            vertices.push(addPoint);
        }

        if (drawLineToCenter) {
            var lastPoint = new cc.Point(center.x * cc.CONTENT_SCALE_FACTOR(), center.y * cc.CONTENT_SCALE_FACTOR());
            vertices.push(lastPoint);
        }

        this.drawPoly(vertices, segments + 2, true, false);
    },

    /**
     * draws a quad bezier path
     * @param {cc.Point} origin
     * @param {cc.Point} control
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawQuadBezier:function (origin, control, destination, segments) {
        cc.log("DrawingPrimitive.drawQuadBezier() not implement!");
    },

    /**
     * draws a cubic bezier path
     * @param {cc.Point} origin
     * @param {cc.Point} control1
     * @param {cc.Point} control2
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawCubicBezier:function (origin, control1, control2, destination, segments) {
        cc.log("DrawingPrimitive.drawCubicBezier() not implement!");
    }
});

/**
 * Canvas of DrawingPrimitive implement version
 * @class
 * @extends cc.DrawingPrimitive
 */
cc.DrawingPrimitiveCanvas = cc.DrawingPrimitive.extend(/** @lends cc.DrawingPrimitiveCanvas# */{
    /**
     * draws a point given x and y coordinate measured in points
     * @override
     * @param {cc.Point} point
     */
    drawPoint:function (point, size) {
        if (!size) {
            size = 1;
        }
        var newPoint = new cc.Point(point.x * cc.CONTENT_SCALE_FACTOR(), point.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.beginPath();
        this._renderContext.arc(newPoint.x, -newPoint.y, size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false);
        this._renderContext.closePath();
        this._renderContext.fill();
    },

    /**
     * draws an array of points.
     * @override
     * @param {Array} points point of array
     * @param {Number} numberOfPoints
     */
    drawPoints:function (points, numberOfPoints, size) {
        if (points == null) {
            return;
        }
        if (!size) {
            size = 1;
        }

        this._renderContext.beginPath();
        for (var i = 0; i < points.length; i++) {
            this._renderContext.arc(points[i].x * cc.CONTENT_SCALE_FACTOR(), -points[i].y * cc.CONTENT_SCALE_FACTOR(),
                size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false);
        }
        this._renderContext.closePath();
        this._renderContext.fill();
    },

    /**
     * draws a line given the origin and destination point measured in points
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} destination
     */
    drawLine:function (origin, destination) {
        this._renderContext.beginPath();
        this._renderContext.moveTo(origin.x * cc.CONTENT_SCALE_FACTOR(), -origin.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.lineTo(destination.x * cc.CONTENT_SCALE_FACTOR(), -destination.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.closePath();
        this._renderContext.stroke();
    },

    /**
     * draws a poligon given a pointer to cc.Point coordiantes and the number of vertices measured in points.
     * @override
     * @param {Array} vertices a pointer to cc.Point coordiantes
     * @param {Number} numOfVertices the number of vertices measured in points
     * @param {Boolean} closePolygon The polygon can be closed or open
     * @param {Boolean} fill The polygon can be closed or open and optionally filled with current color
     */
    drawPoly:function (vertices, numOfVertices, closePolygon, fill) {
        if (fill == 'undefined') {
            fill = false;
        }

        if (vertices == null) {
            return;
        }
        if (vertices.length < 3) {
            throw new Error("Polygon's point must greater than 2");
        }

        var firstPoint = vertices[0];
        this._renderContext.beginPath();
        this._renderContext.moveTo(firstPoint.x * cc.CONTENT_SCALE_FACTOR(), -firstPoint.y * cc.CONTENT_SCALE_FACTOR());
        for (var i = 1; i < vertices.length; i++) {
            this._renderContext.lineTo(vertices[i].x * cc.CONTENT_SCALE_FACTOR(), -vertices[i].y * cc.CONTENT_SCALE_FACTOR());
        }
        if (closePolygon) {
            this._renderContext.closePath();
        }

        if (fill) {
            this._renderContext.fill();
        } else {
            this._renderContext.stroke();
        }
    },

    /**
     * draws a circle given the center, radius and number of segments.
     * @override
     * @param {cc.Point} center center of circle
     * @param {Number} radius
     * @param {Number} angle angle in radians
     * @param {Number} segments
     * @param {Boolean} drawLineToCenter
     */
    drawCircle:function (center, radius, angle, segments, drawLineToCenter) {
        this._renderContext.beginPath();
        var endAngle = angle - Math.PI * 2;
        this._renderContext.arc(0 | center.x, 0 | -(center.y), radius, -angle, -endAngle, false);
        if (drawLineToCenter) {
            this._renderContext.lineTo(0 | center.x, 0 | -(center.y));
        }
        this._renderContext.stroke();
    },

    /**
     * draws a quad bezier path
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} control
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawQuadBezier:function (origin, control, destination, segments) {
        //this is OpenGL Algorithm
        var vertices = [];

        var t = 0.0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 2) * origin.x + 2.0 * (1 - t) * t * control.x + t * t * destination.x;
            var y = Math.pow(1 - t, 2) * origin.y + 2.0 * (1 - t) * t * control.y + t * t * destination.y;
            vertices.push(new cc.Point(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
            t += 1.0 / segments;
        }
        vertices.push(new cc.Point(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));

        this.drawPoly(vertices, segments + 1, false, false);
    },

    /**
     * draws a cubic bezier path
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} control1
     * @param {cc.Point} control2
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawCubicBezier:function (origin, control1, control2, destination, segments) {
        //this is OpenGL Algorithm
        var vertices = [];

        var t = 0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 3) * origin.x + 3.0 * Math.pow(1 - t, 2) * t * control1.x + 3.0 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
            var y = Math.pow(1 - t, 3) * origin.y + 3.0 * Math.pow(1 - t, 2) * t * control1.y + 3.0 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
            vertices.push(new cc.Point(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
            t += 1.0 / segments;
        }
        vertices.push(new cc.Point(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));

        this.drawPoly(vertices, segments + 1, false, false);
    },

    /**
     * draw an image
     * @override
     * @param {HTMLImageElement|HTMLCanvasElement} image
     * @param {cc.Point} sourcePoint
     * @param {cc.Size} sourceSize
     * @param {cc.Point} destPoint
     * @param {cc.Size} destSize
     */
    drawImage:function (image, sourcePoint, sourceSize, destPoint, destSize) {
        var len = arguments.length;
        switch (len) {
            case 2:
                var height = image.height;
                this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
                break;
            case 3:
                this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
                break;
            case 5:
                this._renderContext.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height),
                    destSize.width, destSize.height);
                break;
            default:
                throw new Error("Argument must be non-nil");
                break;
        }
    },

    /**
     * draw a star
     * @param {CanvasContext} ctx canvas context
     * @param {cc.Point} center
     * @param {Number} radius
     * @param {cc.Color3B|cc.Color4B|cc.Color4F} color
     */
    drawStar:function (ctx, center, radius, color) {
        var context = ctx || this._renderContext;
        context.save();
        context.translate(center.x, -center.y);
        context.rotate(cc.DEGREES_TO_RADIANS(45));
        if (color instanceof cc.Color4F) {
            color = new cc.Color3B(0 | (color.r * 255), 0 | (color.g * 255), 0 | (color.b * 255));
        }
        var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
        context.fillStyle = colorStr + ",1)";

        var subRadius = radius / 10;

        context.beginPath();
        context.moveTo(-radius, 0);
        context.lineTo(0, -subRadius);
        context.lineTo(radius, 0);
        context.lineTo(0, subRadius);
        context.lineTo(-radius, 0);
        context.closePath();
        context.fill();

        context.beginPath();
        context.moveTo(0, -radius);
        context.lineTo(-subRadius, 0);
        context.lineTo(0, radius);
        context.lineTo(subRadius, 0);
        context.lineTo(0, -radius);
        context.closePath();
        context.fill();

        var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(0.3, colorStr + ", 0.8)");
        //g1.addColorStop(0.6, colorStr + ", 0.4)");
        g1.addColorStop(1.0, colorStr + ", 0.0)");
        context.fillStyle = g1;
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = Math.PI * 2;
        context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();

        context.restore();
    },

    /**
     * draw a color ball
     * @param {CanvasContext} ctx canvas context
     * @param {cc.Point} center
     * @param {Number} radius
     * @param {cc.Color3B|cc.Color4B|cc.Color4F} color
     */
    drawColorBall:function (ctx, center, radius, color) {
        var context = ctx || this._renderContext;
        if (color instanceof cc.Color4F) {
            color = new cc.Color3B(0 | (color.r * 255), 0 | (color.g * 255), 0 | (color.b * 255));
        }
        var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
        var subRadius = radius / 10;

        var g1 = context.createRadialGradient(center.x, -center.y, subRadius, center.x, -center.y, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(0.3, colorStr + ", 0.8)");
        g1.addColorStop(0.6, colorStr + ", 0.4)");
        g1.addColorStop(1.0, colorStr + ", 0.0)");
        context.fillStyle = g1;
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = Math.PI * 2;
        context.arc(center.x, -center.y, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
    },

    /**
     * fill text
     * @param {String} strText
     * @param {Number} x
     * @param {Number} y
     */
    fillText:function (strText, x, y) {
        this._renderContext.fillText(strText, x, -y);
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * Device oriented vertically, home button on the bottom
 * @constant
 * @type Number
 */
cc.ORIENTATION_PORTRAIT = 0;

/**
 * Device oriented vertically, home button on the top
 * @constant
 * @type Number
 */
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;

/**
 * Device oriented horizontally, home button on the right
 * @constant
 * @type Number
 */
cc.ORIENTATION_LANDSCAPE_LEFT = 2;

/**
 * Device oriented horizontally, home button on the left
 * @constant
 * @type Number
 */
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;

//engine render type

/**
 * Canvas of render type
 * @constant
 * @type Number
 */
cc.CANVAS = 0;

/**
 * WebGL of render type
 * @constant
 * @type Number
 */
cc.WEBGL = 1;

/**
 * drawing primitive of game engine
 * @type cc.DrawingPrimitive
 */
cc.drawingUtil = null;

/**
 * main Canvas 2D Context of game engine
 * @type CanvasContext
 */
cc.renderContext = null;

/**
 * main Canvas of game engine
 * @type HTMLCanvasElement
 */
cc.canvas = null;

/**
 * This Div element contain all game canvas
 * @type HTMLDivElement
 */
cc.gameDiv = null;

/**
 * current render type of game engine
 * @type Number
 */
cc.renderContextType = cc.CANVAS;

/**
 * save original size of canvas, use for resize canvas
 * @type cc.Size
 */
cc.originalCanvasSize = new cc.Size(0, 0);

window.requestAnimFrame = (function () {
    return  window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame
})();


if (!window.console) {
    window.console = {};
    window.console.log = function () {
    };
    window.console.assert = function () {
    };
}

/**
 * <p>
 *   setup game main canvas,renderContext,gameDiv and drawingUtil with argument  <br/>
 *   <br/>
 *   can receive follow type of arguemnt: <br/>
 *      - empty: create a canvas append to document's body, and setup other option    <br/>
 *      - string: search the element by document.getElementById(),    <br/>
 *          if this element is HTMLCanvasElement, set this element as main canvas of engine, and set it's ParentNode as cc.gameDiv.<br/>
 *          if this element is HTMLDivElement, set it's ParentNode to cc.gameDiv， and create a canvas as main canvas of engine.   <br/>
 * </p>
 * @function
 * @example
 * //setup with null
 * cc.setup();
 *
 * // setup with HTMLCanvasElement, gameCanvas is Canvas element
 * // declare like this: <canvas id="gameCanvas" width="800" height="450"></canvas>
 * cc.setup("gameCanvas");
 *
 * //setup with HTMLDivElement, gameDiv is Div element
 * // declare like this: <div id="Cocos2dGameContainer" width="800" height="450"></div>
 * cc.setup("Cocos2dGameContainer");
 */
cc.setup = function () {
    //Browser Support Information
    //event register
    var gameCanvas;
    switch (arguments.length) {
        case 0:
            //add canvas at document
            gameCanvas = document.createElement("Canvas");
            gameCanvas.setAttribute("id", "gameCanvas");
            gameCanvas.setAttribute("width", 480);
            gameCanvas.setAttribute("height", 320);
            document.body.appendChild(gameCanvas);
            cc.canvas = gameCanvas;
            cc.renderContext = cc.canvas.getContext("2d");
            cc.gameDiv = document.body;
            cc.renderContextType = cc.CANVAS;
            //document
            break;
        case 1:
            var name = arguments[0];
            var getElement = null;
            if (typeof(name) == "string") {
                getElement = document.getElementById(name);
            } else {
                getElement = arguments[0];
            }

            if (getElement instanceof HTMLCanvasElement) {
                //HTMLCanvasElement
                cc.canvas = getElement;
                cc.gameDiv = getElement.parentNode;
                cc.renderContext = cc.canvas.getContext("2d");
                cc.renderContextType = cc.CANVAS;
            } else if (getElement instanceof HTMLDivElement) {
                //HTMLDivElement
                gameCanvas = document.createElement("Canvas");
                gameCanvas.setAttribute("id", "gameCanvas");
                gameCanvas.setAttribute("width", getElement.width);
                gameCanvas.setAttribute("height", getElement.height);
                getElement.appendChild(gameCanvas);
                cc.canvas = gameCanvas;
                cc.renderContext = cc.canvas.getContext("2d");
                cc.gameDiv = getElement;
                cc.renderContextType = cc.CANVAS;
            }
            break;
        case 2:
            break;
        case 3:
            break;
    }

    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.translate(0, cc.canvas.height);
        cc.drawingUtil = new cc.DrawingPrimitiveCanvas(cc.renderContext);
    }
    cc.originalCanvasSize = new cc.Size(cc.canvas.width, cc.canvas.height);

    console.log(cc.ENGINE_VERSION);

    //binding window size
    /*
     cc.canvas.addEventListener("resize", function () {
     if (!cc.firstRun) {
     cc.Director.sharedDirector().addRegionToDirtyRegion(new cc.Rect(0, 0, cc.canvas.width, cc.canvas.height));
     }
     }, true);
     */
};

/**
 * setup css style of game div
 * @param {cc.Node} obj
 */
cc.setupHTML = function (obj) {
    var canvas = cc.canvas;

    canvas.style.zIndex = 0;
    var _container = document.createElement("div");//cc.$new("div");
    _container.id = "Cocos2dGameContainer";
    _container.style.position = "relative";
    _container.style.display = "inline-block";

    if (obj) {
        _container.setAttribute("height", obj.getContentSize().height);
    }
    canvas.parentNode.insertBefore(_container, canvas);
    _container.appendChild(canvas);
};

/**
 * Run main loop of game engine
 * @class
 * @extends cc.Class
 */
cc.Application = cc.Class.extend(/** @lends cc.Application# */{
    /**
     * Constructor
     */
    ctor:function () {
        this._animationInterval = 0;
        cc.Assert(!cc._sharedApplication, "CCApplication ctor");
        cc._sharedApplication = this;
    },

    /**
     * Callback by cc.Director for limit FPS.
     * @param {Number} interval The time, which expressed in second, between current frame and next.
     */
    setAnimationInterval:function (interval) {
        this._animationInterval = interval;
    },

    /**
     * Callback by cc.Director for change device orientation.
     * @param {Number} orientation The defination of orientation which cc.Director want change to.
     * @return {Number} The actual orientation of the application.
     * @deprecated Does not require in html5
     */
    setOrientation:function (orientation) {
        // swap width and height
        // TODO, need to be fixed.
        /* var pView = cc.Director.sharedDirector().getOpenGLView();
         if (pView)
         {
         return pView.setDeviceOrientation(orientation);
         }
         return cc.Director.sharedDirector().getDeviceOrientation(); */
        return orientation;

    },

    /**
     *  Get status bar rectangle in EGLView window.
     * @param {cc.Rect} rect
     * @deprecated
     */
    statusBarFrame:function (rect) {
        if (rect) {
            // Windows doesn't have status bar.
            rect = cc.RectMake(0, 0, 0, 0);
        }
    },

    /**
     * Run the message loop.
     * @return {Number}
     */
    run:function () {
        // Initialize instance and cocos2d.
        if (!this.initInstance() || !this.applicationDidFinishLaunching()) {
            return 0;
        }
        // TODO, need to be fixed.
        if (window.requestAnimFrame) {
            var callback = function () {
                cc.Director.sharedDirector().mainLoop();
                window.requestAnimFrame(callback);
            };
            cc.Log(window.requestAnimFrame);
            window.requestAnimFrame(callback);
        }
        else {
            var callback = function () {
                cc.Director.sharedDirector().mainLoop();
            };
            setInterval(callback, this._animationInterval * 1000);
        }

    },
    _animationInterval:null
});

/**
 * Get current applicaiton instance.
 * @return {cc.Application}  Current application instance pointer.
 */
cc.Application.sharedApplication = function () {

    cc.Assert(cc._sharedApplication, "sharedApplication");
    return cc._sharedApplication;
};

/**
 * Get current language config
 * @return {Number} Current language config
 */
cc.Application.getCurrentLanguage = function () {
    var ret = cc.LANGUAGE_ENGLISH;

    var currentLang = navigator.language;
    currentLang = currentLang.toLowerCase();
    switch (currentLang) {
        case "zh-cn":
            ret = cc.LANGUAGE_CHINESE;
            break;
        case "fr":
            ret = cc.LANGUAGE_FRENCH;
            break;
        case "it":
            ret = cc.LANGUAGE_ITALIAN;
            break;
        case "de":
            ret = cc.LANGUAGE_GERMAN;
            break;
        case "es":
            ret = cc.LANGUAGE_SPANISH;
            break;
        case "ru":
            ret = cc.LANGUAGE_RUSSIAN;
            break;
    }

    return ret;
};

cc._sharedApplication = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * a SAX Parser
 * @class
 * @extends cc.Class
 */
cc.SAXParser = cc.Class.extend(/** @lends cc.SAXParser# */{
    xmlDoc:null,
    parser:null,
    xmlList:[],
    plist:[],

    /**
     * parse a xml from a string (xmlhttpObj.responseText)
     * @param {String} textxml plist xml contents
     * @return {Array} plist object array
     */
    parse:function (textxml) {
        var textxml = this.getList(textxml);
        // get a reference to the requested corresponding xml file
        if (window.DOMParser) {
            this.parser = new DOMParser();
            this.xmlDoc = this.parser.parseFromString(textxml, "text/xml");
        } else // Internet Explorer (untested!)
        {
            this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmlDoc.async = "false";
            this.xmlDoc.loadXML(textxml);
        }
        if (this.xmlDoc == null) {
            cc.Log("xml " + this.xmlDoc + " not found!");
        }
        var plist = this.xmlDoc.documentElement;
        if (plist.tagName != 'plist') {
            throw "Not a plist file"
        }
        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == 1) {
                break
            }
        }
        this.plist = this._parseNode(node);
        return this.plist;
    },

    /**
     * parse a tilemap xml from a string (xmlhttpObj.responseText)
     * @param  {String} textxml  tilemap xml content
     * @return {Document} xml document
     */
    tmxParse:function (textxml) {
        var textxml = this.getList(textxml);
        // get a reference to the requested corresponding xml file
        if (window.DOMParser) {
            this.parser = new DOMParser();
            this.xmlDoc = this.parser.parseFromString(textxml, "text/xml");
        } else // Internet Explorer (untested!)
        {
            this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmlDoc.async = "false";
            this.xmlDoc.loadXML(textxml);
        }
        if (this.xmlDoc == null) {
            cc.Log("xml " + this.xmlDoc + " not found!");
        }
        return this.xmlDoc;
    },

    _parseNode:function (node) {
        var data = null;
        switch (node.tagName) {
            case 'dict':
                data = this._parseDict(node);
                break;
            case 'array':
                data = this._parseArray(node);
                break;
            case 'string':
                // FIXME - This needs to handle Firefox's 4KB nodeValue limit
                data = node.firstChild.nodeValue;
                break;
            case 'false':
                data = false;
                break;
            case 'true':
                data = true;
                break;
            case 'real':
                data = parseFloat(node.firstChild.nodeValue);
                break;
            case 'integer':
                data = parseInt(node.firstChild.nodeValue, 10);
                break;
        }

        return data;
    },

    _parseArray:function (node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1) {
                continue;
            }
            data.push(this._parseNode(child));
        }
        return data;
    },

    _parseDict:function (node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this._parseNode(child);
            }
        }
        return data;
    },

    /**
     * Preload plist file
     * @param {String} filePath
     */
    preloadPlist:function (filePath) {
        if (window.XMLHttpRequest) {
            // for IE7+, Firefox, Chrome, Opera, Safari brower
            var xmlhttp = new XMLHttpRequest();
            // is xml file?
            if (xmlhttp.overrideMimeType)
                xmlhttp.overrideMimeType('text/xml');
        } else {
            // for IE6, IE5 brower
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        if (xmlhttp != null) {
            // load xml
            xmlhttp.open("GET", filePath, false);
            xmlhttp.send(null);
            this.xmlList[filePath] = xmlhttp.responseText;
            cc.Loader.shareLoader().onResLoaded();
        } else {
            alert("Your browser does not support XMLHTTP.");
        }
    },

    /**
     * get filename from filepath
     * @param {String} filePath
     * @return {String}
     */
    getName:function (filePath) {
        var startPos = filePath.lastIndexOf("/", filePath.length) + 1;
        var endPos = filePath.lastIndexOf(".", filePath.length);
        return filePath.substring(startPos, endPos);
    },

    /**
     * get file extension name from filepath
     * @param {String} filePath
     * @return {String}
     */
    getExt:function (filePath) {
        var startPos = filePath.lastIndexOf(".", filePath.length) + 1;
        return filePath.substring(startPos, filePath.length);
    },

    /**
     * get value by key from xmlList
     * @param {String} key
     * @return {String} xml content
     */
    getList:function (key) {
        if (this.xmlList != null) {
            return this.xmlList[key];
        } else {
            return null;
        }
    }
});

/**
 * get a singleton SAX parser
 * @function
 * @return {cc.SAXParser}
 */
cc.SAXParser.shareParser = function () {
    if (!cc.shareParser) {
        cc.shareParser = new cc.SAXParser();
    }
    return cc.shareParser;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Controller of Game Application
 * @class
 * @extends cc.Class
 */
cc.AppController = cc.Class.extend(/** @lends cc.AppController# */{
    /**
     * did something when Finish Launching
     * @return {Boolean}
     */
    didFinishLaunchingWithOptions:function () {
        // Override point for customization after application launch.
        var app = new cc.AppDelegate();
        cc.Application.sharedApplication().run();

        return true;
    },

    /**
     * <p>
     *  Sent when the application is about to move from active to inactive state. <br/>
     *  This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) <br/>
     *  or when the user quits the application and it begins the transition to the background state.     <br/>
     *  Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. <br/>
     *  Games should use this method to pause the game.
     * </p>
     */
    applicationWillResignActive:function () {
        cc.Director.sharedDirector().pause();
    },

    /**
     * <p>
     * Restart any tasks that were paused (or not yet started) while the application was inactive. <br/>
     * If the application was previously in the background, optionally refresh the user interface.
     * </p>
     */
    applicationDidBecomeActive:function () {
        cc.Director.sharedDirector().resume();
    },

    /**
     * <p>
     *   Use this method to release shared resources, save user data, invalidate timers, and store enough application state information <br/>
     *   to restore your application to its current state in case it is terminated later.<br/>
     *   If your application supports background execution, called instead of applicationWillTerminate: when the user quits.
     * </p>
     */
    applicationDidEnterBackground:function () {
        cc.Application.sharedApplication().applicationDidEnterBackground();
    },

    /**
     * <p>
     *     Called as part of  transition from the background to the inactive state: <br/>
     *      here you can undo many of the changes made on entering the background.
     * </p>
     */
    applicationWillEnterForeground:function () {
        cc.Application.sharedApplication().applicationWillEnterForeground();
    },

    /**
     * Called when the application is about to terminate. See also applicationDidEnterBackground.
     */
    applicationWillTerminate:function () {
    }
});

/**
 * Return Controller of Game Application
 * @return {cc.AppController}
 */
cc.AppController.shareAppController = function () {
    if (cc.sharedAppController == null) {
        cc.sharedAppController = new cc.AppController();
    }
    cc.Assert(cc.sharedAppController, "shareAppController");
    return cc.sharedAppController;
};

/**
 * cocos2d application instance
 * @type cc.AppController
 */
cc.sharedAppController = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * default size for font size
 * @constant
 * @type Number
 */
cc.CCITEM_SIZE = 32;

cc._fontSize = cc.CCITEM_SIZE;
cc._fontName = "Marker Felt";
cc._fontNameRelease = false;

/**
 * default tag for current item
 * @constant
 * @type Number
 */
cc.CURRENT_ITEM = 0xc0c05001;
/**
 * default tag for zoom action tag
 * @constant
 * @type Number
 */
cc.ZOOM_ACTION_TAG = 0xc0c05002;
/**
 * default tag for normal
 * @constant
 * @type Number
 */
cc.NORMAL_TAG = 8801;

/**
 * default selected tag
 * @constant
 * @type Number
 */
cc.SELECTED_TAG = 8802;

/**
 * default disabled tag
 * @constant
 * @type Number
 */
cc.DISABLE_TAG = 8803;

/**
 * Subclass cc.MenuItem (or any subclass) to create your custom cc.MenuItem objects.
 * @class
 * @extends cc.Node
 */
cc.MenuItem = cc.Node.extend(/** @lends cc.MenuItem# */{
    _listener:null,
    _selector:null,
    _isSelected:false,

    /**
     * @return {Boolean}
     */
    getIsSelected:function () {
        return this._isSelected;
    },
    _isEnabled:false,

    /**
     * @return {Boolean}
     */
    getIsEnabled:function () {
        return this._isEnabled;
    },

    /**
     *
     * @param enable
     */
    setIsEnabled:function (enable) {
        this._isEnabled = enable;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithTarget:function (rec, selector) {
        this.setAnchorPoint(cc.ccp(0.5, 0.5));
        this._listener = rec;
        this._selector = selector;
        this._isEnabled = true;
        this._isSelected = false;
        return true;
    },

    /**
     * @return {cc.Rect}
     */
    rect:function () {
        return cc.RectMake(this._position.x - this._contentSize.width * this._anchorPoint.x,
            this._position.y - this._contentSize.height * this._anchorPoint.y,
            this._contentSize.width, this._contentSize.height);
    },

    /**
     * same as setIsSelected(true)
     */
    selected:function () {
        this._isSelected = true;
    },

    /**
     * same as setIsSelected(false)
     */
    unselected:function () {
        this._isSelected = false;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     */
    setTarget:function (rec, selector) {
        this._listener = rec;
        this._selector = selector;
    },

    /**
     * call the selector with target
     */
    activate:function () {
        if (this._isEnabled) {
            if (this._listener && (typeof(this._selector) == "string")) {
                this._listener[this._selector](this);
            } else if (this._listener && (typeof(this._selector) == "function")) {
                this._selector.call(this._listener, this);
            }
        }
    }
});

/**
 * creates an empty menu item with target and callback<br/>
 * Not recommended to use the base class, should use more defined menu item classes
 * @param {cc.Node} rec target
 * @param {function|String} selector callback
 * @return {cc.MenuItem}
 */
cc.MenuItem.create = function (rec, selector) {
    var ret = new cc.MenuItem();
    ret.initWithTarget(rec, selector);
    return ret;
};


/**
 *  Any cc.Node that supports the cc.LabelProtocol protocol can be added.<br/>
 * Supported nodes:<br/>
 * - cc.BitmapFontAtlas<br/>
 * - cc.LabelAtlas<br/>
 * - cc.LabelTTF<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemLabel = cc.MenuItem.extend(/** @lends cc.MenuItemLabel# */{

    /**
     * this identifies that this object have implemented RGBAProtocol
     * @type Boolean
     */
    RGBAProtocol:true,
    _disabledColor:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getDisabledColor:function () {
        return this._disabledColor;
    },

    /**
     * @param {cc.Color3B} color
     */
    setDisabledColor:function (color) {
        this._disabledColor = color;
    },
    _label:null,

    /**
     * @return {String}
     */
    getLabel:function () {
        return this._label;
    },

    /**
     * @param {String} label
     */
    setLabel:function (label) {
        if (label) {
            this.addChild(label);
            label.setAnchorPoint(cc.ccp(0, 0));
            this.setContentSize(label.getContentSize());
        }

        if (this._label) {
            this.removeChild(this._label, true);
        }

        this._label = label;
    },
    _orginalScale:0,

    /**
     * @param {Boolean} enabled
     */
    setIsEnabled:function (enabled) {
        if (this._isEnabled != enabled) {
            if (!enabled) {
                this._colorBackup = this._label.getColor();
                this._label.setColor(this._disabledColor);
            }
            else {
                this._label.setColor(this._colorBackup);
            }
        }
        this._super(enabled);
    },

    /**
     * @param {Number} opacity from 0-255
     */
    setOpacity:function (opacity) {
        this._label.setOpacity(opacity);
    },

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._label.getOpacity();
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._label.setColor(color);
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._label.getColor
    },

    setIsOpacityModifyRGB:function (value) {
    },
    getIsOpacityModifyRGB:function () {
    },

    /**
     * @param {String} label
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithLabel:function (label, target, selector) {
        this.initWithTarget(target, selector);
        this._originalScale = 1.0;
        this._colorBackup = cc.WHITE();
        this._disabledColor = cc.ccc3(126, 126, 126);
        this.setLabel(label);
        return true;
    },

    /**
     * activate the menu item
     */
    activate:function () {
        if (this._isEnabled) {
            this.stopAllActions();
            this.setScale(this._originalScale);
            this._super();
        }
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        if (this._isEnabled) {
            this._super();

            var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            if (action) {
                this.stopAction(action);
            }
            else {
                this._originalScale = this.getScale();
            }

            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale * 1.2);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        if (this._isEnabled) {
            this._super();
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    }
});

/**
 * @param {String} label
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemLabel}
 */
cc.MenuItemLabel.create = function (label, target, selector) {
    var ret = new cc.MenuItemLabel();
    if (arguments.length == 3) {
        ret.initWithLabel(label, target, selector);
    } else {
        ret.initWithLabel(label);
    }
    return ret;
};

/**
 * Helper class that creates a MenuItemLabel class with a LabelAtlas
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemAtlasFont# */{

    /**
     * @param {String} value
     * @param {String} charMapFile
     * @param {Number} itemWidth
     * @param {Number} itemHeight
     * @param {String} startCharMap a single character
     * @param {cc.Node|Null} target
     * @param {function|String|Null} selector
     * @return {Boolean}
     */
    initFromString:function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
        cc.Assert(value != null && value.length != 0, "value length must be greater than 0");
        var label = new cc.LabelAtlas();
        label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
        this.initWithLabel(label, target, selector);
        return true;
    }
});

/**
 * create menu item from string with font
 * @param {String} value the text to display
 * @param {String} charMapFile the character map file
 * @param {Number} itemWidth
 * @param {Number} itemHeight
 * @param {String} startCharMap a single character
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemAtlasFont}
 * @example
 * // Example
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ')
 *
 * //OR
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ', game, game.run)
 */
cc.MenuItemAtlasFont.create = function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
    var ret = new cc.MenuItemAtlasFont();
    ret.initFromString(value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector);
    return ret;
};


/**
 * Helper class that creates a CCMenuItemLabel class with a Label
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemFont# */{

    /**
     * @param {String} value text for the menu item
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initFromString:function (value, target, selector) {
        cc.Assert(value != null && value.length != 0, "Value length must be greater than 0");

        this._fontName = cc._fontName;
        this._fontSize = cc._fontSize;

        var label = cc.LabelTTF.create(value, this._fontName, this._fontSize);
        if (this.initWithLabel(label, target, selector)) {
            // do something ?
        }
        return true;
    },

    /**
     * @param {Number} s
     */
    setFontSizeObj:function (s) {
        this._fontSize = s;
        this._recreateLabel();
    },

    /**
     *
     * @return {Number}
     */
    fontSizeObj:function () {
        return this._fontSize;
    },

    /**
     * @param {String} name
     */
    setFontNameObj:function (name) {
        this._fontName = name;
        this._recreateLabel();
    },

    /**
     * @return {String}
     */
    fontNameObj:function () {
        return this._fontName;
    },
    _recreateLabel:function () {
        var label = cc.LabelTTF.create(this._label.getString(),
            this._fontName, this._fontSize);
        this.setLabel(label);
    },
    _fontSize:0,
    _fontName:''
});

/**
 * a shared function to set the fontSize for menuitem font
 * @param {Number} s
 */
cc.MenuItemFont.setFontSize = function (s) {
    cc._fontSize = s;
};

/**
 * a shared function to get the font size for menuitem font
 * @return {Number}
 */
cc.MenuItemFont.fontSize = function () {
    return cc._fontSize;
};

/**
 * a shared function to set the fontsize for menuitem font
 * @param name
 */
cc.MenuItemFont.setFontName = function (name) {
    if (cc._fontNameRelease) {
        cc._fontName = '';
    }
    cc._fontName = name;
    cc._fontNameRelease = true;
};

/**
 * a shared function to get the font name for menuitem font
 * @return {String}
 */
cc.MenuItemFont.fontName = function () {
    return cc._fontName
};

/**
 * create a menu item from string
 * @param {String} value the text to display
 * @param {cc.Node|Null} target the target to run callback
 * @param {String|function|Null} selector the callback to run, either in function name or pass in the actual function
 * @return {cc.MenuItemFont}
 * @example
 * // Example
 * var item = cc.MenuItemFont.create("Game start", Game, 'start')
 * //creates a menu item from string "Game start", and when clicked, it will run Game.start()
 *
 * var item = cc.MenuItemFont.create("Game start", Game, game.start)//same as above
 *
 * var item = cc.MenuItemFont.create("i do nothing")//create a text menu item that does nothing
 *
 * //you can set font size and name before or after
 * cc.MenuItemFont.setFontName('my Fancy Font');
 * cc.MenuItemFont.setFontSize(62);
 */
cc.MenuItemFont.create = function (value, target, selector) {
    var ret = new cc.MenuItemFont();
    ret.initFromString(value, target, selector);
    return ret;
};


/**
 * CCMenuItemSprite accepts CCNode<CCRGBAProtocol> objects as items.<br/>
 The images has 3 different states:<br/>
 - unselected image<br/>
 - selected image<br/>
 - disabled image<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemSprite = cc.MenuItem.extend(/** @lends cc.MenuItemSprite# */{
    /**
     * identifies that this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _normalImage:null,

    /**
     * @return {cc.Sprite}
     */
    getNormalImage:function () {
        return this._normalImage;
    },

    /**
     * @param {cc.Sprite} NormalImage
     */
    setNormalImage:function (NormalImage) {
        if (NormalImage) {
            this.addChild(NormalImage, 0, cc.NORMAL_TAG);
            NormalImage.setAnchorPoint(cc.ccp(0, 0));
            NormalImage.setIsVisible(true);
        }
        if (this._normalImage) {
            this.removeChild(this._normalImage, true);
        }

        this._normalImage = NormalImage;
    },
    _selectedImage:null,

    /**
     * @return {cc.Sprite}
     */
    getSelectedImage:function () {
        return this._selectedImage;
    },

    /**
     * @param {cc.Sprite} SelectedImage
     */
    setSelectedImage:function (SelectedImage) {
        if (SelectedImage) {
            this.addChild(SelectedImage, 0, cc.SELECTED_TAG);
            SelectedImage.setAnchorPoint(cc.ccp(0, 0));
            SelectedImage.setIsVisible(false);
        }

        if (this._selectedImage) {
            this.removeChild(this._selectedImage, true);
        }

        this._selectedImage = SelectedImage;
    },
    _disabledImage:null,

    /**
     * @return {cc.Sprite}
     */
    getDisabledImage:function () {
        return this._disabledImage;
    },

    /**
     * @param {cc.Sprite} DisabledImage
     */
    setDisabledImage:function (DisabledImage) {
        if (DisabledImage) {
            this.addChild(DisabledImage, 0, cc.DISABLE_TAG);
            DisabledImage.setAnchorPoint(cc.ccp(0, 0));
            DisabledImage.setIsVisible(false);
        }

        if (this._disabledImage) {
            this.removeChild(this._disabledImage, true);
        }

        this._disabledImage = DisabledImage;
    },

    /**
     * @param {cc.Sprite} normalSprite
     * @param {cc.Sprite} selectedSprite
     * @param {cc.Sprite} disabledSprite
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initFromNormalSprite:function (normalSprite, selectedSprite, disabledSprite, target, selector) {
        cc.Assert(normalSprite != null, "");
        this.initWithTarget(target, selector);
        this.setNormalImage(normalSprite);
        this.setSelectedImage(selectedSprite);
        this.setDisabledImage(disabledSprite);

        this.setContentSize(this._normalImage.getContentSize());
        return true;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._normalImage.setColor(color);

        if (this._selectedImage) {
            this._selectedImage.setColor(color);
        }

        if (this._disabledImage) {
            this._disabledImage.setColor(color);
        }
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._normalImage.getColor();
    },

    /**
     * @param {Number} opacity 0 - 255
     */
    setOpacity:function (opacity) {
        this._normalImage.setOpacity(opacity);

        if (this._selectedImage) {
            this._selectedImage.setOpacity(opacity);
        }

        if (this._disabledImage) {
            this._disabledImage.setOpacity(opacity);
        }
    },

    /**
     * @return {Number} opacity from 0 - 255
     */
    getOpacity:function () {
        return this._normalImage.getOpacity();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        if (this._disabledImage) {
            this._disabledImage.setIsVisible(false);
        }

        if (this._selectedImage) {
            this._normalImage.setIsVisible(false);
            this._selectedImage.setIsVisible(true);
        }
        else {
            this._normalImage.setIsVisible(true);
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();

        this._normalImage.setIsVisible(true);

        if (this._selectedImage) {
            this._selectedImage.setIsVisible(false);
        }

        if (this._disabledImage) {
            this._disabledImage.setIsVisible(false);
        }
    },

    /**
     * @param {Boolean} bEnabled
     */
    setIsEnabled:function (bEnabled) {
        this._super(bEnabled);

        if (this._selectedImage) {
            this._selectedImage.setIsVisible(false);
        }

        if (bEnabled) {
            this._normalImage.setIsVisible(true);

            if (this._disabledImage) {
                this._disabledImage.setIsVisible(false);
            }
        }
        else {
            if (this._disabledImage) {
                this._disabledImage.setIsVisible(true);
                this._normalImage.setIsVisible(false);
            }
            else {
                this._normalImage.setIsVisible(true);
            }
        }
    }
});

/**
 * create a menu item from sprite
 * @param {Image} normal normal state image
 * @param {Image|Null} selected selected state image
 * @param {Image|cc.Node|Null} three disabled state image OR target node
 * @param {String|function|cc.Node|Null} four callback function name in string or actual function, OR target Node
 * @param {String|function|Null} five callback function name in string or actual function
 * @return {cc.MenuItemSprite}
 * @example
 * // Example
 * var item = cc.MenuItemSprite.create(normalImage)//create a menu item from a sprite with no functionality
 *
 * var item = cc.MenuItemSprite.create(normalImage, selectedImage)//create a menu Item, nothing will happen when clicked
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage)//same above, but with disabled state image
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, targetNode, 'callback')//create a menu item, when clicked runs targetNode.callback()
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage, targetNode, targetNode.callback)
 * //same as above, but with disabled image, and passing in callback function
 */
cc.MenuItemSprite.create = function (normalSprite, selectedSprite, three, four, five)//overloaded function
{
    var ret = new cc.MenuItemSprite();
    //when you send 4 arguments, five is undefined
    if (five) {
        ret.initFromNormalSprite(normalSprite, selectedSprite, three, four, five);
    }
    else if (four) {
        return cc.MenuItemSprite.create(normalSprite, selectedSprite, null, three, four);
    }
    else {
        return cc.MenuItemSprite.create(normalSprite, selectedSprite, three, null, null);
    }
    return ret;
};


/**
 * cc.MenuItemImage accepts images as items.<br/>
 * The images has 3 different states:<br/>
 * - unselected image<br/>
 * - selected image<br/>
 * - disabled image<br/>
 * <br/>
 * For best results try that all images are of the same size<br/>
 * @class
 * @extends cc.MenuItemSprite
 */
cc.MenuItemImage = cc.MenuItemSprite.extend(/** @lends cc.MenuItemImage# */{

    /**
     * @return {Boolean}
     */
    initFromNormalImage:function (normalImage, selectedImage, disabledImage, target, selector) {
        var normalSprite = cc.Sprite.create(normalImage);
        var selectedSprite = null;
        var disabledSprite = null;

        if (selectedImage) {
            selectedSprite = cc.Sprite.create(selectedImage);
        }

        if (disabledImage) {
            disabledSprite = cc.Sprite.create(disabledImage);
        }
        return this.initFromNormalSprite(normalSprite, selectedSprite, disabledSprite, target, selector);
    }
});

/**
 * creates a new menu item image
 * @param {String} normalImage file name for normal state
 * @param {String} selectedImage image for selected state
 * @param {String|cc.Node} three Disabled image OR target
 * @param {cc.Node|String|function|Null} four cc.Node target to run callback when clicked OR the callback
 * @param {String|function|Null} five callback function, either name in string, or pass the whole function
 * @return {cc.MenuItemImage}
 * @example
 * // Example
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', gameScene, 'run')
 * //create a dom menu item with normal and selected state, when clicked it will run the run function from gameScene object
 *
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', 'disabled.png',  gameScene, gameScene.run)
 * //same as above, but pass in the actual function and disabled image
 */
cc.MenuItemImage.create = function (normalImage, selectedImage, three, four, five) {
    if (arguments.length == 4) {
        return cc.MenuItemImage.create(normalImage, selectedImage, null, three, four);
    }
    var ret = new cc.MenuItemImage();
    if (ret.initFromNormalImage(normalImage, selectedImage, three, four, five)) {
        return ret;
    }
    return null;
};


/**
 * A simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemToggle = cc.MenuItem.extend(/** @lends cc.MenuItemToggle# */{

    /**
     * this identifies this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} Opacity
     */
    setOpacity:function (Opacity) {
        this._opacity = Opacity;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setOpacity(Opacity);
            }
        }
    },
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} Color
     */
    setColor:function (Color) {
        this._color = Color;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setColor(Color);
            }
        }
    },
    _selectedIndex:0,

    /**
     * @return {Number}
     */
    getSelectedIndex:function () {
        return this._selectedIndex;
    },

    /**
     * @param {Number} SelectedIndex
     */
    setSelectedIndex:function (SelectedIndex) {
        if (SelectedIndex != this._selectedIndex) {
            this._selectedIndex = SelectedIndex;
            this.removeChildByTag(cc.CURRENT_ITEM, false);
            var item = this._subItems[this._selectedIndex];
            this.addChild(item, 0, cc.CURRENT_ITEM);
            var s = item.getContentSize();
            this.setContentSize(s);
            item.setPosition(cc.ccp(s.width / 2, s.height / 2));
        }
    },
    _subItems:[],

    /**
     * similar to get children
     * @return {cc.MenuItem}
     */
    getSubItems:function () {
        return this._subItems;
    },

    /**
     * @param {cc.MenuItem} SubItems
     */
    setSubItems:function (SubItems) {
        this._subItems = SubItems;
    },

    /**
     * @param {cc.Node} args[0] the first item in the args array is a target
     * @param {function|String} args[1] the second item in the args array is the callback
     * @param {cc.MenuItem} args[2+] the rest in the array are cc.MenuItems
     * @return {Boolean}
     */
    initWithTarget:function (args) {
        var target = args[0], selector = args[1];
        this._super(target, selector);
        if (args.length == 2) {
            return false;
        }
        this._subItems = [];
        for (var i = 2; i < args.length; i++) {
            if (args[i]) {
                this._subItems.push(args[i]);
            }
        }
        this._selectedIndex = 0xffffffff;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     * @return {Boolean}
     */
    initWithItem:function (item) {
        this.initWithTarget(null, null);
        this._subItems = [];
        this._subItems.push(item);
        this._selectedIndex = 0xffffffff;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     */
    addSubItem:function (item) {
        this._subItems.push(item);
    },

    /**
     * activate the menu item
     */
    activate:function () {
        // update index
        if (this._isEnabled) {
            var newIndex = (this._selectedIndex + 1) % this._subItems.length;
            this.setSelectedIndex(newIndex);
        }
        this._super();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        this._subItems[this._selectedIndex].selected();
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();
        this._subItems[this._selectedIndex].unselected();
    },

    /**
     * @param {Boolean} enabled
     */
    setIsEnabled:function (enabled) {
        this._super(enabled);

        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setIsEnabled(enabled);
            }
        }
    },

    /**
     * returns the selected item
     * @return {cc.MenuItem}
     */
    selectedItem:function () {
        return this._subItems[this._selectedIndex];
    },
    setIsOpacityModifyRGB:function (value) {
    },
    getIsOpacityModifyRGB:function () {
    }
});

/**
 * create a simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @return {cc.MenuItemToggle}
 * @example
 * // Example
 *
 * //create a toggle item with 2 menu items (which you can then toggle between them later)
 * var toggler = cc.MenuItemToggle.create(this, this.callback, cc.MenuItemFont.create("On"), cc.MenuItemFont.create("Off"))
 * //Note: the first param is the target, the second is the callback function, afterwards, you can pass in any number of menuitems
 *
 * //if you pass only 1 variable, then it must be a cc.MenuItem
 * var notYetToggler = cc.MenuItemToggle.create(cc.MenuItemFont.create("On"));//it is useless right now, until you add more stuff to it
 * notYetToggler.addSubItem(cc.MenuItemFont.create("Off"));
 * //this is useful for constructing a toggler without a callback function (you wish to control the behavior from somewhere else)
 */
cc.MenuItemToggle.create = function (/*Multiple arguments follow*/) {
    var ret = new cc.MenuItemToggle();
    if (arguments.length == 1) {
        ret.initWithItem(arguments);
    } else {
        ret.initWithTarget(arguments);
    }
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.CCMENU_STATE_WAITING = 0;
/**
 * @constant
 * @type Number
 */
cc.CCMENU_STATE_TRACKING_TOUCH = 1;
/**
 * @constant
 * @type Number
 */
cc.CCMENU_TOUCH_PRIORITY = -128;
/**
 * @constant
 * @type Number
 */
cc.DEFAULT_PADDING = 5;

/**
 * <p> Features and Limitation:<br/>
 *  - You can add MenuItem objects in runtime using addChild:<br/>
 *  - But the only accecpted children are MenuItem objects</p>
 * @class
 * @extends cc.Layer
 */
cc.Menu = cc.Layer.extend(/** @lends cc.Menu# */{
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._color = color;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setColor(this._color);
            }
        }
    },
    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} opa
     */
    setOpacity:function (opa) {
        this._opacity = opa;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setOpacity(this._opacity);
            }
        }
    },
    _selectedItem:null,
    /**
     * initializes an empty cc.Menu
     * @return {Boolean}
     */
    init:function () {
        if (this._super()) {
            this.setIsTouchEnabled(true);
            var s = cc.Director.sharedDirector().getWinSize();
            this._isRelativeAnchorPoint = false;
            this.setAnchorPoint(cc.ccp(0.5, 0.5));
            this.setContentSize(s);
            var r = new cc.Rect();
            cc.Application.sharedApplication().statusBarFrame(r);
            var orientation = cc.Director.sharedDirector().getDeviceOrientation();
            if (orientation == cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT || orientation == cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT) {
                s.height -= r.size.width;
            }
            else {
                s.height -= r.size.height;
            }
            this.setPosition(cc.ccp(s.width / 2, s.height / 2));
            this._selectedItem = null;
            this._state = cc.CCMENU_STATE_WAITING;
            return true;
        }
        return false;
    },

    /**
     * initializes a cc.Menu with it's items
     * @param {Array} args
     * @return {Boolean}
     */
    initWithItems:function (args) {
        if (this.init()) {
            if (args.length > 0) {
                for (var i = 0; i < args.length; i++) {
                    if (args[i]) {
                        this.addChild(args[i], i);
                    }
                }
            }
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} child
     * @param {Number|Null} zOrder
     * @param {Number|Null} tag
     */
    addChild:function (child, zOrder, tag) {
        tag = tag || child._tag;
        this._super(child, zOrder, tag);
    },

    /**
     * align items vertically with default padding
     */
    alignItemsVertically:function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items vertically with specified padding
     * @param {Number} padding
     */
    alignItemsVerticallyWithPadding:function (padding) {
        var height = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                height += this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }

        var y = height / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.ccp(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2));
                y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }
    },

    /**
     * align items horizontally with default padding
     */
    alignItemsHorizontally:function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items horizontally with specified padding
     * @param {Number} padding
     */
    alignItemsHorizontallyWithPadding:function (padding) {
        var width = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }

        var x = -width / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.ccp(x + this._children[i].getContentSize().width * this._children[i].getScaleX() / 2, 0));
                x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }
    },

    /**
     * align items in columns
     * @example
     * // Example
     * menu.alignItemsInColumns(3,2,3)// this will create 3 columns, with 3 items for first column, 2 items for second and 3 for third
     *
     * menu.alignItemsInColumns(3,3)//this creates 2 columns, each have 3 items
     */
    alignItemsInColumns:function (/*Multiple Arguments*/) {
        var rows = [];
        for (var i = 0; i < arguments.length; i++) {
            rows.push(arguments[i]);
        }
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                cc.Assert(row < rows.length, "");

                rowColumns = rows[row];
                // can not have zero columns on a row
                cc.Assert(rowColumns, "");

                var tmp = this._children[i].getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    height += rowHeight + 5;

                    columnsOccupied = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
        // check if too many rows/columns for available menu items
        cc.Assert(!columnsOccupied, "");
        var winSize = cc.Director.sharedDirector().getWinSize();

        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0.0;
        var x = 0.0;
        var y = (height / 2);

        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (rowColumns == 0) {
                    rowColumns = rows[row];
                    w = winSize.width / (1 + rowColumns);
                    x = w;
                }

                var tmp = child.getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                child.setPosition(cc.ccp(x - winSize.width / 2,
                    y - child.getContentSize().height / 2));

                x += w;
                ++columnsOccupied;

                if (columnsOccupied >= rowColumns) {
                    y -= rowHeight + 5;

                    columnsOccupied = 0;
                    rowColumns = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
    },
    /**
     * align menu items in rows
     * @example
     * // Example
     * menu.alignItemsInRows(5,3)//this will align items to 2 rows, first row with 5 items, second row with 3
     *
     * menu.alignItemsInRows(4,4,4,4)//this creates 4 rows each have 4 items
     */
    alignItemsInRows:function (/*Multiple arguments*/) {
        var columns = [];
        for (var i = 0; i < arguments.length; i++) {
            columns.push(arguments[i]);
        }
        var columnWidths = [];
        var columnHeights = [];

        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                // check if too many menu items for the amount of rows/columns
                cc.Assert(column < columns.size(), "");

                columnRows = columns[column];
                // can't have zero rows on a column
                cc.Assert(columnRows, "");

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                columnHeight += (child.getContentSize().height + 5);
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    columnWidths.push(columnWidth);
                    columnHeights.push(columnHeight);
                    width += columnWidth + 10;

                    rowsOccupied = 0;
                    columnWidth = 0;
                    columnHeight = -5;
                    ++column;
                }
            }
        }
        // check if too many rows/columns for available menu items.
        cc.Assert(!rowsOccupied, "");

        var winSize = cc.Director.sharedDirector().getWinSize();

        column = 0;
        columnWidth = 0;
        columnRows = 0;
        var x = -width / 2;
        var y = 0.0;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (columnRows == 0) {
                    columnRows = columns[column];
                    y = columnHeights[column];
                }

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                child.setPosition(cc.ccp(x + columnWidths[column] / 2,
                    y - winSize.height / 2));

                y -= child.getContentSize().height + 10;
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    x += columnWidth + 5;
                    rowsOccupied = 0;
                    columnRows = 0;
                    columnWidth = 0;
                    ++column;
                }
            }
        }
    },

    /**
     * make the menu clickable
     */
    registerWithTouchDispatcher:function () {
        cc.TouchDispatcher.sharedDispatcher().addTargetedDelegate(this, cc.CCMENU_TOUCH_PRIORITY, true);
    },

    /**
     * @param {cc.Touch} touch
     * @return {Boolean}
     */
    ccTouchBegan:function (touch, e) {
        if (this._state != cc.CCMENU_STATE_WAITING || !this._isVisible) {
            return false;
        }

        for (var c = this._parent; c != null; c = c.getParent()) {
            if (!c.getIsVisible()) {
                return false;
            }
        }

        this._selectedItem = this._itemForTouch(touch);
        if (this._selectedItem) {
            this._state = cc.CCMENU_STATE_TRACKING_TOUCH;
            this._selectedItem.selected();
            return true;
        }
        return false;
    },

    /**
     * when a touch ended
     */
    ccTouchEnded:function (touch, e) {
        cc.Assert(this._state == cc.CCMENU_STATE_TRACKING_TOUCH, "[Menu ccTouchEnded] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
            this._selectedItem.activate();
        }
        this._state = cc.CCMENU_STATE_WAITING;
    },

    /**
     * touch cancelled
     */
    ccTouchCancelled:function (touch, e) {
        cc.Assert(this._state == cc.CCMENU_STATE_TRACKING_TOUCH, "[Menu ccTouchCancelled] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
        }
        this._state = cc.CCMENU_STATE_WAITING;
    },

    /**
     * touch moved
     * @param {cc.Touch} touch
     */
    ccTouchMoved:function (touch, e) {
        cc.Assert(this._state == cc.CCMENU_STATE_TRACKING_TOUCH, "[Menu ccTouchMoved] -- invalid state");
        var currentItem = this._itemForTouch(touch);
        if (currentItem != this._selectedItem) {
            if (this._selectedItem) {
                this._selectedItem.unselected();
            }
            this._selectedItem = currentItem;
            if (this._selectedItem) {
                this._selectedItem.selected();
            }
        }
    },

    /**
     * custom on exit
     */
    onExit:function () {
        if (this._state == cc.CCMENU_STATE_TRACKING_TOUCH) {
            this._selectedItem.unselected();
            this._state = cc.CCMENU_STATE_WAITING;
            this._selectedItem = null;
        }

        this._super();
    },

    setIsOpacityModifyRGB:function (value) {
    },
    getIsOpacityModifyRGB:function () {
    },
    _itemForTouch:function (touch) {
        var touchLocation = touch.locationInView(touch.view());
        //console.log("touchLocation",touchLocation)
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                if (this._children[i].getIsVisible() && this._children[i].getIsEnabled()) {
                    var local = this._children[i].convertToNodeSpace(touchLocation);
                    var r = this._children[i].rect();
                    r.origin = cc.PointZero();
                    if (cc.Rect.CCRectContainsPoint(r, local)) {
                        return this._children[i];
                    }
                }
            }

        }

        return null;
    },
    _state:-1
});

/**
 * create a new menu
 * @return {cc.Menu}
 * @example
 * // Example
 * var myMenu = cc.Menu.create(menuitem1, menuitem2, menuitem3)//there is no limit on how many menu item you can pass in
 */
cc.Menu.create = function (/*Multiple Arguments*/) {
    var ret = new cc.Menu();
    ret.initWithItems(arguments);
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 Orthogonal orientation
 * @constant
 * @type Number
 */
cc.TMXOrientationOrtho = 0;

/**
 * Hexagonal orientation
 * @constant
 * @type Number
 */

cc.TMXOrientationHex = 1;

/**
 * Isometric orientation
 * @constant
 * @type Number
 */
cc.TMXOrientationIso = 2;

/**
 * <p>cc.TMXTiledMap knows how to parse and render a TMX map.</p>
 *
 * <p>It adds support for the TMX tiled map format used by http://www.mapeditor.org <br />
 * It supports isometric, hexagonal and orthogonal tiles.<br />
 * It also supports object groups, objects, and properties.</p>
 *
 * <p>Features: <br />
 * - Each tile will be treated as an cc.Sprite<br />
 * - The sprites are created on demand. They will be created only when you call "layer.tileAt(position)" <br />
 * - Each tile can be rotated / moved / scaled / tinted / "opacitied", since each tile is a cc.Sprite<br />
 * - Tiles can be added/removed in runtime<br />
 * - The z-order of the tiles can be modified in runtime<br />
 * - Each tile has an anchorPoint of (0,0) <br />
 * - The anchorPoint of the TMXTileMap is (0,0) <br />
 * - The TMX layers will be added as a child <br />
 * - The TMX layers will be aliased by default <br />
 * - The tileset image will be loaded using the cc.TextureCache <br />
 * - Each tile will have a unique tag<br />
 * - Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z<br />
 * - Each object group will be treated as an cc.MutableArray <br />
 * - Object class which will contain all the properties in a dictionary<br />
 * - Properties can be assigned to the Map, Layer, Object Group, and Object</p>
 *
 * <p>Limitations: <br />
 * - It only supports one tileset per layer. <br />
 * - Embeded images are not supported <br />
 * - It only supports the XML format (the JSON format is not supported)</p>
 *
 * <p>Technical description: <br />
 * Each layer is created using an cc.TMXLayer (subclass of cc.SpriteBatchNode). If you have 5 layers, then 5 cc.TMXLayer will be created, <br />
 * unless the layer visibility is off. In that case, the layer won't be created at all. <br />
 * You can obtain the layers (cc.TMXLayer objects) at runtime by: <br />
 * - map.getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...<br />
 * - map.layerNamed(name_of_the_layer); </p>
 *
 * <p>Each object group is created using a cc.TMXObjectGroup which is a subclass of cc.MutableArray.<br />
 * You can obtain the object groups at runtime by: <br />
 * - map.objectGroupNamed(name_of_the_object_group); </p>
 *
 * <p>Each object is a cc.TMXObject.</p>
 *
 * <p>Each property is stored as a key-value pair in an cc.MutableDictionary.<br />
 * You can obtain the properties at runtime by: </p>
 *
 * <p>map.propertyNamed(name_of_the_property); <br />
 * layer.propertyNamed(name_of_the_property); <br />
 * objectGroup.propertyNamed(name_of_the_property); <br />
 * object.propertyNamed(name_of_the_property);</p>
 * @class
 * @extends cc.Node
 */
cc.TMXTiledMap = cc.Node.extend(/** @lends cc.TMXTiledMap# */{
    //the map's size property measured in tiles
    _mapSize:cc.SizeZero(),
    _tileSize:cc.SizeZero(),
    _properties:null,
    _objectGroups:null,
    _mapOrientation:null,
    //tile properties
    _TMXLayers:null,
    _tileProperties:[],

    /**
     * @return {cc.Size}
     */
    getMapSize:function () {
        return this._mapSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapSize:function (Var) {
        this._mapSize = Var;
    },

    /**
     * @return {cc.Size}
     */
    getTileSize:function () {
        return this._tileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setTileSize:function (Var) {
        this._tileSize = Var;
    },

    /**
     * map orientation
     * @return {Number}
     */
    getMapOrientation:function () {
        return this._mapOrientation;
    },

    /**
     * @param {Number} Var
     */
    setMapOrientation:function (Var) {
        this._mapOrientation = Var;
    },

    /**
     * object groups
     * @return {Array}
     */
    getObjectGroups:function () {
        return this._objectGroups;
    },

    /**
     * @param {Array} Var
     */
    setObjectGroups:function (Var) {
        this._objectGroups = Var;
    },

    /**
     * properties
     * @return {object}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {object} Var
     */
    setProperties:function (Var) {
        this._properties = Var;
    },

    /**
     * @param tmxFile
     * @return {Boolean}
     * @example
     * //example
     * var map = new cc.TMXTiledMap()
     * map.initWithTMXFile("hello.tmx");
     */
    initWithTMXFile:function (tmxFile) {
        cc.Assert(tmxFile != null && tmxFile.length > 0, "TMXTiledMap: tmx file should not be nil");

        this.setContentSize(cc.SizeZero());

        var mapInfo = cc.TMXMapInfo.create(tmxFile);

        if (!mapInfo) {
            return false;
        }
        cc.Assert(mapInfo.getTilesets().length != 0, "TMXTiledMap: Map not found. Please check the filename.");

        this._mapSize = mapInfo.getMapSize();
        this._tileSize = mapInfo.getTileSize();
        this._mapOrientation = mapInfo.getOrientation();
        this.setObjectGroups(mapInfo.getObjectGroups());
        this.setProperties(mapInfo.getProperties());
        this._tileProperties = mapInfo.getTileProperties();

        var idx = 0;

        var layers = mapInfo.getLayers();
        if (layers) {
            this._TMXLayers = new Object();

            var layerInfo = null;
            for (var i = 0, len = layers.length; i < len; i++) {
                layerInfo = layers[i];
                if (layerInfo && layerInfo.visible) {
                    var child = this._parseLayer(layerInfo, mapInfo);
                    this.addChild(child, idx, idx);
                    //todo add layer
                    // record the cc.TMXLayer object by it's name
                    var layerName = child.getLayerName();
                    this._TMXLayers[layerName] = child;

                    // update content size with the max size
                    var childSize = child.getContentSize();
                    var currentSize = this.getContentSize();
                    currentSize.width = Math.max(currentSize.width, childSize.width);
                    currentSize.height = Math.max(currentSize.height, childSize.height);
                    this.setContentSize(currentSize);

                    idx++;
                }
            }
        }
        return true;
    },

    /** return the TMXLayer for the specific layer
     * @param {String} layerName
     * @return {cc.TMXLayer}
     */
    layerNamed:function (layerName) {
        if (this._TMXLayers.hasOwnProperty(layerName)) {
            return this._TMXLayers[layerName];
        }
        return null;
    },

    /**
     *return the TMXObjectGroup for the secific group
     * @param {String} groupName
     * @return {cc.TMXObjectGroup}
     */
    objectGroupNamed:function (groupName) {
        if (this._objectGroups) {
            for (var i = 0; i < this._objectGroups.length; i++) {
                var objectGroup = this._objectGroups[i];
                if (objectGroup && objectGroup.getGroupName() == groupName) {
                    return objectGroup;
                }
            }
        }
        // objectGroup not found
        return null;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {String}
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName.toString()];
    },

    /**
     * Return properties dictionary for tile GID
     * @param {Number} GID
     * @return {object}
     */
    propertiesForGID:function (GID) {
        return this._tileProperties[GID];
    },

    _parseLayer:function (layerInfo, mapInfo) {
        var tileset = this._tilesetForLayer(layerInfo, mapInfo);
        var layer = cc.TMXLayer.create(tileset, layerInfo, mapInfo);
        // tell the layerinfo to release the ownership of the tiles map.
        layerInfo.ownTiles = false;
        layer.setupTiles();

        return layer;
    },

    _tilesetForLayer:function (layerInfo, mapInfo) {
        var size = layerInfo._layerSize;
        var tilesets = mapInfo.getTilesets();
        if (tilesets) {
            var tileset = null;
            for (var i = tilesets.length - 1; i >= 0; i--) {
                tileset = tilesets[i];
                if (tileset) {
                    for (var y = 0; y < size.height; y++) {
                        for (var x = 0; x < size.width; x++) {
                            var pos = (x + size.width * y).toString();
                            var gid = layerInfo._tiles[pos];
                            // XXX: gid == 0 --> empty tile
                            // Optimization: quick return
                            // if the layer is invalid (more than 1 tileset per layer) an cc.Assert will be thrown later
                            if (gid !== 0 && gid >= tileset.firstGid) {
                                return tileset;
                            }

                        }
                    }
                }
            }
        }

        // If all the tiles are 0, return empty tileset
        cc.Log("cocos2d: Warning: TMX Layer " + layerInfo.name + " has no tiles");
        return null;
    }
});

/**
 * Creates a TMX Tiled Map with a TMX file.
 * Implementation cc.TMXTiledMap
 * @param {String} tmxFile
 * @return {cc.TMXTiledMap|Null}
 * @example
 * //example
 * var map = cc.TMXTiledMap.create("hello.tmx");
 */
cc.TMXTiledMap.create = function (tmxFile) {
    var ret = new cc.TMXTiledMap();
    if (ret.initWithTMXFile(tmxFile)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribNone = 1 << 0;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribBase64 = 1 << 1;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribGzip = 1 << 2;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribZlib = 1 << 3;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyNone = 0;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyMap = 1;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyLayer = 2;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyObjectGroup = 3;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyObject = 4;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyTile = 5;

/** <p>cc.TMXLayerInfo contains the information about the layers like: <br />
 * - Layer name<br />
 * - Layer size <br />
 * - Layer opacity at creation time (it can be modified at runtime)  <br />
 * - Whether the layer is visible (if it's not visible, then the CocosNode won't be created) <br />
 *  <br />
 * This information is obtained from the TMX file.</p>
 * @class
 * @extends cc.Class
 */
cc.TMXLayerInfo = cc.Class.extend(/** @lends cc.TMXLayerInfo# */{
    _properties:[],
    name:"",
    _layerSize:null,
    _tiles:[],
    visible:null,
    _opacity:null,
    ownTiles:true,
    _minGID:100000,
    _maxGID:0,
    offset:cc.PointZero(),

    /**
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {Array} Var
     */
    setProperties:function (Var) {
        this._properties = Var;
    }
});

/**
 * <p>cc.TMXTilesetInfo contains the information about the tilesets like: <br />
 * - Tileset name<br />
 * - Tileset spacing<br />
 * - Tileset margin<br />
 * - size of the tiles<br />
 * - Image used for the tiles<br />
 * - Image size<br />
 *
 * This information is obtained from the TMX file. </p>
 * @class
 * @extends cc.Class
 */
cc.TMXTilesetInfo = cc.Class.extend(/** @lends cc.TMXTilesetInfo# */{

    /**
     * Tileset name
     */
    name:null,

    /**
     * First grid
     */
    firstGid:0,
    _tileSize:cc.SizeZero(),

    /**
     * Spacing
     */
    spacing:0,

    /**
     *  Margin
     */
    margin:0,

    /**
     * Filename containing the tiles (should be sprite sheet / texture atlas)
     */
    sourceImage:null,

    /**
     * Size in pixels of the image
     */
    imageSize:cc.SizeZero(),

    /**
     * @param {Number} gid
     * @return {cc.Rect}
     */
    rectForGID:function (gid) {
        var rect = cc.RectZero();
        rect.size = this._tileSize;
        gid = gid - parseInt(this.firstGid);
        var max_x = parseInt((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing));
        rect.origin.x = parseInt((gid % max_x) * (this._tileSize.width + this.spacing) + this.margin);
        rect.origin.y = parseInt(parseInt(gid / max_x) * (this._tileSize.height + this.spacing) + this.margin);
        return rect;
    }
});

/**
 * <p>cc.TMXMapInfo contains the information about the map like: <br/>
 *- Map orientation (hexagonal, isometric or orthogonal)<br/>
 *- Tile size<br/>
 *- Map size</p>
 *
 * <p>And it also contains: <br/>
 * - Layers (an array of TMXLayerInfo objects)<br/>
 * - Tilesets (an array of TMXTilesetInfo objects) <br/>
 * - ObjectGroups (an array of TMXObjectGroupInfo objects) </p>
 *
 * <p>This information is obtained from the TMX file. </p>
 * @class
 * @extends cc.SAXParser
 */
cc.TMXMapInfo = cc.SAXParser.extend(/** @lends cc.TMXMapInfo# */{
    // map orientation
    _orientation:null,
    _mapSize:cc.SizeZero(),
    _tileSize:cc.SizeZero(),
    _layers:null,
    _tileSets:null,
    _objectGroups:null,
    _parentElement:null,
    _parentGID:null,
    _layerAttribs:0,
    _storingCharacters:false,
    _properties:null,
    // tmx filename
    _TMXFileName:null,
    //current string
    _currentString:null,
    // tile properties
    _tileProperties:[],

    /**
     * @return {Number}
     */
    getOrientation:function () {
        return this._orientation;
    },

    /**
     * @param {Number} Var
     */
    setOrientation:function (Var) {
        this._orientation = Var;
    },

    /**
     * Map width & height
     * @return {cc.Size}
     */
    getMapSize:function () {
        return this._mapSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapSize:function (Var) {
        this._mapSize = Var;
    },

    /**
     * Tiles width & height
     * @return {cc.Size}
     */
    getTileSize:function () {
        return this._tileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setTileSize:function (Var) {
        this._tileSize = Var;
    },

    /**
     * Layers
     * @return {Array}
     */
    getLayers:function () {
        return this._layers;
    },

    /**
     * @param {cc.TMXLayerInfo} Var
     */
    setLayers:function (Var) {
        this._layers.push(Var);
    },

    /**
     * tilesets
     * @return {Array}
     */
    getTilesets:function () {
        return this._tileSets;
    },

    /**
     * @param {cc.TMXTilesetInfo} Var
     */
    setTilesets:function (Var) {
        this._tileSets.push(Var);
    },

    /**
     * ObjectGroups
     * @return {Array}
     */
    getObjectGroups:function () {
        return this._objectGroups;
    },

    /**
     * @param {cc.TMXObjectGroup} Var
     */
    setObjectGroups:function (Var) {
        this._objectGroups.push(Var);
    },

    /**
     * parent element
     * @return {Number}
     */
    getParentElement:function () {
        return this._parentElement;
    },

    /**
     * @param {Number} Var
     */
    setParentElement:function (Var) {
        this._parentElement = Var;
    },

    /**
     * parent GID
     * @return {Number}
     */
    getParentGID:function () {
        return this._parentGID;
    },

    /**
     * @param {Number} Var
     */
    setParentGID:function (Var) {
        this._parentGID = Var;
    },

    /**
     *  layer attribute
     * @return {Number}
     */
    getLayerAttribs:function () {
        return this._layerAttribs;
    },

    /**
     * @param {Number} Var
     */
    setLayerAttribs:function (Var) {
        this._layerAttribs = Var;
    },

    /**
     * is string characters?
     * @return {Boolean}
     */
    getStoringCharacters:function () {
        return this._storingCharacters;
    },

    /**
     * @param {Boolean} Var
     */
    setStoringCharacters:function (Var) {
        this._storingCharacters = Var;
    },

    /**
     * Properties
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {String} Var
     */
    setProperties:function (Var) {
        this._properties.push(Var);
    },

    /**
     * Initializes a TMX format with a  tmx file
     * @param tmxFile
     * @return {String}
     */
    initWithTMXFile:function (tmxFile) {
        this._tileSets = [];
        this._layers = [];
        this._TMXFileName = tmxFile;
        this._objectGroups = [];
        this._properties = [];
        this._tileProperties = [];

        // tmp vars
        this._currentString = "";
        this._storingCharacters = false;
        this._layerAttribs = cc.TMXLayerAttribNone;
        this._parentElement = cc.TMXPropertyNone;

        return this.parseXMLFile(this._TMXFileName);
    },

    /** Initalises parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file
     * @param {String} xmlFilename
     * @return {Element}
     */
    parseXMLFile:function (xmlFilename) {
        var mapXML = cc.SAXParser.shareParser().tmxParse(xmlFilename);

        // PARSE <map>
        var map = mapXML.documentElement;

        var version = map.getAttribute('version');
        var orientationStr = map.getAttribute('orientation');

        if (map.nodeName == "map") {
            if (version != "1.0" && version !== null) {
                cc.Log("cocos2d: TMXFormat: Unsupported TMX version:" + version);
            }

            if (orientationStr == "orthogonal")
                this.setOrientation(cc.TMXOrientationOrtho);
            else if (orientationStr == "isometric")
                this.setOrientation(cc.TMXOrientationIso);
            else if (orientationStr == "hexagonal")
                this.setOrientation(cc.TMXOrientationHex);
            else if (orientationStr !== null)
                cc.Log("cocos2d: TMXFomat: Unsupported orientation:" + this.getOrientation());

            var s = new cc.Size();
            s.width = parseFloat(map.getAttribute('width'));
            s.height = parseFloat(map.getAttribute('height'));
            this.setMapSize(s);

            s = new cc.Size();
            s.width = parseFloat(map.getAttribute('tilewidth'));
            s.height = parseFloat(map.getAttribute('tileheight'));
            this.setTileSize(s)

            // The parent element is now "map"
            this.setParentElement(cc.TMXPropertyMap);
        }

        // PARSE <tileset>
        var tilesets = map.getElementsByTagName('tileset');
        if (map.nodeName !== "map") {
            tilesets = []
            tilesets.push(map);
        }
        for (var i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];
            // If this is an external tileset then start parsing that
            var externalTilesetFilename = t.getAttribute('source');
            var imgpath = xmlFilename.substring(0, xmlFilename.lastIndexOf("/") + 1);
            if (externalTilesetFilename) {
                this.parseXMLFile(imgpath + externalTilesetFilename);
            }
            else {
                var tileset = new cc.TMXTilesetInfo();
                tileset.name = t.getAttribute('name') || "";
                tileset.firstGid = parseInt(t.getAttribute('firstgid')) || 1;
                tileset.spacing = parseInt(t.getAttribute('spacing')) || 0;
                tileset.margin = parseInt(t.getAttribute('margin')) || 0;

                var s = cc.Size;
                s.width = parseFloat(t.getAttribute('tilewidth'));
                s.height = parseFloat(t.getAttribute('tileheight'));
                tileset._tileSize = s;

                var image = t.getElementsByTagName('image')[0];
                var imgSource = image.getAttribute('source');
                if (imgSource) {
                    imgSource = imgpath + imgSource;
                }
                tileset.sourceImage = imgSource;
                this.setTilesets(tileset);
            }
        }

        // PARSE  <tile>
        var tiles = map.getElementsByTagName('tile');
        if (tiles) {
            for (var i = 0, len = tiles.length; i < len; i++) {
                var info = this.getTilesets()[0];
                var t = tiles[i];
                this.setParentGID(info.firstGid + parseInt(t.getAttribute('id')));
                this.setTileProperties(this.getParentGID());
                this.setParentElement(cc.TMXPropertyTile);
            }
        }

        // PARSE  <layer>
        var layers = map.getElementsByTagName('layer');
        if (layers) {
            for (var i = 0, len = layers.length; i < len; i++) {
                var l = layers[i];
                var data = l.getElementsByTagName('data')[0];

                var layer = new cc.TMXLayerInfo();
                layer.name = l.getAttribute('name');

                var s = new cc.Size;
                s.width = parseFloat(l.getAttribute('width'));
                s.height = parseFloat(l.getAttribute('height'));
                layer._layerSize = s;

                var visible = l.getAttribute('visible')
                layer.visible = !(visible == "0");

                var opacity = l.getAttribute('opacity') || 1;

                if (opacity) {
                    layer._opacity = parseInt(255 * parseFloat(opacity));
                }
                else {
                    layer._opacity = 255;
                }

                var x = parseFloat(l.getAttribute('x')) || 0;
                var y = parseFloat(l.getAttribute('y')) || 0;
                layer.offset = cc.ccp(x, y);

                var nodeValue = ''
                for (var j = 0; j < data.childNodes.length; j++) {
                    nodeValue += data.childNodes[j].nodeValue
                }

                // Unpack the tilemap data
                var compression = data.getAttribute('compression');
                cc.Assert(compression == null || compression == "gzip" || compression == "zlib", "TMX: unsupported compression method");
                switch (compression) {
                    case 'gzip':
                        layer._tiles = cc.unzipBase64AsArray(nodeValue, 4);
                        break;
                    case 'zlib':
                        //Not Implemented
                        break;
                    // Uncompressed
                    case null:
                    case '':
                        layer._tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4);
                        break;
                    default:
                        cc.Assert(this.getLayerAttribs() != cc.TMXLayerAttribNone, "TMX tile map: Only base64 and/or gzip/zlib maps are supported");
                }
                this.setLayers(layer);
                // The parent element is now "layer"
                this.setParentElement(cc.TMXPropertyLayer);
            }
        }

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        if (objectgroups) {
            for (var i = 0; i < objectgroups.length; i++) {
                var g = objectgroups[i];
                var objectGroup = new cc.TMXObjectGroup();
                objectGroup.setGroupName(g.getAttribute('name'));
                var positionOffset = new cc.Point();
                positionOffset.x = parseFloat(g.getAttribute('x')) * this.getTileSize().width || 0;
                positionOffset.y = parseFloat(g.getAttribute('y')) * this.getTileSize().height || 0;
                objectGroup.setPositionOffset(positionOffset);

                var objects = g.querySelectorAll('object')
                if (objects) {
                    for (var j = 0; j < objects.length; j++) {
                        var o = objects[j]
                        // The value for "type" was blank or not a valid class name
                        // Create an instance of TMXObjectInfo to store the object and its properties
                        var dict = new Object();

                        // Set the name of the object to the value for "name"
                        dict["name"] = o.getAttribute('name') || "";

                        // Assign all the attributes as key/name pairs in the properties dictionary
                        dict["type"] = o.getAttribute('type') || "";

                        dict["x"] = parseInt(o.getAttribute('x') || 0) + objectGroup.getPositionOffset().x;

                        var y = parseInt(o.getAttribute('y') || 0) + objectGroup.getPositionOffset().y;
                        // Correct y position. (Tiled uses Flipped, cocos2d uses Standard)
                        y = parseInt(this.getMapSize().height * this.getTileSize().height) - y - parseInt(o.getAttribute('height'));
                        dict["y"] = y;

                        dict["width"] = parseInt(o.getAttribute('width'));

                        dict["height"] = parseInt(o.getAttribute('height'));

                        // Add the object to the objectGroup
                        objectGroup.setObjects(dict);
                        // The parent element is now "object"
                        this.setParentElement(cc.TMXPropertyObject);
                    }
                }

                this.setObjectGroups(objectGroup);
                // The parent element is now "objectgroup"
                this.setParentElement(cc.TMXPropertyObjectGroup);
            }
        }

        // PARSE <map><property>
        this.setParentElement(cc.TMXPropertyMap);
        var properties = mapXML.querySelectorAll('map > properties > property')
        if (properties) {
            for (i = 0; i < properties.length; i++) {
                var property = properties[i]

                if (this.getParentElement() == cc.TMXPropertyNone) {
                    cc.Log("TMX tile map: Parent element is unsupported. Cannot add property named " + property.getAttribute('name') + " with value " + property.getAttribute('value'));
                }
                else if (this.getParentElement() == cc.TMXPropertyMap) {
                    // The parent element is the map
                    var value = new String(property.getAttribute('value'));
                    var key = property.getAttribute('name');
                    this.getProperties()[key] = value;
                }
                else if (this.getParentElement() == cc.TMXPropertyLayer) {
                    // The parent element is the last layer
                    var layer = this.getLayers()[0];
                    var value = new String(property.getAttribute('value'));
                    var key = property.getAttribute('name');
                    // Add the property to the layer
                    layer.getProperties()[key] = value;
                }
                else if (this.getParentElement() == cc.TMXPropertyObjectGroup) {
                    // The parent element is the last object group
                    var objectGroup = this.getObjectGroups()[0];
                    var value = new String(property.getAttribute('value'));
                    var key = property.getAttribute('name');
                    objectGroup.getProperties()[key] = value;
                }
                else if (this.getParentElement() == cc.TMXPropertyObject) {
                    // The parent element is the last object
                    var objectGroup = this.getObjectGroups()[0];
                    var dict = objectGroup.getObjects()[0];

                    var propertyName = property.getAttribute('name');
                    var propertyValue = new String(property.getAttribute('value'));
                    dict[propertyName] = propertyValue;
                }
                else if (this.getParentElement() == cc.TMXPropertyTile) {
                    var dict;
                    dict = this.getTileProperties()[this.getParentGID()];

                    var propertyName = property.getAttribute('name');
                    var propertyValue = new String(property.getAttribute('name'));

                    dict[propertyName] = propertyValue;
                }
            }
        }

        return map;
    },

    /**
     * @return {object}
     */
    getTileProperties:function () {
        return this._tileProperties;
    },

    /**
     * @param {Number} tileProperties
     */
    setTileProperties:function (tileProperties) {
        this._tileProperties[tileProperties] = {};
    },

    /**
     * @return {String}
     */
    getCurrentString:function () {
        return this._currentString;
    },

    /**
     * @param {String} currentString
     */
    setCurrentString:function (currentString) {
        this._currentString = currentString;
    },

    /**
     * @return {String}
     */
    getTMXFileName:function () {
        return this._TMXFileName;
    },

    /**
     * @param {String} fileName
     */
    setTMXFileName:function (fileName) {
        this._TMXFileName = fileName;
    }
});

/**
 * Creates a TMX Format with a tmx file
 * @param {String} tmxFile
 * @return {cc.TMXMapInfo}
 */
cc.TMXMapInfo.create = function (tmxFile) {
    var ret = new cc.TMXMapInfo();
    if (ret.initWithTMXFile(tmxFile)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.TMXObjectGroup represents the TMX object group.
 * @class
 * @extends cc.Class
 */
cc.TMXObjectGroup = cc.Class.extend(/** @lends cc.TMXObjectGroup# */{
    //name of the group
    _groupName:"",
    _positionOffset:cc.PointZero(),
    _properties:null,
    _objects:null,

    /**
     *  Constructor
     */
    ctor:function () {
        this._properties = [];
        this._objects = [];
    },

    /**
     * Offset position of child objects
     * @return {cc.Point}
     */
    getPositionOffset:function () {
        return this._positionOffset;
    },

    /**
     * @param {cc.Point} Var
     */
    setPositionOffset:function (Var) {
        this._positionOffset = Var;
    },

    /**
     * List of properties stored in a dictionary
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param properties
     */
    setProperties:function (properties) {
        this._properties.push(properties);
    },

    /**
     * @return {String}
     */
    getGroupName:function () {
        return this._groupName.toString();
    },

    /**
     * @param {String} groupName
     */
    setGroupName:function (groupName) {
        this._groupName = groupName;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {object}
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName];
    },

    /**
     * <p>Return the dictionary for the specific object name. <br />
     * It will return the 1st object found on the array for the given name.</p>
     * @param {String} objectName
     * @return {object|Null}
     */
    objectNamed:function (objectName) {
        if (this._objects && this._objects.length > 0) {
            for (var i = 0, len = this._objects.length; i < len; i++) {
                var name = this._objects[i]["name"];
                if (name && name == objectName) {
                    return this._objects[i];
                }
            }
        }
        // object not found
        return null;
    },

    /**
     * @return {Array}
     */
    getObjects:function () {
        return this._objects;
    },

    /**
     * @param {object} objects
     */
    setObjects:function (objects) {
        this._objects.push(objects);
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>cc.TMXLayer represents the TMX layer. </p>
 *
 * <p>It is a subclass of cc.SpriteBatchNode. By default the tiles are rendered using a cc.TextureAtlas. <br />
 * If you modify a tile on runtime, then, that tile will become a cc.Sprite, otherwise no cc.Sprite objects are created. <br />
 * The benefits of using cc.Sprite objects as tiles are: <br />
 * - tiles (cc.Sprite) can be rotated/scaled/moved with a nice API </p>
 *
 * <p>If the layer contains a property named "cc.vertexz" with an integer (in can be positive or negative), <br />
 * then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth. </p>
 *
 * <p>On the other hand, if the "cc.vertexz" property has the "automatic" value, then the tiles will use an automatic vertex Z value. <br />
 * Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:  </p>
 *
 * glAlphaFunc( GL_GREATER, value ) <br />
 *
 * <p>"value" by default is 0, but you can change it from Tiled by adding the "cc_alpha_func" property to the layer. <br />
 * The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different value, like 0.5.</p>
 * @class
 * @extends cc.SpriteBatchNode
 */
cc.TMXLayer = cc.SpriteBatchNode.extend(/** @lends cc.TMXLayer# */{
    //size of the layer in tiles
    _layerSize:cc.SizeZero(),
    _mapTileSize:cc.SizeZero(),
    _tiles:null,
    _tileSet:null,
    _layerOrientation:null,
    _properties:null,
    //name of the layer
    _layerName:"",
    //TMX Layer supports opacity
    _opacity:255,
    _minGID:null,
    _maxGID:null,
    //Only used when vertexZ is used
    _vertexZvalue:null,
    _useAutomaticVertexZ:null,
    _alphaFuncValue:null,
    //used for optimization
    _reusedTile:null,
    _atlasIndexArray:null,
    //used for retina display
    _contentScaleFactor:null,

    /**
     *  Constructor
     */
    ctor:function () {
        this._super();
        this._children = [];
        this._descendants = [];
        this._isUseCache = true;
    },

    /**
     * @return {cc.Size}
     */
    getLayerSize:function () {
        return this._layerSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setLayerSize:function (Var) {
        this._layerSize = Var;
    },

    /**
     * Size of the map's tile (could be different from the tile's size)
     * @return {cc.Size}
     */
    getMapTileSize:function () {
        return this._mapTileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapTileSize:function (Var) {
        this._mapTileSize = Var;
    },

    /**
     * Pointer to the map of tiles
     * @return {Array}
     */
    getTiles:function () {
        return this._tiles;
    },

    /**
     * @param {Array} Var
     */
    setTiles:function (Var) {
        this._tiles = Var;
    },

    /**
     * Tile set information for the layer
     * @return {cc.TMXTilesetInfo}
     */
    getTileSet:function () {
        return this._tileSet;
    },

    /**
     * @param {cc.TMXTilesetInfo} Var
     */
    setTileSet:function (Var) {
        this._tileSet = Var;
    },

    /**
     * Layer orientation, which is the same as the map orientation
     * @return {Number}
     */
    getLayerOrientation:function () {
        return this._layerOrientation;
    },

    /**
     * @param {Number} Var
     */
    setLayerOrientation:function (Var) {
        this._layerOrientation = Var;
    },

    /**
     * properties from the layer. They can be added using Tiled
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {Array} Var
     */
    setProperties:function (Var) {
        this._properties = Var;
    },

    /**
     * Initializes a cc.TMXLayer with a tileset info, a layer info and a map info
     * @param {cc.TMXTilesetInfo} tilesetInfo
     * @param {cc.TMXLayerInfo} layerInfo
     * @param {cc.TMXMapInfo} mapInfo
     * @return {Boolean}
     */
    initWithTilesetInfo:function (tilesetInfo, layerInfo, mapInfo) {
        // XXX: is 35% a good estimate ?
        var size = layerInfo._layerSize;
        var totalNumberOfTiles = parseInt(size.width * size.height);
        var capacity = totalNumberOfTiles * 0.35 + 1; // 35 percent is occupied ?

        var texture = null;
        if (tilesetInfo) {
            texture = cc.TextureCache.sharedTextureCache().addImage(tilesetInfo.sourceImage.toString());
        }
        if (this.initWithTexture(texture, capacity)) {
            // layerInfo
            this._layerName = layerInfo.name;
            this._layerSize = layerInfo._layerSize;
            this._tiles = layerInfo._tiles;
            this._minGID = layerInfo._minGID;
            this._maxGID = layerInfo._maxGID;
            this._opacity = layerInfo._opacity;
            this._properties = layerInfo.getProperties();
            this._contentScaleFactor = cc.Director.sharedDirector().getContentScaleFactor();

            // tilesetInfo
            this._tileSet = tilesetInfo;

            // mapInfo
            this._mapTileSize = mapInfo.getTileSize();
            this._layerOrientation = mapInfo.getOrientation();

            // offset (after layer orientation is set);
            var offset = this._calculateLayerOffset(layerInfo.offset);
            this.setPosition(offset);

            this._atlasIndexArray = [];

            this.setContentSizeInPixels(cc.SizeMake(this._layerSize.width * this._mapTileSize.width,
                this._layerSize.height * this._mapTileSize.height));
            this._mapTileSize.width /= this._contentScaleFactor;
            this._mapTileSize.height /= this._contentScaleFactor;

            this._useAutomaticVertexZ = false;
            this._vertexZvalue = 0;
            this._alphaFuncValue = 0;
            return true;
        }
        return false;
    },

    /**
     * <p>Dealloc the map that contains the tile position from memory. <br />
     * Unless you want to know at runtime the tiles positions, you can safely call this method. <br />
     * If you are going to call layer.tileGIDAt() then, don't release the map</p>
     */
    releaseMap:function () {
        if (this._tiles) {
            this._tiles = null;
        }

        if (this._atlasIndexArray) {
            this._atlasIndexArray = null;
        }
    },

    /**
     * <p>Returns the tile (cc.Sprite) at a given a tile coordinate. <br/>
     * The returned cc.Sprite will be already added to the cc.TMXLayer. Don't add it again.<br/>
     * The cc.Sprite can be treated like any other cc.Sprite: rotated, scaled, translated, opacity, color, etc. <br/>
     * You can remove either by calling: <br/>
     * - layer.removeChild(sprite, cleanup); <br/>
     * - or layer.removeTileAt(ccp(x,y)); </p>
     * @param {cc.Point} pos
     * @return {cc.Sprite}
     */
    tileAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        var tile = null;
        var gid = this.tileGIDAt(pos);

        // if GID == 0, then no tile is present
        if (gid) {
            var z = pos.x + pos.y * this._layerSize.width;

            tile = this.getChildByTag(z);

            // tile not created yet. create it
            if (!tile) {
                var rect = this._tileSet.rectForGID(gid);
                rect = cc.RectMake(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor,
                    rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);

                tile = new cc.Sprite();
                tile.initWithBatchNode(this, rect);
                tile.setPosition(this.positionAt(pos));
                tile.setVertexZ(this._vertexZForPos(pos));
                tile.setAnchorPoint(cc.PointZero());
                tile.setOpacity(this._opacity);

                var indexForZ = this._atlasIndexForExistantZ(z);
                this.addSpriteWithoutQuad(tile, indexForZ, z);
            }
        }
        return tile;
    },

    /**
     * Returns the tile gid at a given tile coordinate. <br />
     * if it returns 0, it means that the tile is empty. <br />
     * This method requires the the tile map has not been previously released (eg. don't call layer.releaseMap())<br />
     * @param {cc.Point} pos
     * @return {Number}
     */
    tileGIDAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        var idx = pos.x + pos.y * this._layerSize.width;
        return this._tiles[idx];
    },

    /**
     * <p>Sets the tile gid (gid = tile global id) at a given tile coordinate.<br />
     * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor . Tileset Mgr +1.<br />
     * If a tile is already placed at that position, then it will be removed.</p>
     * @param {Number} gid
     * @param {cc.Point} pos
     */
    setTileGID:function (gid, pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
        cc.Assert(gid !== 0 || !(gid >= this._tileSet.firstGid), "TMXLayer: invalid gid:" + gid);

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        var currentGID = this.tileGIDAt(pos);

        if (currentGID != gid) {
            // setting gid=0 is equal to remove the tile
            if (gid == 0) {
                this.removeTileAt(pos);
            }

            // empty tile. create a new one
            else if (currentGID == 0) {
                this._insertTileForGID(gid, pos);
            }

            // modifying an existing tile with a non-empty tile
            else {
                var z = pos.x + pos.y * this._layerSize.width;
                var sprite = this.getChildByTag(z);
                if (sprite) {
                    var rect = this._tileSet.rectForGID(gid);
                    rect = cc.RectMake(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor, rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);
                    sprite.setTextureRectInPixels(rect, false, rect.size);
                    this._tiles[z] = gid;
                }
                else {
                    this._updateTileForGID(gid, pos);
                }
            }
        }
    },

    /**
     * Removes a tile at given tile coordinate
     * @param {cc.Point} pos
     */
    removeTileAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        var gid = this.tileGIDAt(pos);

        if (gid) {
            var z = pos.x + pos.y * this._layerSize.width;
            var atlasIndex = this._atlasIndexForExistantZ(z);
            // remove tile from GID map
            this._tiles[z] = 0;

            // remove tile from atlas position array
            cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);

            // remove it from sprites and/or texture atlas
            var sprite = this.getChildByTag(z);

            if (sprite) {
                this.removeChild(sprite, true);
            }
            else {
                this._textureAtlas.removeQuadAtIndex(atlasIndex);

                // update possible children
                if (this._children) {
                    for (var i = 0, len = this._children.length; i < len; i++) {
                        var child = this._children[i];
                        if (child) {
                            var ai = child.getAtlasIndex();
                            if (ai >= atlasIndex) {
                                child.setAtlasIndex(ai - 1);
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * Returns the position in pixels of a given tile coordinate
     * @param {cc.Point} pos
     * @return {cc.Point}
     */
    positionAt:function (pos) {
        var ret = cc.PointZero();
        switch (this._layerOrientation) {
            case cc.TMXOrientationOrtho:
                ret = this._positionForOrthoAt(pos);
                break;
            case cc.TMXOrientationIso:
                ret = this._positionForIsoAt(pos);
                break;
            case cc.TMXOrientationHex:
                ret = this._positionForHexAt(pos);
                break;
        }
        return ret;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {Number}
     * //todo
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName];
    },

    /**
     * Creates the tiles
     */
    setupTiles:function () {
        // Optimization: quick hack that sets the image size on the tileset
        var textureCache = this._textureAtlas.getTexture();
        this._tileSet.imageSize = new cc.Size(textureCache.width, textureCache.height);

        // By default all the tiles are aliased
        // pros:
        //  - easier to render
        // cons:
        //  - difficult to scale / rotate / etc.
        //this._textureAtlas.getTexture().setAliasTexParameters();

        // Parse cocos2d properties
        this._parseInternalProperties();
        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());

        for (var y = 0; y < this._layerSize.height; y++) {
            for (var x = 0; x < this._layerSize.width; x++) {
                var pos = x + this._layerSize.width * y;
                var gid = this._tiles[pos];

                // XXX: gid == 0 -. empty tile
                if (gid != 0) {
                    this._appendTileForGID(gid, cc.ccp(x, y));
                    // Optimization: update min and max GID rendered by the layer
                    this._minGID = Math.min(gid, this._minGID);
                    this._maxGID = Math.max(gid, this._maxGID);
                }
            }
        }

        cc.Assert(this._maxGID >= this._tileSet.firstGid &&
            this._minGID >= this._tileSet.firstGid, "TMX: Only 1 tilset per layer is supported");
    },

    /**
     * cc.TMXLayer doesn't support adding a cc.Sprite manually.
     * @warning addChild(child); is not supported on cc.TMXLayer. Instead of setTileGID.
     * @param {cc.Node} child
     */
    addChild:function (child) {
        cc.Assert(0, "addChild: is not supported on cc.TMXLayer. Instead use setTileGID:at:/tileAt:");
    },

    /**
     * Remove child
     * @param  {cc.Node} child
     * @param  {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        var sprite = child;

        // allows removing nil objects
        if (!sprite)
            return;

        cc.Assert(cc.ArrayContainsObject(this._children, sprite), "Tile does not belong to TMXLayer");

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        var atlasIndex = cc.ArrayGetIndexOfObject(this._children,sprite);
        var zz = this._atlasIndexArray[atlasIndex];
        this._tiles[zz] = 0;
        cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);
        this._super(sprite, cleanup);
    },

    /**
     *  Draw
     */
    draw:function () {
        if (this._useAutomaticVertexZ) {
            //TODO need to fix
            //glEnable(GL_ALPHA_TEST);
            //glAlphaFunc(GL_GREATER, this._alphaFuncValue);
        }

        this._super();

        if (this._useAutomaticVertexZ) {
            //glDisable(GL_ALPHA_TEST);
        }
    },

    /**
     * @return {String}
     */
    getLayerName:function () {
        return this._layerName.toString();
    },

    /**
     * @param {String} layerName
     */
    setLayerName:function (layerName) {
        this._layerName = layerName;
    },

    _positionForIsoAt:function (pos) {
        var xy = cc.PointMake(this._mapTileSize.width / 2 * ( this._layerSize.width + pos.x - pos.y - 1),
            this._mapTileSize.height / 2 * (( this._layerSize.height * 2 - pos.x - pos.y) - 2));
        return xy;
    },

    _positionForOrthoAt:function (pos) {
        var xy = cc.PointMake(pos.x * this._mapTileSize.width,
            (this._layerSize.height - pos.y - 1) * this._mapTileSize.height);
        return xy;
    },

    _positionForHexAt:function (pos) {
        var diffY = 0;
        if (pos.x % 2 == 1) {
            diffY = -this._mapTileSize.height / 2;
        }

        var xy = cc.PointMake(pos.x * this._mapTileSize.width * 3 / 4,
            (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY);
        return xy;
    },

    _calculateLayerOffset:function (pos) {
        var ret = cc.PointZero();
        switch (this._layerOrientation) {
            case cc.TMXOrientationOrtho:
                ret = cc.ccp(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
                break;
            case cc.TMXOrientationIso:
                ret = cc.ccp((this._mapTileSize.width / 2) * (pos.x - pos.y),
                    (this._mapTileSize.height / 2 ) * (-pos.x - pos.y));
                break;
            case cc.TMXOrientationHex:
                ret = cc.ccp(0, 0);
                cc.Log("cocos2d:offset for hexagonal map not implemented yet");
                break;
        }
        return ret;
    },

    _appendTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.RectMake(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor,
            rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);
        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        var z = pos.x + pos.y * this._layerSize.width;
        this._reusedTile = new cc.Sprite();
        this._reusedTile.setParent(this);
        this._reusedTile.initWithBatchNode(this, rect);
        this._reusedTile.setPosition(this.positionAt(pos));
        this._reusedTile.setVertexZ(this._vertexZForPos(pos));
        this._reusedTile.setAnchorPoint(cc.PointZero());
        this._reusedTile.setOpacity(this._opacity);
        this._reusedTile.setTag(z);
        // optimization:
        // The difference between _appendTileForGID and _insertTileForGID is that append is faster, since
        // it appends the tile at the end of the texture atlas
        //todo fix
        var indexForZ = this._atlasIndexArray.length;

        // don't add it using the "standard" way.
        this.addQuadFromSprite(this._reusedTile, indexForZ);

        // append should be after addQuadFromSprite since it modifies the quantity values
        this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
        return this._reusedTile;
    },

    _insertTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.RectMake(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor, rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);

        var z = parseInt(pos.x + pos.y * this._layerSize.width);
        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this._reusedTile = new cc.Sprite();
        this._reusedTile.setParent(this);
        this._reusedTile.initWithBatchNode(this, rect);
        this._reusedTile.setPositionInPixels(this.positionAt(pos));
        this._reusedTile.setVertexZ(this._vertexZForPos(pos));
        this._reusedTile.setAnchorPoint(cc.PointZero());
        this._reusedTile.setOpacity(this._opacity);

        // get atlas index
        var indexForZ = this._atlasIndexForNewZ(z);

        // Optimization: add the quad without adding a child
        this.addQuadFromSprite(this._reusedTile, indexForZ);

        // insert it into the local atlasindex array
        this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
        // update possible children
        if (this._children) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var child = this._children[i];
                if (child) {
                    var ai = child.getAtlasIndex();
                    if (ai >= indexForZ) {
                        child.setAtlasIndex(ai + 1);
                    }
                }
            }
        }
        this._tiles[z] = gid;
        return this._reusedTile;
    },

    _updateTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.RectMake(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor,
            rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);
        var z = pos.x + pos.y * this._layerSize.width;

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.boundingBoxToWorld());
        this._reusedTile = new cc.Sprite();
        this._reusedTile.initWithBatchNode(this, rect);

        this._reusedTile.setPositionInPixels(this.positionAt(pos));
        this._reusedTile.setVertexZ(this._vertexZForPos(pos));
        this._reusedTile.setAnchorPoint(cc.PointZero());
        this._reusedTile.setOpacity(this._opacity);

        // get atlas index
        var indexForZ = this._atlasIndexForExistantZ(z);
        this._reusedTile.setAtlasIndex(indexForZ);
        this._reusedTile.setDirty(true);
        this._reusedTile.updateTransform();
        this._tiles[z] = gid;

        return this._reusedTile;
    },

    //The layer recognizes some special properties, like cc_vertez
    _parseInternalProperties:function () {
    // if cc_vertex=automatic, then tiles will be rendered using vertexz

        var vertexz = this.propertyNamed("cc_vertexz");
        if (vertexz) {
            if (vertexz == "automatic") {
                this._useAutomaticVertexZ = true;
            }
            else {
                this._vertexZvalue = parseInt(vertexz);
            }
        }

        var alphaFuncVal = this.propertyNamed("cc_alpha_func");
        if (alphaFuncVal) {
            this._alphaFuncValue = parseInt(alphaFuncVal);
        }
    },

    _vertexZForPos:function (pos) {
        var ret = 0;
        var maxVal = 0;
        if (this._useAutomaticVertexZ) {
            switch (this._layerOrientation) {
                case cc.TMXOrientationIso:
                    maxVal = this._layerSize.width + this._layerSize.height;
                    ret = -(maxVal - (pos.x + pos.y));
                    break;
                case cc.TMXOrientationOrtho:
                    ret = -(this._layerSize.height - pos.y);
                    break;
                case cc.TMXOrientationHex:
                    cc.Assert(0, "TMX Hexa zOrder not supported");
                    break;
                default:
                    cc.Assert(0, "TMX invalid value");
                    break;
            }
        }
        else {
            ret = this._vertexZvalue;
        }
        return ret;
    },

    _atlasIndexForExistantZ:function (z) {
        var item;
        if (this._atlasIndexArray) {
            for (var i = 0; i < this._atlasIndexArray.length; i++) {
                item = this._atlasIndexArray[i]
                if (item == z) {
                    break;
                }
            }
        }
        cc.Assert(item, "TMX atlas index not found. Shall not happen");
        return i;
    },

    _atlasIndexForNewZ:function (z) {
        for (var i = 0; i < this._atlasIndexArray.length; i++) {
            var val = this._atlasIndexArray[i];
            if (z < val)
                break;
        }
        return i;
    }
});

/**
 * Creates a cc.TMXLayer with an tile set info, a layer info and a map info
 * @param {cc.TMXTilesetInfo} tilesetInfo
 * @param {cc.TMXLayerInfo} layerInfo
 * @param {cc.TMXMapInfo} mapInfo
 * @return {cc.TMXLayer|Null}
 */
cc.TMXLayer.create = function (tilesetInfo, layerInfo, mapInfo) {
    var ret = new cc.TMXLayer();
    if (ret.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo)) {
        return ret;
    }
    return null;
};

/**
 * cc.TMXLayer - atlasIndex and Z
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 */
cc.compareInts = function (a, b) {
    return a - b;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.PointObject = cc.Class.extend(/** @lends cc.PointObject# */{
    _ratio:null,
    _offset:null,
    _child:null,

    /**
     * @return  {cc.Point}
     */
    getRatio:function () {
        return this._ratio;
    },

    /**
     * @param  {cc.Point} value
     */
    setRatio:function (value) {
        this._ratio = value;
    },

    /**
     * @return  {cc.Point}
     */
    getOffset:function () {
        return this._offset;
    },

    /**
     * @param {cc.Point} value
     */
    setOffset:function (value) {
        this._offset = value;
    },

    /**
     * @return {cc.Node}
     */
    getChild:function () {
        return this._child;
    },

    /**
     * @param  {cc.Node} value
     */
    setChild:function (value) {
        this._child = value;
    },

    /**
     * @param  {cc.Point} ratio
     * @param  {cc.Point} offset
     * @return {Boolean}
     */
    initWithCCPoint:function (ratio, offset) {
        this._ratio = ratio;
        this._offset = offset;
        this._child = null;
        return true;
    }
});

/**
 * @param {cc.Point} ratio
 * @param {cc.Point} offset
 * @return {cc.PointObject}
 */
cc.PointObject.create = function (ratio, offset) {
    var ret = new cc.PointObject();
    ret.initWithCCPoint(ratio, offset);
    return ret;
}

/**
 * <p>cc.ParallaxNode: A node that simulates a parallax scroller<br />
 * The children will be moved faster / slower than the parent according the the parallax ratio. </p>
 * @class
 * @extends cc.Node
 */
cc.ParallaxNode = cc.Node.extend(/** @lends cc.ParallaxNode# */{
    _lastPosition:null,
    _parallaxArray:[],

    /**
     * @return {Array}
     */

    getParallaxArray:function () {
        return this._parallaxArray;
    },

    /**
     * @param {Array} value
     */
    setParallaxArray:function (value) {
        this._parallaxArray = value;
    },

    /**
     * Constructor
     */
    ctor:function () {
        this._parallaxArray = [];
        this._lastPosition = cc.PointMake(-100, -100);
    },

    /**
     * Adds a child to the container with a z-order, a parallax ratio and a position offset
     * It returns self, so you can chain several addChilds.
     * @param {cc.Node} child
     * @param {Number} z
     * @param {cc.Point} ratio
     * @param {cc.Point} offset
     * @example
     * //example
     * voidNode.addChild(background, -1, cc.ccp(0.4, 0.5), cc.PointZero());
     */
    addChild:function (child, z, ratio, offset) {
        if (arguments.length == 3) {
            cc.Assert(0, "ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
            return;
        }
        cc.Assert(child != null, "Argument must be non-nil");
        var obj = cc.PointObject.create(ratio, offset);
        obj.setChild(child);
        this._parallaxArray.push(obj);

        var pos = this._position;
        pos.x = pos.x * ratio.x + offset.x;
        pos.y = pos.y * ratio.y + offset.y;
        child.setPosition(pos);

        this._super(child, z, child.getTag());
    },

    /**
     *  Remove Child
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     * @example
     * //example
     * voidNode.removeChild(background,true);
     */
    removeChild:function (child, cleanup) {
        for (var i = 0; i < this._parallaxArray.length; i++) {
            var point = this._parallaxArray[i];
            if (point.getChild().isEqual(child)) {
                this._parallaxArray.splice(i, 1);
                break;
            }
        }
        this._super(child, cleanup);
    },

    /**
     *  Remove all children with cleanup
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        this._parallaxArray = [];
        this._super(cleanup);
    },

    /**
     * Visit
     */
    visit:function () {
        var pos = this._absolutePosition();
        if (!cc.Point.CCPointEqualToPoint(pos, this._lastPosition)) {
            for (var i = 0; i < this._parallaxArray.length; i++) {
                var point = this._parallaxArray[i];
                var x = -pos.x + pos.x * point.getRatio().x + point.getOffset().x;
                var y = -pos.y + pos.y * point.getRatio().y + point.getOffset().y;
                point.getChild().setPosition(cc.ccp(x, y));
            }
            this._lastPosition = pos;
        }
        this._super();
    },

    _absolutePosition:function () {
        var ret = this._position;
        var cn = this;
        while (cn.getParent() != null) {
            cn = cn.getParent();
            ret = cc.ccpAdd(ret, cn.getPosition());
        }
        return ret;
    }
});

/**
 * @return {cc.ParallaxNode}
 * @example
 * //example
 * var voidNode = cc.ParallaxNode.create();
 */
cc.ParallaxNode.create = function () {
    var ret = new cc.ParallaxNode();
    return ret;
}
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Whether the sound on or not
 * @type Boolean
 */
cc.sound = true;

/**
 * Support audio format
 * @type Boolean
 */
cc.capabilities = {
    mp3:false,
    ogg:false,
    wav:false
};

/**
 * Offer a VERY simple interface to play background music & sound effect.
 * @class
 * @extends   cc.Class
 */
cc.AudioManager = cc.Class.extend(/** @lends cc.AudioManager# */{
    _initialized:false,
    _supportedFormat:[ "mp3", "ogg", "wav" ],
    _requestedFormat:null,
    _sound_enable:true,
    _audioList:{},
    _activeAudioExt:-1,
    _bgmList:{},
    _isBgmPlaying:false,
    _playingBgm:null,
    _effectsVolume:1,
    /**
    * Constructor
    */
    ctor:function () {
        if (this._initialized)
            return;

        // init audio
        var au = document.createElement('audio');
        if (au.canPlayType) {
            cc.capabilities.mp3 = ("no" != au.canPlayType("audio/mpeg"))
                && ("" != au.canPlayType("audio/mpeg"));

            cc.capabilities.ogg = ("no" != au.canPlayType('audio/ogg; codecs="vorbis"'))
                && ("" != au.canPlayType('audio/ogg; codecs="vorbis"'));

            cc.capabilities.wav = ("no" != au.canPlayType('audio/wav; codecs="1"'))
                && ("" != au.canPlayType('audio/wav; codecs="1"'));

            // enable sound if any of the audio format is supported
            cc.sound = cc.capabilities.mp3 || cc.capabilities.ogg || cc.capabilities.wav;
        }
        this._initialized = true;
    },
    /**
     * Initialize sound type
     * @param {String} audioType
     * @return {Boolean}
     * @example
     * //example
     * cc.AudioManager.sharedEngine().init("mp3,ogg");
     */
    init:function (audioType) {
        if (audioType) {
            this._requestedFormat = new String(audioType)
        }
        else {
            // if no param is given to init we use mp3 by default
            this._requestedFormat = new String("mp3");
        }

        // detect the prefered audio format
        this._activeAudioExt = this._getSupportedAudioFormat();
        return this._sound_enable;
    },
    _getSupportedAudioFormat:function () {
        var extIdx = 0;
        // check for sound support by the browser
        if (!cc.sound) {
            this._sound_enable = false;
            return;
        }

        // check for MP3
        if ((this._requestedFormat.search(/mp3/i) != -1) && cc.capabilities.mp3) {
            return this._supportedFormat[extIdx];
        }

        // check for OGG/Vorbis
        if ((this._requestedFormat.search(/ogg/i) != -1) && cc.capabilities.ogg) {
            return this._supportedFormat[++extIdx];
        }

        // check for WAV
        if ((this._requestedFormat.search(/wav/i) != -1) && cc.capabilities.wav) {
            return this._supportedFormat[++extIdx];
        }

        // deactivate sound
        this._sound_enable = false;

        return -1;
    },
    /**
     * Preload background music resource.<br />
     * This method is called when cc.Loader preload  resources.
     * @param {String} path The path of the background music file without filename extension.
     */
    preloadBackgroundMusic:function (path) {
        if (this._sound_enable) {
            if (this._activeAudioExt == -1) return;
            var soundPath = path + "." + this._activeAudioExt;
            var soundCache = new Audio(soundPath);
            soundCache.preload = 'auto';

            soundCache.addEventListener('canplaythrough', function (e) {
                this.removeEventListener('canplaythrough', arguments.callee, false);
            }, false);
            soundCache.addEventListener("error", function (e) {
                cc.Loader.shareLoader().onResLoadingErr();
            }, false);
            soundCache.addEventListener("playing", function (e) {
                cc.sharedEngine._isBgmPlaying = true;
            }, false);
            soundCache.addEventListener("pause", function (e) {
                cc.sharedEngine._isBgmPlaying = false;
            }, false);

            // load it
            soundCache.load();

            this._bgmList[path] = soundCache
        }
        cc.Loader.shareLoader().onResLoaded();
    },
    /**
     * Play background music.
     * @param {String} path The path of the background music file without filename extension.
     * @param {Boolean} loop Whether the background music loop or not.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().playBackgroundMusic(path, false);
     */
    playBackgroundMusic:function (path, loop) {
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].pause();
        }
        this._playingBgm = path;
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].loop = loop || false;
            this._bgmList[this._playingBgm].play();
        }
    },
    /**
     * Stop playing background music.
     * @param {Boolean} releaseData If release the background music data or not.As default value is false.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().stopBackgroundMusic();
     */
    stopBackgroundMusic:function (releaseData) {
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].pause();
            this._bgmList[this._playingBgm].currentTime = 0;
            if (releaseData && this._bgmList.hasOwnProperty(this._playingBgm)) {
                delete this._bgmList[this._playingBgm];
            }
        }
    },
    /**
     * Pause playing background music.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().pauseBackgroundMusic();
     */
    pauseBackgroundMusic:function () {
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].pause();
        }
    },
    /**
     * Resume playing background music.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().resumeBackgroundMusic();
     */
    resumeBackgroundMusic:function () {
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].play();
        }
    },

    /**
     * Rewind playing background music.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().rewindBackgroundMusic();
     */
    rewindBackgroundMusic:function () {
        if (this._bgmList[this._playingBgm]) {
            this._bgmList[this._playingBgm].currentTime = 0;
            this._bgmList[this._playingBgm].play();
        }
    },
    willPlayBackgroundMusic:function () {
        return false;
    },

    /**
     * Whether the background music is playing.
     * @return {Boolean} If is playing return true,or return false.
     * @example
     * //example
     *  if (cc.AudioManager.sharedEngine().isBackgroundMusicPlaying()) {
     *      cc.Log("background music is playing");
     *  }
     *  else {
     *      cc.Log("background music is not playing");
     *  }
     */
    isBackgroundMusicPlaying:function () {
        return cc.sharedEngine._isBgmPlaying;
    },

    /**
     * The volume of the background music max value is 1.0,the min value is 0.0 .
     * @return {Number}
     * @example
     * //example
     * var volume = cc.AudioManager.sharedEngine().getBackgroundMusicVolume();
     */
    getBackgroundMusicVolume:function () {
        if (this._bgmList[this._playingBgm]) {
            return this._bgmList[this._playingBgm].volume;
        }
        else {
            return 0;
        }
    },

    /**
     * Set the volume of background music.
     * @param {Number} volume Volume must be in 0.0~1.0 .
     * @example
     * //example
     * cc.AudioManager.sharedEngine().setBackgroundMusicVolume(0.5);
     */
    setBackgroundMusicVolume:function (volume) {
        if (this._bgmList[this._playingBgm]) {
            if (volume > 1) {
                this._bgmList[this._playingBgm].volume = 1;
            }
            else if (volume < 0) {
                this._bgmList[this._playingBgm].volume = 0;
            }
            else {
                this._bgmList[this._playingBgm].volume = volume;
            }
        }
    },

    /**
     *The volume of the effects max value is 1.0,the min value is 0.0 .
     * @return {Number}
     * @example
     * //example
     * var effectVolume = cc.AudioManager.sharedEngine().getEffectsVolume();
     */
    getEffectsVolume:function () {
        return this._effectsVolume;
    },

    /**
     * Set the volume of sound effecs.
     * @param {Number} volume Volume must be in 0.0~1.0 .
     * @example
     * //example
     * cc.AudioManager.sharedEngine().setEffectsVolume(0.5);
     */
    setEffectsVolume:function (volume) {
        if (volume > 1) {
            this._effectsVolume = 1;
        }
        else if (volume < 0) {
            this._effectsVolume = 0;
        }
        else {
            this._effectsVolume = volume;
        }
        if (this._audioList) {
            for (var i in this._audioList) {
                this._audioList[i].volume = this._effectsVolume;
            }
        }
    },

    /**
     * Play sound effect.
     * @param {String} path The path of the sound effect  without filename extension.
     * @param {Boolean} loop Whether to loop the effect playing, default value is false
     * @example
     * //example
     * var soundId = cc.AudioManager.sharedEngine().playEffect(path);
     */
    playEffect:function (path, loop) {
        var soundCache = this._getEffectList(path);
        if (soundCache) {
            soundCache.loop = loop || false;
            soundCache.play();
        }
        return path;
    },

    /**
     * Pause playing sound effect.
     * @param {String} path The return value of function playEffect.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().pauseEffect(path);
     */
    pauseEffect:function (path) {
        if (this._audioList[path]) {
            this._audioList[path].pause();
        }
    },

    /**
     * Pause all playing sound effect.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().pauseAllEffects();
     */
    pauseAllEffects:function () {
        if (this._audioList) {
            for (var i in this._audioList) {
                this._audioList[i].pause();
            }
        }
    },

    /**
     * Resume playing sound effect.
     * @param {String} path The return value of function playEffect.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().resumeEffect(path);
     */
    resumeEffect:function (path) {
        if (this._audioList[path]) {
            this._audioList[path].play();
        }
    },

    /**
     * Resume all playing sound effect
     * @example
     * //example
     * cc.AudioManager.sharedEngine().resumeAllEffects();
     */
    resumeAllEffects:function () {
        if (this._audioList) {
            for (var i in this._audioList) {
                this._audioList[i].play();
            }
        }
    },

    /**
     * Stop playing sound effect.
     * @param {String} path The return value of function playEffect.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().stopEffect(path);
     */
    stopEffect:function (path) {
        if (this._audioList[path]) {
            this._audioList[path].pause();
            this._audioList[path].currentTime = 0;
        }
    },

    /**
     * Stop all playing sound effects.
     * @example
     * //example
     * cc.AudioManager.sharedEngine().stopAllEffects();
     */
    stopAllEffects:function () {
        if (this._audioList) {
            for (var i in this._audioList) {
                this._audioList[i].pause();
                this._audioList[i].currentTime = 0;
            }
        }
    },

    /**
     * Preload sound effect resource.
     * This method is called when cc.Loader preload  resources.
     * @param {String} path The path of the sound effect file without filename extension.
     */
    preloadEffect:function (path) {
        if (this._sound_enable) {
            if (this._activeAudioExt == -1) return;
            var soundPath = path + "." + this._activeAudioExt;
            var soundCache = new Audio(soundPath);
            soundCache.preload = 'auto';

            soundCache.addEventListener('canplaythrough', function (e) {
                this.removeEventListener('canplaythrough', arguments.callee,
                    false);
            }, false);
            soundCache.addEventListener("error", function (e) {
                cc.Loader.shareLoader().onResLoadingErr();
            }, false);

            // load it
            soundCache.load();
            this._audioList[path] = soundCache;
        }
        cc.Loader.shareLoader().onResLoaded();
    },

    /**
     * Unload the preloaded effect from internal buffer
     * @param {String} path
     * @example
     * //example
     * cc.AudioManager.sharedEngine().unloadEffect(EFFECT_FILE);
     */
    unloadEffect:function (path) {
        if (this._audioList.hasOwnProperty(path)) {
            delete this._audioList[path];
        }
    },
    _getEffectList:function (elt) {
        if (this._audioList != null) {
            return this._audioList[elt];
        }
        else {
            return null;
        }
    },
    /**
     *  Stop all background music and sound effects
     * @example
     * //example
     * cc.AudioManager.sharedEngine().end();
     */
    end:function () {
        this.stopBackgroundMusic();
        this.stopAllEffects();
    }
});

/**
 * Get the shared Engine object, it will new one when first time be called.
 * @return {cc.AudioManager}
 */
cc.AudioManager.sharedEngine = function () {
    if (!cc.sharedEngine) {
        cc.sharedEngine = new cc.AudioManager();
    }
    return cc.sharedEngine;
};
